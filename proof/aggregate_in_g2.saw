/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";

let do_prove = false;

enable_experimental;

include "proof-helpers.saw";
include "misc_rules_E2.saw";
include "algebraic-laws.saw";

include "fp_overrides.saw";
include "vect.saw";
include "exp.saw";
include "curve_operations.saw";
include "ec_mult.saw";
include "sgn0.saw";
include "deserialize-p1.saw";

include "fp2_overrides.saw";
include "exp2.saw";
include "curve_operations_e2.saw";
include "ec_mult2.saw";
include "psi.saw";
include "subgroup_check_g2.saw";
include "deserialize-p2.saw";

let do_prove = true;

// NOTE: we only consider inputs that either have the infinity-bit set or compressed-bit set

// aggregate_in_g2_error_precond describes the circumstances under which aggregate_in_g2 returns an error (assuming either the compressed bit is set of the infinity bit is set)
let {{
  aggregate_in_g2_error_precond : [96][8] -> Bool
  aggregate_in_g2_error_precond zwire =
      ~(zwire@0)@1 // not infinity
    /\ (   (uncompress_E2_x zwire)@0 >= `p
        \/ (uncompress_E2_x zwire)@1 >= `p
        \/ ~ is_square_fp2 (uncompress_E2_y2 zwire) // not on curve
        \/ uncompress_E2_x_fp zwire == Fp_2.field_zero // uncompresses to zero
        \/ ~ is_in_g2_impl (uncompress_E2_OK zwire) ) // not in group g2
}};

// case in which the input is not null and we return BLST_SUCCESS:
let blst_aggregate_in_g2_OK_nonnull_spec = do {
  //
  (out, out_ptr) <- ptr_to_fresh "blst_aggregate_in_g2_out" (llvm_struct "struct.POINTonE2");
  (inp, inp_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g2_in" (llvm_struct "struct.POINTonE2");
  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g2_zwire" (llvm_array 96 (llvm_int 8));
  //
  llvm_precond {{ (zwire@0)@0 }}; // compressed
  llvm_precond {{ POINTonE2_invariant inp }}; // inp is a valid point (precondition of add)
  llvm_precond {{ ~aggregate_in_g2_error_precond zwire }}; // no error condition
  //
  llvm_execute_func [out_ptr, inp_ptr, zwire_ptr];
  //
  new_out <- llvm_fresh_var "new_out" (llvm_struct "struct.POINTonE2");
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ POINTonE2_abs new_out == if (zwire@0)@1 then POINTonE2_abs out else point_dadd_affine Fp_2 (POINTonE2_abs inp) (uncompress_E2_OK zwire) }};
  //
  llvm_return (llvm_term {{ (`BLST_SUCCESS):[32] }});
};

// Special case: the input is null:

let blst_aggregate_in_g2_null_spec = do {
  //
  (out, out_ptr) <- ptr_to_fresh "blst_aggregate_in_g2_out" (llvm_struct "struct.POINTonE2");
  let inp_ptr = llvm_null;
  //
  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g2_zwire" (llvm_array 48 (llvm_int 8));
  llvm_precond {{ (zwire@0)@0 }}; // compressed
  llvm_precond {{ ~aggregate_in_g2_error_precond zwire }}; // no error condition
  //
  llvm_execute_func [out_ptr, inp_ptr, zwire_ptr];
  //
  new_out <- llvm_fresh_var "new_out" (llvm_struct "struct.POINTonE2");
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ POINTonE2_abs new_out ==
    if (zwire@0)@1
    then zero
    else projectify E (uncompress_E2_OK zwire)
  }};
  //
  llvm_return (llvm_term {{ (`BLST_SUCCESS):[32] }});
};

// here we cover the error cases:
let blst_aggregate_in_g2_error_spec = do {
  (out, out_ptr) <- ptr_to_fresh "blst_aggregate_in_g2_out" (llvm_struct "struct.POINTonE2");
  (inp, inp_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g2_in" (llvm_struct "struct.POINTonE2");
  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g2_zwire" (llvm_array 48 (llvm_int 8));
  llvm_precond {{ (zwire@0)@0 }}; // compressed
  llvm_precond {{ aggregate_in_g2_error_precond zwire }};
  llvm_execute_func [out_ptr, inp_ptr, zwire_ptr];
  ret <- llvm_fresh_var "blst_aggregate_in_g2_ret" (llvm_int 32);
  llvm_return (llvm_term ret);
  llvm_postcond {{ ret != `BLST_SUCCESS }};
  new_out <- llvm_fresh_var "new_out" (llvm_struct "struct.POINTonE2");
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ new_out == out }};
};


// TODO: old spec; keep?
let _blst_aggregate_in_g2_in_null_spec = do {
  //
  out_ptr <- llvm_alloc (llvm_struct "struct.POINTonE2");
  let inp_ptr = llvm_null;
  //
  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g2_zwire" (llvm_array 48 (llvm_int 8));
  llvm_precond {{ ~(zwire@0)@1 }}; // infinity bit not set
  llvm_precond {{ (zwire@0)@0 }}; // compressed
  llvm_precond {{ uncompress_E2_imp zwire != nothing }}; // decompression succeeds (this does not check for zero)
  llvm_precond {{ uncompress_E2_x_fp zwire != Fp.field_zero }}; // decompressed value is not zero
  llvm_precond {{ is_in_g2_impl (uncompress_E2_OK zwire)  }}; // subgroup check succeeds
  //
  llvm_execute_func [out_ptr, inp_ptr, zwire_ptr];
  //
  new_out <- llvm_fresh_var "new_out" (llvm_struct "struct.POINTonE2");
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ affinify E (POINTonE2_abs new_out) == uncompress_E2_OK zwire }};
  //
  llvm_return (llvm_term {{ (`BLST_SUCCESS):[32] }});
};

let overrides = foldr concat [vec_overrides,curve_operations_e2_ovs] [POINTonE2_Uncompress_OK_ov,POINTonE2_in_g2_ov];

// Assumptions

uncompress_not_point_O <- admit_cryptol {{ \x -> (is_point_O E' (uncompress_E2_OK x)) == if uncompress_E2_x_fp x != Fp_2.field_zero then False else apply is_point_O E' (uncompress_E2_OK x) }};

uncompress_on_curve <- admit_cryptol {{ \x -> (is_point_affine E' (uncompress_E2_OK x)) == True }};

// Proofs

custom_prove_cryptol {{ \p -> POINTonE2_affine_abs (POINTonE2_affine_rep p) == p }} w4;
custom_prove_cryptol {{ \p -> POINTonE1_affine_abs (POINTonE1_affine_rep p) == p }} w4;

blst_aggregate_in_g2_error_ov <- custom_verify
  "blst_aggregate_in_g2"
  [POINTonE2_Uncompress_BAD_ov,POINTonE2_Uncompress_OK_ov,POINTonE2_in_G2_ov]
  blst_aggregate_in_g2_error_spec
  (goal_num_ite 1 // preconditions of the subgroup check
    do {
      simplify (addsimps (concat POINTonE2_thms [uncompress_not_point_O, uncompress_on_curve]) empty_ss);
      w4_unint_z3 ["sqrt_fp","uncompress_E2_x_fp","uncompress_E2_x","uncompress_E2_y2","is_square_fp2","is_in_g2_impl"];
    }
    do {
      simplify (addsimps POINTonE2_thms empty_ss);
      simplify remove_higher_order_function_simpset;
      w4_unint_z3 ["sqrt_fp","uncompress_E2_x_fp","uncompress_E2_x","uncompress_E2_y2","is_square_fp","is_in_g2_impl","uncompress_E2_OK","is_point_affine_E"];
    });

blst_aggregate_in_g2_OK_nonnull_ov <- custom_verify
  "blst_aggregate_in_g2"
  overrides
  blst_aggregate_in_g2_OK_nonnull_spec
  (goal_num_ite 1 // preconditions of the subgroup check
    do {
      simplify (addsimps (concat POINTonE2_thms [uncompress_not_point_O, uncompress_on_curve]) empty_ss);
      w4_unint_z3 ["sqrt_fp2","uncompress_E2_x_fp","uncompress_E2_x","uncompress_E2_y2","is_square_fp2","is_in_g2_impl"];
    }
    do {
      simplify (addsimps misc_rules empty_ss);
      simplify (addsimps POINTonE2_thms empty_ss);
      print_readably;
      simplify remove_higher_order_function_simpset;
      w4_unint_z3 ["sqrt_fp2","uncompress_E2_x_fp","uncompress_E2_x","uncompress_E2_y2","is_square_fp2","is_in_g2_impl","uncompress_E2_OK","is_point_affine_E'"];
    });

blst_aggregate_in_g2_null_ov <- custom_verify
  "blst_aggregate_in_g2"
  overrides
  blst_aggregate_in_g2_null_spec
  (goal_num_ite 1 // preconditions of the subgroup check
    do {
      simplify (addsimps (concat POINTonE2_thms [uncompress_not_point_O, uncompress_on_curve]) empty_ss);
      w4_unint_z3 ["sqrt_fp2","uncompress_E2_x_fp","uncompress_E2_x","uncompress_E2_y2","is_square_fp2","is_in_g2_impl"];
    }
    do {
      simplify (addsimps misc_rules empty_ss);
      simplify (addsimps POINTonE2_thms empty_ss);
      unfolding ["POINTonE2_abs","POINTonE2_affine_rep"];
      let rewrite_unit = run (custom_prove_cryptol (rewrite (cryptol_ss ()) {{ fp_abs [ 8505329371266088957 , 17002214543764226050 , 6865905132761471162 , 8632934651105793861 , 6631298214892334189 , 1582556514881692819 ] == Fp.field_unit }}) w4);
      simplify (addsimp rewrite_unit fp_simpset);
      simplify remove_higher_order_function_simpset;
      w4_unint_z3 ["sqrt_fp2","uncompress_E2_x_fp","uncompress_E2_x","uncompress_E2_y2","is_square_fp2","is_in_g2_impl","uncompress_E2_OK","is_point_affine_E"];
    });
