/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

enable_experimental;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";
include "exp.saw";

import "../spec/Parameters.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE1_standalone.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";
//EC <- cryptol_load "../spec/ShortWeierstrassCurve.cry";

let do_prove = true;

let blst_hash_to_g1_impl_spec msg_len DST_len aug_len = do {
  p_ptr <- llvm_alloc POINTonE1_type;
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  llvm_execute_func [p_ptr, msg_ptr, llvm_term {{ `msg_len : [64] }}, DST_ptr, llvm_term {{ `DST_len : [64] }}, aug_ptr, llvm_term {{ `aug_len : [64] }}];
  llvm_points_to p_ptr (llvm_term {{ (POINTonE1_rep (hash_to_curve_opt_impl (aug#msg, DST))) }});
};

let map_to_g1_impl_nonnull_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u,u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  (v,v_ptr) <- ptr_to_fresh_readonly "v" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_precond {{ fp_invariant v }};
  llvm_execute_func [out_ptr, u_ptr, v_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_g1_impl [fp_abs u, fp_abs v]) }});
};

let isogeny_map_to_E1_impl_alias_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (iso_map_impl (POINTonE1_abs out)) }} );
};

let map_to_isogenous_E1_impl_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_curve_simple_swu_impl (fp_abs u)) }});
};

// other overrides:

let dbl_n_add_spec n = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant out /\ POINTonE1_invariant p }};
  llvm_execute_func [out_ptr, llvm_term {{`n:[64]}}, p_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (dbl_n_add (POINTonE1_abs out) `n (POINTonE1_abs p)) }});
};

// the code calls this assembly function:
let sgn0x_pty_mont_384_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  p_ptr <- alloc_init_readonly vec384_type (llvm_term {{ vec384_rep (from_Fp `p) }});
  llvm_execute_func [a_ptr, p_ptr, llvm_term {{ 0x89f3fffcfffcfffd }}];
  llvm_return (llvm_term {{ zext`{m=64} [2*(fp_abs a)>`p, (from_Fp (fp_abs a))!0] }});
};

// we also need this:
let recip_sqrt_fp_3mod4_spec = do {
    out_ptr <- crucible_alloc vec384_type;
    (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384_type;
    crucible_precond {{ fp_invariant inp }};
    crucible_execute_func [out_ptr, inp_ptr];
    crucible_points_to out_ptr (crucible_term {{fp_rep (Fp.div (Fp.field_unit, sqrt_fp (fp_abs inp))) }});
    };

sgn0x_pty_mont_384_ov <- admit "sgn0x_pty_mont_384" sgn0x_pty_mont_384_spec;
recip_sqrt_fp_3mod4_ov <- admit "recip_sqrt_fp_3mod4" recip_sqrt_fp_3mod4_spec; // TODO: prove (see exp.saw)

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
  fp_neg = Fp.neg
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p -> Fp.neg p == fp_neg p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

// Assumptions:

// This is an algebraic fact:
recip_sqrt_fp_algebra_thm <- simp_then_admit {{ \x -> Fp.div (Fp.field_unit, sqrt_fp x) == fp_exp x ((`p-3)/4) }};

// We assume that the optimized implementation of the swu map given in the IETF spec is correct:
swu_3mod4_correct <- admit_cryptol
  {{ \u -> ((Fp.div(xn,xd), Fp.div(yn,yd)) where (xn, xd, yn, yd) =  map_to_curve_simple_swu_3mod4 u)
        == map_to_curve_simple_swu u
  }};

let {{
  isogenous_E: EllipticCurve t_Fp
  isogenous_E = {base_field = Fp, a = A', b = B'}
}};

// this holds because a projective point on on ef the curves cannot be of the form (0,0,z) with z != 0
//affinify_on_curve_thms <- for [
    //{{ \p -> is_point_projective isogenous_E p ==> is_zero Fp p.2 == is_point_O isogenous_E (affinify E p) }}
    //{{ \p -> is_point_projective E p ==> is_zero Fp p.2 == is_point_O E (affinify E p) }}
  //] simp_then_admit;

is_point_equiv_thm <- simp_then_admit {{ \p -> is_point_projective isogenous_E p == (is_point_affine isogenous_E (affinify isogenous_E p) /\ ~( Fp.is_equal (p.0, Fp.field_zero) /\ Fp.is_equal (p.1, Fp.field_zero) )) }};

// TODO: this is quite useless in this form...
//is_point_aff_to_proj_thm <- simp_then_admit {{ \p q -> is_point_affine isogenous_E p /\ ~(is_point_O isogenous_E p) /\ affinify isogenous_E q == p ==> is_point_projective isogenous_E q }};

swu_xd_nz_thm <- simp_then_admit {{ \u -> (is_zero Fp xd == False where (_, xd, _, _) = map_to_curve_simple_swu_3mod4 u) }};

is_affine_swu <- simp_then_admit {{ \u -> is_point_affine isogenous_E (map_to_curve_simple_swu u) == True }};

dadd_thm <- admit_cryptol (rewrite (cryptol_ss ()) {{ \ p1 p2 -> affinify E (point_dadd Fp p1 p2 A' False) == add Curve_E' (affinify E p1) (affinify E p2) }});

point_dadd_on_curve <- simp_then_admit {{ \p q -> is_point_projective isogenous_E (point_dadd Fp p q A' False) == if is_point_projective isogenous_E p /\ is_point_projective isogenous_E q then True else apply is_point_projective isogenous_E (point_dadd Fp p q A' False) }};

// We will need to prove that some expression involving field Fp operations are
// equivalent.  To do so, we will try to rewrite them to a normal form with the
// following rules. The problem is that we cannot use commutativity or
// associativity, which would make the rewriter loop....

zero_unit_rewrites <- for [ // TODO: here we are cheating: this is true only if we use the (Z p) type
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.mul (Fp.field_zero, p) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_unit) == Fp.field_unit }}
  , {{ \p -> Fp.div (Fp.field_zero, p) == Fp.field_zero }}
] simp_then_admit;

// NOTE: those rules should be sound since we have `Fp.div (x,0) == 0`
push_div_out_rewrites <- for [
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.div (Fp.div (z, x), y) == Fp.div (z, Fp.mul (x,y)) }}
] simp_then_admit;

sum_of_prods_rewrites <- for [
  {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
] simp_then_admit;

unsquare_rewrite <- simp_then_admit {{ \a -> Fp.sq a == Fp.mul (a,a) }};

left_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z) }};

// this one is not included in algebra_simpset below:
right_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (Fp.mul (x, y),z) == Fp.mul (x, Fp.mul (y,z)) }};

simp_div_rewrites <- for [
    {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
  , {{ \x y z -> Fp.div (Fp.mul (y,x), Fp.mul(z,x)) == Fp.div (y,z) }}
  , {{ \x y z -> Fp.div (Fp.mul (x,y), Fp.mul(x,z)) == Fp.div (y,z) }}
] simp_then_admit;

let algebra_simpset = addsimps (concat_all [zero_unit_rewrites, [unsquare_rewrite], [left_fold_mul], sum_of_prods_rewrites, push_div_out_rewrites, simp_div_rewrites]) empty_ss;

// Proofs

// map_to_isogenous_E1

// We rewrite the constants appearing in the C code (mostly for readability of the goals when debugging; this just saves unfolding Fp.field_unit):
constants_rewrites <- for [
      {{ fp_abs [ 4878930887265312543 , 14750521259635781058 , 8371497156570714123 , 15793066378700994603 , 16433423527091015560 , 32548497384448767 ] == sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) }}
    , {{ fp_abs [ 9830232086645309404 , 1112389714365644829 , 8603885298299447491 , 11361495444721768256 , 5788602283869803809 , 543934104870762216 ] == Z }}
    , {{ [ 9180392817347875192 , 12752300768841235045 , 5424152106454515062 , 3349150446948955809 , 1614784533401171638 , 42236840757897548 ] == fp_rep (Fp.mul (Z, A')) }}
    ,  {{ fp_abs [ 9987108143941419098 , 10981380979105458492 , 12597673232421864513 , 4365728511027233858 , 2514197008840889506 , 336850944957925653 ] == Fp.neg(A') }}
    , {{ fp_abs [ 3415322872136444497 , 9675504606121301699 , 13284745414851768802 , 2873609449387478652 , 2897906769629812789 , 1536947672689614213 ] == A' }}
    , {{ fp_abs [ 18129637713272545760 , 11144507692959411567 , 10108153527111632324 , 9745270364868568433 , 14587922135379007624 , 469008097655535723 ] == B' }}
    , {{ fp_abs [ 8505329371266088957 , 17002214543764226050 , 6865905132761471162 , 8632934651105793861 , 6631298214892334189 , 1582556514881692819 ] == Fp.field_unit }}
  ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

map_to_isogenous_E1_impl_ov <- custom_verify
  "map_to_isogenous_E1"
  (concat_all [fp_overrides, vec_overrides, [recip_sqrt_fp_3mod4_ov , sgn0x_pty_mont_384_ov]])
  map_to_isogenous_E1_impl_spec
  (do {
    goal_num_ite 31
      do { // main safety goal:
        // the only difference between spec and code is the use of `vec_select` and `vec_is_equal`
        let local_rewrites = run (
          for [
                {{ \x y -> Fp.is_equal (x, y) == (x == y) }}
              , {{ Fp.field_zero == 0 }}
          ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4)
        );
        unfolding ["map_to_curve_simple_swu_impl", "select", "POINTonE1_rep"];
        simplify (addsimps constants_rewrites fp_simpset);
        simplify (addsimps local_rewrites empty_ss);
        w4_unint_z3 (concat ["Fp"] ["sqrt_fp","sqrt","fp_rep"]);
      }
      do { // simulation side-conditions
        unfolding ["select"];
        simplify fp_simpset;
        w4;
      };
  });

// Now it remains to prove that the map_to_isogenous_E1 implementation spec is equivalent to the IETF spec

// We need to rewrite `e2`, which is computed differently in the C code compared to the specification
let {{
  e2_eqn = \gx1 gxd -> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul (gx1, gxd))), gxd), gx1)
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq gxd, Fp.mul (gx1, gxd)))
}};

e2_lemma <- simp_then_admit (unfold_term ["e2_eqn"] {{ e2_eqn }}); // TODO: this is a trivial simplification, which unfortunately may be pretty tedious in SAW...

swu_impl_equiv_3mod4_impl <- custom_prove_cryptol {{ \u -> map_to_curve_simple_swu_impl u == map_to_curve_simple_swu_3mod4_impl u }}
  do {
    unfolding ["map_to_curve_simple_swu_impl", "map_to_curve_simple_swu_3mod4_impl"];
    simplify (addsimp e2_lemma empty_ss);
    simplify (addsimp recip_sqrt_fp_algebra_thm empty_ss);
    w4_unint_z3 (concat ["Fp"] ["sqrt","fp_exp"]);
  };

swu_impl_nz_thm <- custom_prove_cryptol {{ \u -> (is_zero Fp z == False where (_,_,z) = (map_to_curve_simple_swu_3mod4_impl u)) }}
  do {
    goal_insert swu_xd_nz_thm;
    unfolding ["map_to_curve_simple_swu_3mod4_impl","map_to_curve_simple_swu_3mod4"];
    w4;
  };

swu_3mod4_abs_thm <- custom_prove_cryptol {{ \u -> affinify isogenous_E (map_to_curve_simple_swu_3mod4_impl u) ==
  ((Fp.div(xn,xd), Fp.div(yn,yd)) where (xn, xd, yn, yd) = map_to_curve_simple_swu_3mod4 u) }}
  do {
    unfolding ["affinify","isogenous_E"];
    simplify (addsimp swu_impl_nz_thm empty_ss);
    goal_eval_unint ["map_to_curve_simple_swu_3mod4_impl","map_to_curve_simple_swu_3mod4","Fp","point_O"];
    unfolding ["map_to_curve_simple_swu_impl","map_to_curve_simple_swu_3mod4"];
    // TODO: now a "simple" algebraic manipulation should suffice...
    //w4_unint_z3 (concat fp_unints ["fp_exp"]);
    assume_unsat;
  };

// finally for map_to_isogenous_E1:
map_to_isogenous_E1_thm <- custom_prove_cryptol {{ \u -> affinify isogenous_E (map_to_curve_simple_swu_impl u) == map_to_curve_simple_swu u }}
  do {
    simplify (addsimps [swu_impl_equiv_3mod4_impl, swu_3mod4_abs_thm, swu_3mod4_correct] empty_ss);
    w4;
  };

// moreover:
is_point_proj_swu <- custom_prove_cryptol {{ \u -> is_point_projective isogenous_E (map_to_curve_simple_swu_impl u) }}
  do {
    simplify (addsimps [is_point_equiv_thm, map_to_isogenous_E1_thm, is_affine_swu, swu_impl_equiv_3mod4_impl] empty_ss);
    // TODO: now this should be provable from assumptions about swu_impl_equiv_3mod4
    assume_unsat;
  };
