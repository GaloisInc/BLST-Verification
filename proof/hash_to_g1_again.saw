/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

enable_experimental;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";
include "exp.saw";

import "../spec/Parameters.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE1_standalone.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";
//EC <- cryptol_load "../spec/ShortWeierstrassCurve.cry";

let do_prove = true;

let blst_hash_to_g1_impl_spec msg_len DST_len aug_len = do {
  p_ptr <- llvm_alloc POINTonE1_type;
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  llvm_execute_func [p_ptr, msg_ptr, llvm_term {{ `msg_len : [64] }}, DST_ptr, llvm_term {{ `DST_len : [64] }}, aug_ptr, llvm_term {{ `aug_len : [64] }}];
  llvm_points_to p_ptr (llvm_term {{ (POINTonE1_rep (hash_to_curve_opt_impl (aug#msg, DST))) }});
};

let map_to_g1_impl_nonnull_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u,u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  (v,v_ptr) <- ptr_to_fresh_readonly "v" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_precond {{ fp_invariant v }};
  llvm_execute_func [out_ptr, u_ptr, v_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_g1_impl [fp_abs u, fp_abs v]) }});
};

let isogeny_map_to_E1_impl_alias_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (isogeny_map_to_E1_impl (POINTonE1_abs out)) }} );
};

let map_to_isogenous_E1_impl_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_curve_simple_swu_impl (fp_abs u)) }});
};

// other overrides:

let dbl_n_add_spec n = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant out /\ POINTonE1_invariant p }};
  llvm_execute_func [out_ptr, llvm_term {{`n:[64]}}, p_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (dbl_n_add (POINTonE1_abs out) `n (POINTonE1_abs p)) }});
};

// the code calls this assembly function:
let sgn0x_pty_mont_384_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  p_ptr <- alloc_init_readonly vec384_type (llvm_term {{ vec384_rep (from_Fp `p) }});
  llvm_execute_func [a_ptr, p_ptr, llvm_term {{ 0x89f3fffcfffcfffd }}];
  llvm_return (llvm_term {{ zext`{m=64} [2*(fp_abs a)>`p, (from_Fp (fp_abs a))!0] }});
};

// we also need this:
let recip_sqrt_fp_3mod4_spec = do {
    out_ptr <- crucible_alloc vec384_type;
    (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384_type;
    crucible_precond {{ fp_invariant inp }};
    crucible_execute_func [out_ptr, inp_ptr];
    crucible_points_to out_ptr (crucible_term {{fp_rep (Fp.div (Fp.field_unit, sqrt_fp (fp_abs inp))) }});
    };

sgn0x_pty_mont_384_ov <- admit "sgn0x_pty_mont_384" sgn0x_pty_mont_384_spec;
recip_sqrt_fp_3mod4_ov <- admit "recip_sqrt_fp_3mod4" recip_sqrt_fp_3mod4_spec; // TODO: prove (see exp.saw)

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
  fp_neg = Fp.neg
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p -> Fp.neg p == fp_neg p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

// Assumptions:

// This is an algebraic fact:
recip_sqrt_fp_algebra_thm <- simp_then_admit {{ \x -> Fp.div (Fp.field_unit, sqrt_fp x) == fp_exp x ((`p-3)/4) }};

// We assume that the optimized implementation of the swu map given in the IETF spec is correct:
swu_3mod4_correct <- admit_cryptol
  {{ \u -> ((Fp.div(xn,xd), Fp.div(yn,yd)) where (xn, xd, yn, yd) =  map_to_curve_simple_swu_3mod4 u)
        == map_to_curve_simple_swu u
  }};

let {{
  isogenous_E: EllipticCurve t_Fp
  isogenous_E = {base_field = Fp, a = A', b = B'}
}};

// this holds because a projective point on on ef the curves cannot be of the form (0,0,z) with z != 0
//affinify_on_curve_thms <- for [
    //{{ \p -> is_point_projective isogenous_E p ==> is_zero Fp p.2 == is_point_O isogenous_E (affinify E p) }}
    //{{ \p -> is_point_projective E p ==> is_zero Fp p.2 == is_point_O E (affinify E p) }}
  //] simp_then_admit;

is_point_O_on_curve_thm <- simp_then_admit {{ \p -> is_point_O isogenous_E (affinify isogenous_E p) == if is_point_projective isogenous_E p then Fp.is_equal (p.2, Fp.field_zero) else apply is_point_O isogenous_E (affinify isogenous_E p) }};

is_point_equiv_thm <- simp_then_admit {{ \p -> is_point_projective isogenous_E p == (is_point_affine isogenous_E (affinify isogenous_E p) /\ ~( Fp.is_equal (p.0, Fp.field_zero) /\ Fp.is_equal (p.1, Fp.field_zero) )) }};

// TODO: this is quite useless in this form...
//is_point_aff_to_proj_thm <- simp_then_admit {{ \p q -> is_point_affine isogenous_E p /\ ~(is_point_O isogenous_E p) /\ affinify isogenous_E q == p ==> is_point_projective isogenous_E q }};

swu_xd_nz_thm <- simp_then_admit {{ \u -> (is_zero Fp xd == False where (_, xd, _, _) = map_to_curve_simple_swu_3mod4 u) }};

is_affine_swu <- simp_then_admit {{ \u -> is_point_affine isogenous_E (map_to_curve_simple_swu u) == True }};

dadd_thm <- admit_cryptol (rewrite (cryptol_ss ()) {{ \ p1 p2 -> affinify E (point_dadd Fp p1 p2 A' False) == add Curve_E' (affinify E p1) (affinify E p2) }});

point_dadd_on_curve <- simp_then_admit {{ \p q -> is_point_projective isogenous_E (point_dadd Fp p q A' False) == if is_point_projective isogenous_E p /\ is_point_projective isogenous_E q then True else apply is_point_projective isogenous_E (point_dadd Fp p q A' False) }};

// We will need to prove that some expression involving field Fp operations are
// equivalent.  To do so, we will try to rewrite them to a normal form with the
// following rules. The problem is that we cannot use commutativity or
// associativity, which would make the rewriter loop....

zero_unit_rewrites <- for [ // TODO: here we are cheating: this is true only if we use the (Z p) type
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.mul (Fp.field_zero, p) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_unit) == Fp.field_unit }}
  , {{ \p -> Fp.div (Fp.field_zero, p) == Fp.field_zero }}
] simp_then_admit;

// NOTE: those rules should be sound since we have `Fp.div (x,0) == 0`
push_div_out_rewrites <- for [
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.div (Fp.div (z, x), y) == Fp.div (z, Fp.mul (x,y)) }}
] simp_then_admit;

sum_of_prods_rewrites <- for [
  {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
] simp_then_admit;

unsquare_rewrite <- simp_then_admit {{ \a -> Fp.sq a == Fp.mul (a,a) }};

left_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z) }};

// this one is not included in algebra_simpset below:
right_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (Fp.mul (x, y),z) == Fp.mul (x, Fp.mul (y,z)) }};

simp_div_rewrites <- for [
    {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
  , {{ \x y z -> Fp.div (Fp.mul (y,x), Fp.mul(z,x)) == Fp.div (y,z) }}
  , {{ \x y z -> Fp.div (Fp.mul (x,y), Fp.mul(x,z)) == Fp.div (y,z) }}
] simp_then_admit;

let algebra_simpset = addsimps (concat_all [zero_unit_rewrites, [unsquare_rewrite], [left_fold_mul], sum_of_prods_rewrites, push_div_out_rewrites, simp_div_rewrites]) empty_ss;

// Proofs

// map_to_isogenous_E1

// We rewrite the constants appearing in the C code (mostly for readability of the goals when debugging; this just saves unfolding Fp.field_unit):
constants_rewrites <- for [
      {{ fp_abs [ 4878930887265312543 , 14750521259635781058 , 8371497156570714123 , 15793066378700994603 , 16433423527091015560 , 32548497384448767 ] == sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) }}
    , {{ fp_abs [ 9830232086645309404 , 1112389714365644829 , 8603885298299447491 , 11361495444721768256 , 5788602283869803809 , 543934104870762216 ] == Z }}
    , {{ [ 9180392817347875192 , 12752300768841235045 , 5424152106454515062 , 3349150446948955809 , 1614784533401171638 , 42236840757897548 ] == fp_rep (Fp.mul (Z, A')) }}
    ,  {{ fp_abs [ 9987108143941419098 , 10981380979105458492 , 12597673232421864513 , 4365728511027233858 , 2514197008840889506 , 336850944957925653 ] == Fp.neg(A') }}
    , {{ fp_abs [ 3415322872136444497 , 9675504606121301699 , 13284745414851768802 , 2873609449387478652 , 2897906769629812789 , 1536947672689614213 ] == A' }}
    , {{ fp_abs [ 18129637713272545760 , 11144507692959411567 , 10108153527111632324 , 9745270364868568433 , 14587922135379007624 , 469008097655535723 ] == B' }}
    , {{ fp_abs [ 8505329371266088957 , 17002214543764226050 , 6865905132761471162 , 8632934651105793861 , 6631298214892334189 , 1582556514881692819 ] == Fp.field_unit }}
  ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

map_to_isogenous_E1_impl_ov <- custom_verify
  "map_to_isogenous_E1"
  (concat_all [fp_overrides, vec_overrides, [recip_sqrt_fp_3mod4_ov , sgn0x_pty_mont_384_ov]])
  map_to_isogenous_E1_impl_spec
  (do {
    goal_num_ite 31
      do { // main safety goal:
        // the only difference between spec and code is the use of `vec_select` and `vec_is_equal`
        let local_rewrites = run (
          for [
                {{ \x y -> Fp.is_equal (x, y) == (x == y) }}
              , {{ Fp.field_zero == 0 }}
          ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4)
        );
        unfolding ["map_to_curve_simple_swu_impl", "select", "POINTonE1_rep"];
        simplify (addsimps constants_rewrites fp_simpset);
        simplify (addsimps local_rewrites empty_ss);
        w4_unint_z3 (concat ["Fp"] ["sqrt_fp","sqrt","fp_rep"]);
      }
      do { // simulation side-conditions
        unfolding ["select"];
        simplify fp_simpset;
        w4;
      };
  });

// Now it remains to prove that the map_to_isogenous_E1 implementation spec is equivalent to the IETF spec

// We need to rewrite `e2`, which is computed differently in the C code compared to the specification
let {{
  e2_eqn = \gx1 gxd -> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul (gx1, gxd))), gxd), gx1)
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq gxd, Fp.mul (gx1, gxd)))
}};

e2_lemma <- simp_then_admit (unfold_term ["e2_eqn"] {{ e2_eqn }}); // TODO: this is a trivial simplification, which unfortunately may be pretty tedious in SAW...

swu_impl_equiv_3mod4_impl <- custom_prove_cryptol {{ \u -> map_to_curve_simple_swu_impl u == map_to_curve_simple_swu_3mod4_impl u }}
  do {
    unfolding ["map_to_curve_simple_swu_impl", "map_to_curve_simple_swu_3mod4_impl"];
    simplify (addsimp e2_lemma empty_ss);
    simplify (addsimp recip_sqrt_fp_algebra_thm empty_ss);
    w4_unint_z3 (concat ["Fp"] ["sqrt","fp_exp"]);
  };

swu_impl_nz_thm <- custom_prove_cryptol {{ \u -> (is_zero Fp z == False where (_,_,z) = (map_to_curve_simple_swu_3mod4_impl u)) }}
  do {
    goal_insert swu_xd_nz_thm;
    unfolding ["map_to_curve_simple_swu_3mod4_impl","map_to_curve_simple_swu_3mod4"];
    w4;
  };

swu_3mod4_abs_thm <- custom_prove_cryptol {{ \u -> affinify isogenous_E (map_to_curve_simple_swu_3mod4_impl u) ==
  ((Fp.div(xn,xd), Fp.div(yn,yd)) where (xn, xd, yn, yd) = map_to_curve_simple_swu_3mod4 u) }}
  do {
    unfolding ["affinify","isogenous_E"];
    simplify (addsimp swu_impl_nz_thm empty_ss);
    goal_eval_unint ["map_to_curve_simple_swu_3mod4_impl","map_to_curve_simple_swu_3mod4","Fp","point_O"];
    unfolding ["map_to_curve_simple_swu_impl","map_to_curve_simple_swu_3mod4"];
    // TODO: now a "simple" algebraic manipulation should suffice...
    //w4_unint_z3 (concat fp_unints ["fp_exp"]);
    assume_unsat;
  };

// finally for map_to_isogenous_E1:
map_to_isogenous_E1_thm <- custom_prove_cryptol {{ \u -> affinify isogenous_E (map_to_curve_simple_swu_impl u) == map_to_curve_simple_swu u }}
  do {
    simplify (addsimps [swu_impl_equiv_3mod4_impl, swu_3mod4_abs_thm, swu_3mod4_correct] empty_ss);
    w4;
  };

// moreover:
is_point_proj_swu <- custom_prove_cryptol {{ \u -> is_point_projective isogenous_E (map_to_curve_simple_swu_impl u) }}
  do {
    simplify (addsimps [is_point_equiv_thm, map_to_isogenous_E1_thm, is_affine_swu, swu_impl_equiv_3mod4_impl] empty_ss);
    // TODO: now this should be provable from assumptions about swu_impl_equiv_3mod4
    assume_unsat;
  };

// isogeny_map_to_E1

isogeny_map_to_E1_impl_alias_ov <- custom_verify
  "isogeny_map_to_E1"
  fp_overrides
  isogeny_map_to_E1_impl_alias_spec
  (goal_num_ite 176 // 176 is the main safety goal
    (do {
      simplify fp_simpset; // eliminate `abs . rep` etc.
      w4_unint_z3 ["fp_rep"];
    })
    (do { // discharge simulation side-conditions:
      unfolding ["POINTonE1_invariant"];
      simplify fp_simpset;
      w4_unint_z3 ["Fp"];
    })
  );

// an auxiliary definition that will be useful:
let {{
  powers x = ps where
    ps = [Fp.field_unit] # [Fp.mul(x, pi) | pi <- ps]
  zz11 z = (powers (Fp.sq z))@11
  zz15 z = (powers (Fp.sq z))@15
}};

// we will first rewrite iso_map to get rid of div terms
// first we multiply x_num and x_den by zz11, and y_num and y_den by zz15
let {{
  iso_map_2 (x', y', z') = if is_point_O isogenous_E (X,Y) then point_O E else (x, y) where
    (X,Y) = affinify isogenous_E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
}};

rewrite_1 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map (affinify isogenous_E p) == iso_map_2 p }})
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimps (concat_all [zero_unit_rewrites, simp_div_rewrites]) empty_ss);
    w4_unint_z3 fp_unints;
  });

// now we use the fact that Y = y'/z'^3 if the point is not point_O
let {{
  iso_map_3 (x', y', z') = if is_point_O isogenous_E (X,Y) then point_O E else (x, y) where
    (X,Y) = affinify isogenous_E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')))
}};

// we are going to rewrite y with this rule:
aux_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \y_num y_den x' y' z' -> (Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z'))) == if ~(is_point_O isogenous_E (X,Y)) then Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z'))) else apply Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
  where (X,Y) = affinify isogenous_E (x', y', z'))
}})
 (do {
    let local_rewrites = run (for [
          {{ \x a b c -> Fp.mul(if a then b else c, x) == if a then Fp.mul (b,x) else Fp.mul (c,x) }}
        , {{ \x a b c -> Fp.mul(x, if a then b else c) == if a then Fp.mul (x,b) else Fp.mul (x,c) }}
        , {{ \x a b c -> Fp.is_equal(if a then b else c, x) == if a then Fp.is_equal (b,x) else Fp.is_equal (c,x) }}
        , {{ \x a b c -> Fp.is_equal(x, if a then b else c) == if a then Fp.is_equal (x,b) else Fp.is_equal (x,c) }}
        , {{ \c (x:(Integer,Integer)) y -> (if c then x else y).0 == if c then x.0 else y.0 }}
        , {{ \a (b:(Integer,Integer)) (c:(Integer,Integer))-> (if a then b else c).1 == if a then b.1 else c.1 }}
        , {{ \(x:Integer) -> Fp.is_equal (x, x) == True }}
      ] (\ x -> custom_prove_cryptol (rewrite (cryptol_ss()) x) w4));
    unfolding ["affinify","isogenous_E","apply","is_point_O","same_point_affine","is_zero"];
    simplify (addsimps local_rewrites algebra_simpset);
    w4_unint_z3 fp_unints;
 });

rewrite_2 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map_2 p == iso_map_3 p }})
  (do {
    unfolding ["iso_map_2","apply"];
    simplify (addsimp aux_rewrite empty_ss);
    w4_unint_z3 fp_unints;
  });

// now we rewrite x_num, x_den, y_num, and y_den independently:

// Rewrite rule for x_num

let {{
  x_num_times_zz11 x' z' = Fp.mul (x_num, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- (powers X)]
  // here we don't want any divisions:
  x_num_times_zz11_nodiv x' z' = x_num where
    x'_powers = take`{front=12}(powers x')
    zz'_powers = take`{front=12}(powers zz')
    zz' = Fp.sq z'
    x_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k1s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_x_num_times_zz11 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_num_times_zz11_nodiv x z == x_num_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","x_num_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// Now let's prove that the nodiv term is equivalent to the implementation term. Since there are no divisions left, Z3 is able to handle the proof obligations (or is it rewriting in What4?)

let {{
  x_num_times_zz11_impl x' z' = xn where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k1s]) x' where // k0 to k11
      kzzs = map_fp_times_Zz`{n=11} k1s zzs // k0 to k10
}};

x_num_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_num_times_zz11_impl"] {{ \x z -> x_num_times_zz11_impl x z == x_num_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// rewrite rule for x_den

let {{
  x_den_times_zz11 x' z' = Fp.mul (x_den, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_den = Fp.add ((powers X)@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- (powers X)])
  // here we don't want any divisions:
  x_den_times_zz11_nodiv x' z' = x_den where
    x'_powers = take`{front=11}(powers x')
    zz'_powers = tail (take`{front=12}(powers zz'))
    zz' = Fp.sq z'
    x_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k2s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_x_den_times_zz11 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_den_times_zz11_nodiv x z == x_den_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k2s","x_den_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  x_den_times_zz11_impl x' z' = xd where
    zzs = Zz_powers z'
    xd = Fp.mul (xs, last zzs)
    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) x'
    xkzz9 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=10} k2s zzs
}};

x_den_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_den_times_zz11_impl"] {{ \x z -> x_den_times_zz11_impl x z == x_den_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// rewrite rule for y_num

let {{
  y_num_times_zz15 x' y' z' = Fp.mul (y', Fp.mul (y_num, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- (powers X)]
  // here we don't want any divisions:
  y_num_times_zz15_nodiv x' y' z' = Fp.mul (y_num, y') where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k3s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_y_num_times_zz15 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x y z -> y_num_times_zz15_nodiv x y z == y_num_times_zz15 x y z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","y_num_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

let {{
  y_num_times_zz15_impl x' y' z' = Fp.mul (xn, y') where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k3s]) x' where
      kzzs = map_fp_times_Zz`{n=15} k3s zzs
}};

y_num_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_num_times_zz15_impl"] {{ \x y z -> y_num_times_zz15_impl x y z == y_num_times_zz15_nodiv x y z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k3s"]);
    w4;
  });

// rewrite rule for y_den

let {{
  y_den_times_zz15 x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_den = Fp.add ((powers X)@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- (powers X)])
  // here we don't want any divisions:
  y_den_times_zz15_nodiv x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  y_den) where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k4s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_y_den_times_zz15 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> y_den_times_zz15_nodiv x z == y_den_times_zz15 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k4s","y_den_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  y_den_times_zz15_impl x' z' = Fp.mul (Fp.mul (xs, z'), last zzs) where
    zzs = Zz_powers z'
    xs = map_fp ((take`{front=14}kzzs)#[ykzz14]) x'
    ykzz14 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=15} k4s zzs
}};

y_den_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_den_times_zz15_impl"] {{ \x z -> y_den_times_zz15_impl x z == y_den_times_zz15_nodiv x z }}))
  (do {
    unfolding ["y_den_times_zz15_nodiv"];
    goal_eval_unint (concat fp_unints ["k4s"]);
    w4;
  });

to_jacobian_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ())
  {{
    \xn xd yn yd -> affinify E (to_jacobian xn xd yn yd) == if ~(is_zero Fp (Fp.mul (xd,yd))) then (Fp.div (xn, xd), Fp.div(yn, yd)) else point_O E
  }})
  (do {
    unfolding ["to_jacobian", "affinify", "E", "apply"];
    simplify algebra_simpset;
    w4_unint_z3 fp_unints;
  });

// TODO:
isogeny_map_to_E1_impl_thm <- custom_prove_cryptol {{ \p -> affinify E (isogeny_map_to_E1_impl p) == if is_point_projective isogenous_E p then iso_map (affinify isogenous_E p) else apply affinify E (isogeny_map_to_E1_impl p) }}
  do {
    simplify (addsimps [rewrite_1, rewrite_2] empty_ss); // rewrite iso_map to iso_map_3
    unfolding ["isogeny_map_to_E1_impl","apply"];
    simplify (cryptol_ss ());
    simplify (addsimps [x_num_rewrite, elim_div_rewrite_x_num_times_zz11, x_den_rewrite, elim_div_rewrite_x_den_times_zz11, y_num_rewrite, elim_div_rewrite_y_num_times_zz15, y_den_rewrite, elim_div_rewrite_y_den_times_zz15] empty_ss); // rewrite iso_map_impl to get to x_num, y_num etc. as in iso_map_3
    simplify (cryptol_ss ());
    unfolding ["iso_map_3"];
    let rw = run (
        simp_then_admit {{ \(x:(Integer,Integer)) -> (x.0,(x.1)) == x }}
      );
    simplify (addsimps [rw, is_point_O_on_curve_thm] empty_ss);
    goal_eval_unint ["Fp","k1s","k2s","k3s","k4s"];
    w4;
    //print_readably;
    //assume_unsat;
  };
