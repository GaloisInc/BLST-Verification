/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

let point_op_overrides = concat vec_overrides
  [ POINTonE1_add_ov, POINTonE1_add_alias_1_2_ov // <= prob not needed
  , POINTonE1_dadd_null_ov, POINTonE1_dadd_null_alias_1_2_ov
  , POINTonE1_dadd_null_alias_1_3_ov, POINTonE1_dadd_affine_ov
  , POINTonE1_double_ov, POINTonE1_double_alias_1_2_ov
  , POINTonE1_cneg_ov
  ];


let {{
  beta: t_Fp
  beta = to_Fp 0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac

  sigma: AffinePoint t_Fp -> AffinePoint t_Fp
  sigma (x, y) = (Fp.mul (x, beta), y)
 }};

// For sigma, need some facts about the constants

beta_rep_invariant_thm <-
  prove_cryptol (rewrite (cryptol_ss ())
    {{fp_invariant [ 0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95
                   , 0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]
       == True}}) [];

beta_rep_abs_thm <-
  prove_cryptol (rewrite (cryptol_ss ())
    {{fp_abs       [ 0xcd03c9e48671f071, 0x5dab22461fcda5d2, 0x587042afd3851b95
                   , 0x8eb60ebe01bacb9e, 0x03f97d6e83d050d2, 0x18f0206554638741]
       == beta }}) [];


let sigma_constant_thms = [ beta_rep_invariant_thm, beta_rep_abs_thm
                          , one_mont_p_invariant_thm,  one_mont_p_abs_thm];

let sigma_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (x, x_ptr) <- ptr_to_fresh_readonly "in"  POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_affine_invariant x }};
  crucible_execute_func [out_ptr, x_ptr];
  crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep (projectify E (sigma (POINTonE1_affine_abs x))) }});
  };


sigma_ov <- custom_verify "sigma"
    // (concat vec_overrides (concat fp_overrides  ec_mult_overrides))
    (concat  point_op_overrides fp_overrides)
    sigma_spec
    do {
      unfolding [ "POINTonE1_rep", "POINTonE1_affine_invariant", "POINTonE1_affine_abs"
                , "projectify", "E", "sigma"];
      // simplify (addsimps sigma_constant_thms fp_simpset);
      // print_goal;
      simplify fp_simpset;
      z3;
      };

enable_experimental;

/*
//let sigma_ov <- custom_verify "sigma" (concat vec_overrides ec_mult_overrides) sigma_spec
//  do { 

let sigma_spec' = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (x, x_ptr) <- ptr_to_fresh_readonly "in"  POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_affine_invariant x }};
  crucible_execute_func [out_ptr, x_ptr];
  out <- crucible_fresh_var "out" POINTonE1_type;
  crucible_points_to out_ptr (crucible_term out);
  };

crucible_llvm_compositional_extract m "sigma" "sigma_effect" 
    (concat vec_overrides (concat fp_overrides  ec_mult_overrides))
    false
    sigma_spec'
    do {unfolding ["POINTonE1_affine_invariant"]; simplify (addsimps sigma_constant_thms empty_ss); print_goal; z3;};
P <- fresh_symbolic "P" {| ([6][64], [6][64]) |};

let th = {{ POINTonE1_affine_invariant P ==> (sigma_effect P) ==  POINTonE1_rep (projectify E (sigma (POINTonE1_affine_abs P))) }};
*/
/* WORKS:
let th1 =  rewrite (addsimps sigma_constant_thms empty_ss) (unfold_term ["sigma_effect", "POINTonE1_rep", "POINTonE1_affine_invariant"] th)
 let th2 =  rewrite (cryptol_ss()) (unfold_term ["projectify", "E", "POINTonE1_affine_abs", "sigma"] th1)
 prove z3 (rewrite fp_simpset th2)
*/

let {{
  zz_minus_1_div_by_3 = 76329603384216526021617858986798044501: Integer

  is_in_g1: AffinePoint t_Fp -> Bool
  is_in_g1 P = is_point_O E (sub E (e1_scalar_mult c Q) P'') where
    P' = sigma P
    P'' = sigma P'
    Q = sub E (sub E (add E P' P') P) P''
    c =  zz_minus_1_div_by_3 // (z^2-1)/3, 0x396c8c005555e1560000000055555555

  // This version with Q as computed in the implementation
  is_in_g1_impl: AffinePoint t_Fp -> Bool
  is_in_g1_impl P = is_point_O E (sub E (e1_scalar_mult c Q) P'') where
    P' = sigma P
    P'' = sigma P'
    // Q = sub E (sub E (add E P' P') P) P''
    Q = add E (neg E (add E P'' P)) (add E P' P')
    c =  zz_minus_1_div_by_3 // (z^2-1)/3, 0x396c8c005555e1560000000055555555

  bool_to_limb: Bool -> Limb
  bool_to_limb c = if c then 1 else 0
  }};


// POINTonE1_times_zz_minus_1_div_by_3
// ... it is useful to use compositional extraction to get a Cryptol term representing
// the effect of this function

let POINTonE1_times_zz_minus_1_div_by_3_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (x, x_ptr) <- ptr_to_fresh_readonly "in"  POINTonE1_type;
  crucible_precond {{ POINTonE1_invariant x }};
  crucible_execute_func [out_ptr, x_ptr];
  out <- crucible_fresh_var "out_POINTonE1_times_zz_minus_1_div_by_3" POINTonE1_type;
  crucible_points_to out_ptr (crucible_term out);
  };

POINTonE1_times_zz_minus_1_div_by_3_ov <- crucible_llvm_compositional_extract m
    "POINTonE1_times_zz_minus_1_div_by_3"
    "POINTonE1_times_c"
    (concat  point_op_overrides fp_overrides)
    false
    POINTonE1_times_zz_minus_1_div_by_3_spec
    do { simplify (addsimps POINTonE1_thms empty_ss);
         simplify remove_higher_order_function_simpset;
         w4_unint_z3 ec_mult_unints; };

// .. want to show
let big_simpset = addsimps (foldr concat
                                  [POINTonE1_thms, e1_curve_op_thms
                                  , structural_rewrites, e1_scalar_mult_alg_thms]
                                  [])
                           cleanup_simpset;

affinify_POINTonE1_times_c_thm <- custom_prove_cryptol
  {{\p -> affinify E (POINTonE1_abs (POINTonE1_times_c p)) ==
          e1_scalar_mult zz_minus_1_div_by_3 (affinify E (POINTonE1_abs p)) }}
  do { unfolding ["POINTonE1_times_c"];
       simplify big_simpset;
       simplify remove_higher_order_function_simpset;
       w4_unint_z3 ec_mult_unints;
       };

invariant_POINTonE1_times_c_thm <- custom_prove_cryptol
  {{ \p -> POINTonE1_invariant (POINTonE1_times_c p) == True }}
  do { unfolding ["POINTonE1_times_c"];
       simplify (addsimps POINTonE1_thms (cryptol_ss()));
       w4_unint_z3 ec_mult_unints;
     };

// POINTonE1_in_G1:

// For the second call to sigma:
sigma_call_thm <- prove_cryptol
  {{ \q -> POINTonE1_affine_invariant (q.0, q.1) ==
             if POINTonE1_invariant q
             then True
             else apply POINTonE1_affine_invariant (q.0, q.1) }}
  ["fp_invariant"];

// ... and for the call to "vec_is_zero"
vec_is_zero_call_thm <- prove_cryptol
  {{ \p -> fp_invariant (p.2) ==
           if POINTonE1_invariant p
           then True
           else apply fp_invariant (p.2) }}
  ["fp_invariant"];


let POINTonE1_in_G1_spec = do {
  (p, p_ptr) <- ptr_to_fresh_readonly "p"  POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_affine_invariant p }};
  crucible_execute_func [p_ptr];
  crucible_return (crucible_term {{ bool_to_limb (is_in_g1_impl (POINTonE1_affine_abs p)) }});
  };

let POINTonE1_in_G1_spec' = do {
  (p, p_ptr) <- ptr_to_fresh_readonly "p"  POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_affine_invariant p }};
  crucible_execute_func [p_ptr];
  r <- crucible_fresh_var "r" limb_type;
  crucible_return (crucible_term {{ r }});
  };

crucible_llvm_compositional_extract m "POINTonE1_in_G1" "inG1" 
    (concat [sigma_ov, POINTonE1_times_zz_minus_1_div_by_3_ov] (concat  point_op_overrides fp_overrides))
    false
    POINTonE1_in_G1_spec'
    do { simplify (addsimps [sigma_call_thm, vec_is_zero_call_thm, invariant_POINTonE1_times_c_thm]
                   (addsimps POINTonE1_thms empty_ss));
         simplify remove_higher_order_function_simpset;
         //print_goal;
         w4_unint_z3 (concat ["sigma"] ec_mult_unints); };

//let zero_for_fp =  parse_core "replicate 6 (Vec 64 Bool) (bvNat 64 0)";

// Not-quite true:
// is_point_O_thm <- admit_cryptol {{ \p -> (p.2 == zero_for_fp) == is_point_O E (affinify E (POINTonE1_abs p)) }};

//is_point_O_thm <- admit_cryptol {{ \p -> (p.2 == zero_for_fp) == is_point_O E (affinify E (POINTonE1_abs p)) }};
//is_point_O_thm' <- admit_cryptol (rewrite (cryptol_ss())
//    {{ \p -> (fp_abs((POINTonE1_rep p).2) == Fp.field_zero) == is_point_O E (affinify E p) }});

let peq = parse_core "intEq"; // NOTE. This depends on t_Fp
is_point_O_thm'' <- admit_cryptol (rewrite (cryptol_ss()) {{ \p -> peq (fp_abs((POINTonE1_rep p).2)) (Fp.field_zero) == is_point_O E (affinify E p) }});
// May not need peq: examine this:
// (rewrite big_simpset {{ \p -> (fp_abs((POINTonE1_rep p).2) == Fp.field_zero) == is_point_O E (affinify E p) }})

// should be conditional, e.g. P = (0, -1)
affinify_projectify_thm <- admit_cryptol {{ \P -> affinify E (projectify E P) == P }};

// rewrite (addsimps [affinify_projectify_thm, affinify_POINTonE1_times_c_thm] big_simpset) (unfold_term ["sub"] (rewrite (addsimp is_point_O_thm'' (cryptol_ss())) (unfold_term ["inG1", "is_in_g1", "bool_to_limb"] {{ \P -> inG1 P == bool_to_limb (is_in_g1 (POINTonE1_affine_abs P))}})))

// ... also not quite true
in_G1_lemma <- admit_cryptol
 {{ \P -> (POINTonE1_affine_abs (x.0, x.1) == P where x = POINTonE1_rep (projectify E P)) }};

// rewrite (addsimps [G1_lemma, affinify_projectify_thm, affinify_POINTonE1_times_c_thm] big_simpset) (unfold_term ["sub"] (rewrite (addsimp is_point_O_thm'' (cryptol_ss())) (unfold_term ["inG1", "is_in_g1_impl", "bool_to_limb"] {{ \P -> inG1 P == bool_to_limb (is_in_g1_impl (POINTonE1_affine_abs P))}})))

POINTonE1_in_G1_thm <- custom_prove_cryptol
  {{ \P -> inG1 P == bool_to_limb (is_in_g1_impl (POINTonE1_affine_abs P))}}
  do {
     unfolding ["inG1", "is_in_g1_impl", "bool_to_limb"];
     simplify (addsimp is_point_O_thm'' (cryptol_ss()));
     unfolding ["sub"];
     simplify (addsimps [affinify_projectify_thm, affinify_POINTonE1_times_c_thm, in_G1_lemma] big_simpset);
     simplify remove_higher_order_function_simpset;
     w4_unint_z3 (concat ["sigma"] ec_mult_unints);
  };

/* FAILS:
POINTonE1_in_G1_ov <- custom_verify "POINTonE1_in_G1"
  (concat [sigma_ov, POINTonE1_times_zz_minus_1_div_by_3_ov] (concat  point_op_overrides fp_overrides))
   POINTonE1_in_G1_spec
   do {
    simplify (addsimps [sigma_call_thm, vec_is_zero_call_thm, invariant_POINTonE1_times_c_thm]
                   (addsimps POINTonE1_thms empty_ss));
     unfolding ["is_in_g1_impl", "bool_to_limb"];
     simplify (addsimp is_point_O_thm'' (cryptol_ss()));
     unfolding ["sub"];
     simplify (addsimps [affinify_projectify_thm, affinify_POINTonE1_times_c_thm] big_simpset);
     print_goal;
     simplify remove_higher_order_function_simpset;
     w4_unint_z3 (concat ["sigma"] ec_mult_unints);
     };
*/
