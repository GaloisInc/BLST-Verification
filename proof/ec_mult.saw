/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

print "%%%% Theorems about Booth's windowed method";
/*

The windowed scalar multiplication algorithm used in blst is a version
of Booth's optimization of a simple windowed multiplication algorithm.

That more basic algorithm starts with a precomputed table of scalar
multiples, [i]P for i in range 0..(2^w-1), where `w` is the number of
bits in the window.  Then the scalar is split into blocks of size w.

The key equation behind this is simple:

(*1)  [2^w*a + b]P = [2^w][a]P + [b]P

In the Booth optimization, since we can also subtract, we sometimes also use

(*2)  [2^w*a + b]P = [2^w][a+1]P - [2^w-b]P

so we only need a table of [i]P for i in range 0..2^(w-1); when `b` is small we add, and when
`b` is large we subtract `2^w - b`.

A wrinkle in the implementation here is that for the `[a+1]P` part of
(*2), we actually split up the `a` value into blocks before adding 1,
and do not carry between blocks.  So a block's value can end up being
as much as 2^w.  We will see this in the size of the precomputed table
below.

A second interesting aspect is that we might need an additional block,
e.g, even with a single window we might want a borrow, e.g.
  [b]P = [2^w]P - [2^w-b]P
whenever b > 2^w.

In implementing this method we start with the most significant bits of
the scalar.  So we need to know whether this `a` part needs to have 1
added or not (which depends on the value of the next block, if there is one).

We begin with some lemmas that show how the multipliers work.  We keep
these multipliers as integers, and so have to deal with the relation
of bitvectors to integers.
*/

// Proofs work better with a custom version of `toInteger`
let {{
  bitInt: Bit -> Integer
  bitInt b = if b then 1 else 0

  toInt: {n} (fin n) => [n] -> Integer
  toInt = foldl (\ acc bit -> 2*acc + (bitInt bit)) 0
  }};

bif_thm <- prove_cryptol {{bitInt False == 0}} [];


// The plain windowed method uses blocks of width `SZ`.
let {{
  type SZ = 5

  window_blocks: {n} (fin n) => [n] -> [n /^ SZ][SZ]
  window_blocks e = split (zext e)
  
  block_val: [SZ] -> Integer
  block_val = toInt

  shift = (2:Integer)^^`SZ

  plain: {n} (fin n) => [n] -> Integer
  plain e = foldl (\ acc block -> shift*acc + (block_val block)) 0 (window_blocks e)
  }};

let window_script = do {
  goal_eval_unint ["bitInt"];
  simplify (addsimp bif_thm empty_ss);
  w4_unint_z3 ["bitInt"];};

// we can show that the plain method gets the right final multiples, for various
// concrete sizes:
custom_prove_cryptol {{\(e:[3*SZ+1]) -> plain e == toInt e }} window_script;
custom_prove_cryptol {{\(e:[5*SZ-1]) -> plain e == toInt e }} window_script;
custom_prove_cryptol {{\(e:[8*SZ]) -> plain e == toInt e }} window_script;
custom_prove_cryptol {{\(e:[381]) -> plain e == toInt e }} window_script;

// The Booth method as used in blst, both the first and last blocks get special treatment:
// - the first (most significant) block is always used non-negatively
// - the last block does not have a following block, and so never has 1 added to its value.

let {{
  booth_sign: [SZ] -> Bit // True for negative
  booth_sign x = x@0

  booth_block_val: [SZ] -> Integer
  booth_block_val x = if booth_sign x then v-shift else v where v = block_val x

  booth: {n} (fin n, n >= 1) => [n] -> Integer
  booth e = foldl (\ a v -> shift*a + v) 0 (booth_parts e)

  booth_parts: {n} (fin n) => [n] -> [(n+1) /^ SZ]Integer
  booth_parts e = vs where
    [b0] # blocks = window_blocks ([False] # e) // make sure there room for a borrow
    [s0] # signs = [booth_sign b | b <- blocks] # [False]
    vs = [(block_val b0) + (bitInt s0)] # [(booth_block_val b) + (bitInt s) | b <- blocks | s <- signs]
}};

// It is easiest to show the Booth method gets the righ answer by comparing it to
// the plain method (when the multiplier has many bits).  But we can prove directly
// for small sizes

prove_cryptol {{\(e:[2*SZ-1]) -> booth e == toInt e }} [];
prove_cryptol {{\(e:[2*SZ+1]) -> booth e == toInt e }} [];
prove_cryptol {{\(e:[3*SZ]) -> booth e == toInt e }} [];

// .... and now indirectly for the larger sizes
for [17,25,31,39]
 ( \ n_bits -> do {
   plain_lemma <- custom_prove_cryptol {{ \(e:[n_bits]) -> toInt e == plain ([False] # e) }} window_script;
   custom_prove_cryptol {{ \(e:[n_bits]) -> booth e == toInt e }}
     do { simplify (addsimp plain_lemma empty_ss); // so now we show booth e == plain e
          w4_unint_z3 ["block_val"]; };
   } );       

import "../spec/ShortWeierstrassCurve.cry";
import "../spec/implementation/Types.cry";
import "../spec/implementation/CurveOperation.cry";

/*
propositional_rewrites <- for
  [ "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (ite Bool a True b) (or a b))"
  , "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (ite Bool a b False) (and a b))"
  , "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (not (and a b)) (or (not a) (not b)))"
  , "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (not (or a b)) (and (not a) (not b)))"
   ] (prove_core abc);

let prop_simpset = add_prelude_eqs
  [ "ite_true", "ite_false", "ite_eq"
  , "not_True", "not_False", "not_not"
  , "and_True1", "and_True2", "and_False1", "and_False2", "and_idem"
  , "or_True1", "or_True2", "or_False1", "or_False2", "or_idem"]
  (addsimps propositional_rewrites empty_ss);

let cleanup_simpset = add_cryptol_defs ["ecEq", "PEqInteger"] prop_simpset;
*/

let {{
  e1_scalar_mult: Integer -> AffinePoint t_Fp -> AffinePoint t_Fp
  e1_scalar_mult k P = if k < 0 then e1_scalar_mult (-k) (neg E P)
                       else if k == 0 then point_O E
                       else add E P (e1_scalar_mult (k-1) P)

  e1_order: AffinePoint t_Fp -> Integer
  e1_order P = undefined 
  }};


//  We use algebraic rules relating addition and doubling to scalar multiples

// ... cover function for the effect of point_add, in affine space
let {{
  add' C p1 p2 = if p1 == p2 then point_O C else add C p1 p2

  add_exponents': Integer -> Integer -> Integer -> Integer
  add_exponents' e1 e2 order = if (e1-e2)%order == 0 then 0 else e1+e2
  }};

e1_scalar_mult_alg_thms <- for
  [ // {{ \ k p1 -> point_double Fp (e1_scalar_mult k p1) == e1_scalar_mult (2*k) p1 }}
  // , {{ \ p1 -> point_double Fp p1 == e1_scalar_mult 2 p1 }}
    {{ \ p1 -> add E p1 p1 == e1_scalar_mult 2 p1 }}
  , {{ \ k k' p1 -> e1_scalar_mult k (e1_scalar_mult k' p1) == e1_scalar_mult (k*k') p1 }}

  , {{ \ k k' p1 -> add E (e1_scalar_mult k p1) (e1_scalar_mult k' p1) ==
                    e1_scalar_mult (k + k') p1 }}
  // plus two special cases for k==1 or k'==1
  , {{ \ k    p1 -> add E (e1_scalar_mult k p1) p1 == e1_scalar_mult (k + 1) p1 }}
  , {{ \ k    p1 -> add E p1 (e1_scalar_mult k p1) == e1_scalar_mult (k + 1) p1 }}

  // add'
  , {{ \ k k' p1 -> add' E (e1_scalar_mult k p1) (e1_scalar_mult k' p1) ==
                    e1_scalar_mult (add_exponents' k k' (e1_order p1)) p1 }}
  // ... with two special cases
  , {{ \ k    p1 -> add' E (e1_scalar_mult k p1) p1 ==
                      e1_scalar_mult (add_exponents' k 1 (e1_order p1)) p1 }}
  , {{ \ k    p1 -> add' E p1 (e1_scalar_mult k p1) ==
                      e1_scalar_mult (add_exponents' k 1 (e1_order p1)) p1 }}

  // negation
  , {{ \k p1 -> neg E (e1_scalar_mult k p1) == e1_scalar_mult (- k) p1 }}
  // for precomputation, may need to know p == [1]p
  // , {{ \p1 -> ec_scalar_mult 1 p1 == p1 }}
  // and get rid of the (0,0,0) that come up
  , {{ \p1 -> point_add Fp (0,0,0) p1 == p1 }}
  // , {{ \p1 -> point_add Fp p1 (0,0,0) == ??? }}
  , {{ point_double Fp (0,0,0) == (0,0,0) }}
  ] admit_cryptol;

// abstract effect of the concrete operations

curve_op_thms <- for
 [ {{ \ p1 -> affinify E (point_double Fp p1) == add E (affinify E p1) (affinify E p1) }}
 , {{ \ p1 p2 -> affinify E (point_add Fp p1 p2) == add' E (affinify E p1) (affinify E p2) }}
 , {{ \ p1 -> affinify E (point_neg Fp p1) == neg E (affinify E p1) }}
 // eventually will need more, for dadd, dadd_affine, add_affine

// and theorems for equality of exponentials
 , {{ \ k k' p1 -> (e1_scalar_mult k p1 == e1_scalar_mult k' p1) == ( (k-k') % (e1_order p1) == 0 ) }}
 // with two special cases
  , {{ \ k p1 -> (p1 == e1_scalar_mult k p1) == ( (k-1) % (e1_order p1) == 0 ) }}
  , {{ \ k p1 -> (e1_scalar_mult k p1 == p1) == ( (k-1) % (e1_order p1) == 0 ) }}
 // and a tidy-up
 , {{ \p1 -> affinify E (POINTonE1_abs p1) == POINTonE1_abs' p1 }}
 ] 
 admit_cryptol;
 
// and abs_rep rules for points

POINTonE1_thms <- for
 [ {{ \p1 -> POINTonE1_abs (POINTonE1_rep p1) == p1 }}
 , {{ \p1 -> POINTonE1_invariant (POINTonE1_rep p1) == True }}
 // , {{ \p1 -> POINTonE1_rep (POINTonE1_abs p1) == p1 }} // FIX THIS
 , {{ \p1 -> POINTonE1_rep (POINTonE1_abs p1) ==
             if POINTonE1_invariant p1
             then p1
             else POINTonE1_normalize p1 }}
 // , {{ POINTonE1_invariant (zero, zero, zero) == True }} // "zero" gives a useless SAWcore term here
 , {{ \c p1 p2 -> POINTonE1_invariant (if c then p1 else p2) ==
         if c then POINTonE1_invariant p1 else POINTonE1_invariant p2 }}
 , {{ \c p1 p2 -> POINTonE1_rep (if c then p1 else p2) ==
         if c then POINTonE1_rep p1 else POINTonE1_rep p2 }}
 , {{ \c p1 p2 -> POINTonE1_abs (if c then p1 else p2) ==
         if c then POINTonE1_abs p1 else POINTonE1_abs p2 }}

 , {{ \c p1 p2 -> point_neg Fp (if c then p1 else p2) ==
                  if c then point_neg Fp p1 else point_neg Fp p2 }}

 , {{ \(x:POINTonE1_t) -> (x.0, x.1, x.2) == x }}
 , {{ \(x:POINTonE1_affine_t) -> (x.0, x.1) == x }}
 ]
 (\t -> custom_prove_cryptol (rewrite (cryptol_ss ()) t)
    do { unfolding ["POINTonE1_abs", "POINTonE1_rep", "POINTonE1_invariant", "POINTonE1_normalize"];
         apply_fp_rewrites;
         // unfolding ["fp_invariant"]; // for the (zero,zero,zero) thm
         simplify (addsimp fp_normalize_thm empty_ss); // for the rep_abs rule
         w4_unint_z3 fp_unints; }) ;

// We need some non-higher order cover functions; e.g., point_add can not be left uninterpreted but
// point_add_fp can be.

let {{
  point_add_fp = point_add Fp
  point_double_fp = point_double Fp
  point_neg_fp = point_neg Fp
  add_E = add E
  add'_E = add' E
  affinify_E = affinify E
  }};

point_add_fp_thm <- prove_cryptol {{  \p1 p2 -> point_add Fp p1 p2 == point_add_fp p1 p2 }} ["Fp"];
point_double_fp_thm <- prove_cryptol {{  \p1 -> point_double Fp p1 == point_double_fp p1 }} ["Fp"];
point_neg_fp_thm <- prove_cryptol {{  \p1 -> point_neg Fp p1 == point_neg_fp p1 }} ["Fp"];
add_E_thm <- prove_cryptol {{  \p1 p2 -> add E p1 p2 == add_E p1 p2 }} ["E"];
add'_E_thm <- prove_cryptol {{  \p1 p2 -> add' E p1 p2 == add'_E p1 p2 }} ["E"];
affinify_E_thm <- prove_cryptol {{  \p1 -> affinify E p1 == affinify_E p1 }} ["E"];

let remove_higher_order_function_simpset =
  addsimps [ point_add_fp_thm, point_double_fp_thm, point_neg_fp_thm
           , add_E_thm, add'_E_thm, affinify_E_thm] empty_ss;

// more rules to hoist `if`-terms

ec_mult_structure_thms <- for
  [ {{ \k c P Q -> e1_scalar_mult k (if c then P else Q) ==
                   if c then e1_scalar_mult k P else e1_scalar_mult k Q }}
  , {{ \c P1 P2 Q -> point_add Fp (if c then P1 else P2) Q ==
                     if c then point_add Fp P1 Q else point_add Fp P2 Q }}
  , {{ \c P Q1 Q2 ->point_add Fp P (if c then Q1 else Q2) ==
                     if c then point_add Fp P Q1 else point_add Fp P Q2 }}
  ]
  (\ th -> prove_cryptol (rewrite (cryptol_ss ()) th) ["e1_scalar_mult", "Fp"]);
  
let ec_mult_overrides = concat vec_overrides
  [ POINTonE1_add_ov, POINTonE1_add_alias_1_2_ov
  , POINTonE1_double_ov, POINTonE1_double_alias_1_2_ov
  , POINTonE1_cneg_ov, POINTonE1_on_curve_ov
  ];

let ec_mult_unints =
    [ "e1_scalar_mult", "e1_order"
    , "POINTonE1_abs", "POINTonE1_rep", "POINTonE1_invariant", "POINTonE1_normalize"
    , "point_add", "point_double", "Fp", "point_add_fp", "point_double_fp", "point_neg_fp"
    , "precomputed_table"
    , "add_E", "add'_E", "affinify_E"
    ];

////////////////

  
// precomputed_table

let {{
  small_mult: Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp
  small_mult i p1 =
    if i < 0 then point_neg_fp (small_mult (-i) p1)
     | i == 0 then zero
     | i == 1 then p1
     | (i%2)==0 then point_double_fp (small_mult (i/2) p1)
    else point_add_fp (small_mult (i/2 + 1) p1) (small_mult (i/2) p1)

  precomputed_table: ProjectivePoint t_Fp -> [16]POINTonE1_t
  precomputed_table p1 = [POINTonE1_rep p1] # [POINTonE1_rep (small_mult i p1) | i <- [2..16] ]

  precomputed_table' p1 = [POINTonE1_rep (small_mult i p1) | i <- [1..16] ]
}};

precomputed_table_invariant_thm <- custom_prove_cryptol
  {{ \ p1 -> all POINTonE1_invariant (precomputed_table p1) == True }}
  do { goal_eval_unint ["POINTonE1_invariant", "POINTonE1_rep", "e1_scalar_mult"];
       simplify (addsimps POINTonE1_thms fp_simpset);
       w4_unint_z3 ["POINTonE1_invariant", "POINTonE1_rep", "e1_scalar_mult"]; } ;


let POINTonE1_precompute_w5_spec = do {
    row_ptr <- crucible_alloc (llvm_array 16 POINTonE1_type);
    (point, point_ptr) <- ptr_to_fresh_readonly "point" POINTonE1_type;
    crucible_precond {{ POINTonE1_invariant point }};
    crucible_execute_func [row_ptr, point_ptr];
    crucible_points_to row_ptr (crucible_term {{ precomputed_table (POINTonE1_abs point) }} );
    };

 POINTonE1_precompute_w5_ov <-
   custom_verify "POINTonE1_precompute_w5" ec_mult_overrides POINTonE1_precompute_w5_spec
     do { unfolding ["precomputed_table"];
          simplify (addsimps POINTonE1_thms empty_ss);
          simplify remove_higher_order_function_simpset;
          w4_unint_z3 ec_mult_unints; } ;


// This theorem requires a strong induction:
//  {{ \p1 i -> 0 <= i ==> affinify E (small_mult i p1) == e1_scalar_mult i (affinify E p1) }}
// There is a base case, i=0:
small_mult_is_scalar_mult_0_thm <- prove_cryptol
  {{ \p1 -> affinify E (small_mult 0 p1) == e1_scalar_mult 0 (affinify E p1) }}
  [];
// and there is a step for even exponents, that just needs double,
// and a step for odd exponents, where we need to show that adding [k]P and [k+1]P does not
// need to double.  That's true, unless P=point_O, and the point_O case also works.

small_mult_is_scalar_mult_thm <- admit_cryptol
  {{ \p1 i -> affinify_E (small_mult i p1) == e1_scalar_mult i (affinify_E p1) }};

// POINTonE1_gather_booth_w5

let {{
  booth_lookup: [16]POINTonE1_t -> Bit -> [SZ] -> POINTonE1_t
  booth_lookup table s v = POINTonE1_rep (if s then point_neg Fp w else w) where
    w = POINTonE1_abs (([zero] # table) @ v')
    v' = if v <= 16 then v else 0

  booth' table (bi:Limb) = booth_lookup table (bi!`SZ) (drop bi)
  }};

invariant_booth'_thm <-
  custom_prove_cryptol
  {{ \p1 booth_index -> POINTonE1_invariant (booth' (precomputed_table p1) booth_index) == True }}
  do { unfolding ["booth'", "booth_lookup"];
       simplify (addsimp (nth POINTonE1_thms 1) (cryptol_ss ())); // the "invariant_rep" theorem
       w4_unint_z3 ec_mult_unints; } ;

let {{
  booth_exponent: Limb -> Integer
  booth_exponent bi = if (bi!`SZ) then -e else e where
    e1 = toInt (drop`{back=SZ} bi)
    e = if e1 <= 16 then e1 else 0
  }};

/*
booth'_precomputed_table_thm <- custom_prove_cryptol 
  {{ \p1 booth_index -> POINTonE1_abs (booth' (precomputed_table p1) booth_index) ==
                        small_mult (booth_exponent booth_index) p1 }}
  do { unfolding ["booth'", "booth_lookup", "precomputed_table"];
       // simplify (addsimps ec_mult_structure_thms (addsimps POINTonE1_thms (cryptol_ss ())));
       simplify (addsimps POINTonE1_thms (cryptol_ss ()));
       print_goal;
       w4_unint_z3 ec_mult_unints;
       };
*/
// We should be able to prove this:
booth'_precomputed_table_thm <- admit_cryptol 
  {{ \p1 booth_index -> POINTonE1_abs (booth' (precomputed_table p1) booth_index) ==
                        small_mult (booth_exponent booth_index) p1 }};


let POINTonE1_gather_booth_w5_spec = do {
    p_ptr <- crucible_alloc POINTonE1_type;
    (table, table_ptr) <- ptr_to_fresh_readonly "table" (llvm_array 16 POINTonE1_type);
    booth_idx <- crucible_fresh_var "booth_idx" limb_type;
    crucible_precond {{ booth_idx <= 16 \/ (-32 <= booth_idx /\ booth_idx <= -16) }}; // NB unsigned comparisons
    // need to assume each element of the table satisfies the invariant:
    crucible_precond {{ all POINTonE1_invariant table }};
    crucible_execute_func [p_ptr, table_ptr, crucible_term {{booth_idx}}];
    crucible_points_to p_ptr (crucible_term {{ booth' table booth_idx }});
    };


POINTonE1_gather_booth_w5_ov <-
   custom_verify "POINTonE1_gather_booth_w5" ec_mult_overrides POINTonE1_gather_booth_w5_spec
     do { unfolding ["select", "all", "booth'", "booth_lookup"];
          simplify (addsimps ec_mult_structure_thms (addsimps POINTonE1_thms (cryptol_ss ())));
          unfolding ["POINTonE1_invariant", "fp_invariant"]; // for the zero
          w4_unint_z3 ec_mult_unints; } ;


//  POINTonE1_mult_w5


// We define here the terms built up by the loop in `mult_w5`
let {{
  mult_w5_intermediate es p = foldl step start (tail es) where
    step acc e = add'_E (e1_scalar_mult shift acc) (affinify_E (small_mult e p))
    start = affinify_E (small_mult (head es) p)

  // alternative defn.
  mult_w5_intermediate' es p = accs!0 where
    accs = [start] # [add' E (e1_scalar_mult shift acc) (affinify E (small_mult e p)) | acc <- accs | e <- tail es]
    start = affinify E (small_mult (head es) p)
    
  mult_w5_result_term: {n} (fin n, n >= 1) => [n] -> ProjectivePoint t_Fp -> AffinePoint t_Fp
  mult_w5_result_term e p = mult_w5_intermediate (booth_parts e) p
  }};
  

// We next show that the result term gives a correct result.  
// this is by rewriting `small_mult` to `e1_scalar_mult`, then the algebraic rules of scalar multiplication
// The only wrinkle is in the use of `add'`, where we need to make sure we are not adding a point to
// itself.

let {{ shift_and_add acc e = shift*acc + e

       no_doubles es order = // never need to add a point to itself (inb terms of on exponents)
         all (\  (acc, val) -> (acc-val)%order != 0)
             (zip (take (tail (scanl shift_and_add 0 es)))  (tail es))

       has_bounded_partial_sums es low high =
          all (\x -> low <= x /\ x <= high) (scanl shift_and_add 0 es)
       intermediate_result_lemma: {n} (fin n, n >= 1) => [n]Integer -> ProjectivePoint t_Fp -> Bool
       intermediate_result_lemma es p =
             has_bounded_partial_sums es (-ord) ord
               ==> mult_w5_intermediate es p == e1_scalar_mult (foldl shift_and_add 0 es) (affinify E p)
             where ord = e1_order (affinify E p)

       booth_with_add' es order = foldl step (head es) (tail es) where
         step acc e = add_exponents' (shift * acc) e order
  }};

print "%%%% Mult_w5_result_term ...";

for [4,5,6,7,12,14, 64, 100] (\ bits ->
 custom_prove_cryptol
  {{ \ (e:[bits]) p -> mult_w5_result_term e p == e1_scalar_mult (booth_with_add' (booth_parts e) (e1_order (affinify_E p))) (affinify_E p) }}
  do { goal_eval_unint [ "e1_order", "e1_scalar_mult", "affinify_E", "booth_parts"
                       , "add'_E", "small_mult", "add_exponents'"];
       simplify cleanup_simpset;
       simplify (addsimps (concat [small_mult_is_scalar_mult_thm] POINTonE1_thms) empty_ss);
       unfolding ["add'_E"]; // so that the rules can apply
       simplify (addsimps e1_scalar_mult_alg_thms empty_ss);
       simplify remove_higher_order_function_simpset; // and fold up again so it can be uninterpreted
       // print_goal;
       w4_unint_z3 [ "e1_order", "e1_scalar_mult", "affinify_E", "booth_parts"
                   , "add'_E", "small_mult", "add_exponents'"];
     } );

/*
print "%%% Exponent theorems 1 %%%";
for [4,5,6,7,8,9,10,11,12,13] // about 2s for 13, up to 6s for 16, 15m for 20.
  (\ bits -> 
      prove_cryptol {{ \ (e:[bits]) order -> (order > (toInt e) + shift
                                 ==> booth_with_add' es order == foldl shift_and_add 0 es
                                  where es = booth_parts e )}} [] );
*/

print "%%% Exponent theorems 2 %%%";
for [4,5,6,7,8,9,10,11,12,13]
  (\ bits -> 
      prove_cryptol {{ \ (e:[bits]) order -> order > (toInt e) + shift
                                 ==> booth_with_add' (booth_parts e) order == booth e }} [] );

// conditional version:
for [4,5,6,9,13]
  (\ bits -> 
      really_prove_cryptol {{ \ (e:[bits]) order ->
        booth_with_add' (booth_parts e) order ==
          if order > (toInt e) + shift
          then booth e
          else apply booth_with_add' (booth_parts e) order }} [] );


// We will only be able to prove things for specific concrete sizes


// NOTE: scalar_ptr passed to get_wval, cast to limb, so must be aligned by 8 <= FIX: what if limb_t changes?
let POINTonE1_mult_w5_spec n_bytes bits = do {
    ret_ptr <- crucible_alloc  POINTonE1_type;
    (point, point_ptr) <- ptr_to_fresh_readonly "point" POINTonE1_type;
    // needs alignment
    scalar_ptr <- crucible_alloc_readonly_aligned 8 (llvm_array n_bytes (llvm_int 8));
    scalar <- crucible_fresh_var "scalar" (llvm_array n_bytes (llvm_int 8));
    crucible_points_to scalar_ptr (crucible_term scalar);
    crucible_precond {{ POINTonE1_invariant point }};
    // crucible_precond {{ e1_order (POINTonE1_abs point) > 16000000 }}; // TODO FIX bound
    crucible_execute_func [ret_ptr, point_ptr, scalar_ptr, crucible_term {{`bits:Limb}}];
    ret <- crucible_fresh_var "ret" POINTonE1_type;
    crucible_points_to ret_ptr (crucible_term ret);
    crucible_postcond {{ affinify E (POINTonE1_abs ret) ==
                         mult_w5_result_term`{bits} (drop (join (reverse scalar)))
                                                    (POINTonE1_abs point) }};
    };

let POINTonE1_mult_script noisy = do {
      simplify (addsimps curve_op_thms
                       (addsimps POINTonE1_thms
                                 (addsimps e1_scalar_mult_alg_thms
                                           (addsimps [ invariant_booth'_thm
                                                     , precomputed_table_invariant_thm
                                                     , booth'_precomputed_table_thm
                                                     ]
                                                     empty_ss))));
    if noisy
    then do {
      simplify remove_higher_order_function_simpset; // needed before goal_eval_unint
      print_goal_consts;
      goal_eval_unint (concat ["e1_scalar_mult", "small_mult"] ec_mult_unints);
      simplify (addsimps POINTonE1_thms fp_simpset);
      unfolding ["Fp", "prime_field_integer"]; // for readability of Fp components
      simplify cleanup_simpset; print_goal;
      } else do {
      return ();
      };
    simplify remove_higher_order_function_simpset;
    w4_unint_z3 (concat ["e1_scalar_mult", "small_mult"] ec_mult_unints);
    } ;


// This works! (one block)
POINTonE1_mult_w5_1_3_spec <- custom_verify "POINTonE1_mult_w5"
   (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
   (POINTonE1_mult_w5_spec 1 3)
   (POINTonE1_mult_script false);

// and a simple case of SZ divides bits:, takes about 0.5 seconds

POINTonE1_mult_w5_1_5_spec <- custom_verify "POINTonE1_mult_w5"
   (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
   (POINTonE1_mult_w5_spec 1 5)
   (POINTonE1_mult_script false);

// 2 blocks, 1 byte

POINTonE1_mult_w5_1_6_spec <- custom_verify "POINTonE1_mult_w5"
   (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
   (POINTonE1_mult_w5_spec 1 6)
   (POINTonE1_mult_script false);

// 3 blocks, 2 bytes - about 4 seconds

POINTonE1_mult_w5_2_15_spec <- custom_verify "POINTonE1_mult_w5"
   (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
   (POINTonE1_mult_w5_spec 2 15)
   (POINTonE1_mult_script false);

// 4 blocks, 31 bits - about 18s
POINTonE1_mult_w5_4_14_spec <- custom_verify "POINTonE1_mult_w5"
   (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
   (POINTonE1_mult_w5_spec 4 31)
   (POINTonE1_mult_script false);

/*
print "%%%% 8,58";
// 8 blocks, 58 bits - about 4m 15s
POINTonE1_mult_w5_8_58_spec <- custom_verify "POINTonE1_mult_w5"
   (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
   (POINTonE1_mult_w5_spec 8 58)
   (POINTonE1_mult_script false);
*/
/*

// For `mult_w5` we use the experimental compositional extraction method to get a Term representing the
// effect of the function call.  We can then prove theorems directly about this term.

// We do this for a small number of values of the `bits` parameter, and corresponding
// lengths of the scalar.
mult_extract_ovs <- for [6,8,15,20]
  (\ bits -> 
crucible_llvm_compositional_extract  m  "POINTonE1_mult_w5" (str_concat "mult_extract" (show bits))
 (concat [POINTonE1_precompute_w5_ov, POINTonE1_gather_booth_w5_ov] ec_mult_overrides)
 false
 do {
    // let bits = 8;
    let n_bytes = eval_int {{ (7+(`bits:Limb)) / 8 }};
    ret_ptr <- crucible_alloc  POINTonE1_type;
    (point, point_ptr) <- ptr_to_fresh_readonly "point" POINTonE1_type;
    // needs alignment
    scalar_ptr <- crucible_alloc_readonly_aligned 8 (llvm_array n_bytes (llvm_int 8));
    scalar <- crucible_fresh_var "scalar" (llvm_array n_bytes (llvm_int 8));
    crucible_points_to scalar_ptr (crucible_term scalar);

    crucible_precond {{ POINTonE1_invariant point }};
    // crucible_precond {{ e1_order (POINTonE1_abs point) > 16000000 }}; // TODO FIX bound
    crucible_execute_func [ret_ptr, point_ptr, scalar_ptr, crucible_term {{`bits:Limb}}];
    ret <- crucible_fresh_var "ret" POINTonE1_type;
    crucible_points_to ret_ptr (crucible_term ret);
    }

  do {
    simplify (addsimps ec_mult_structure_thms
                       (addsimps POINTonE1_thms
                                 (addsimps e1_scalar_mult_alg_thms
                                           (addsimps [ point_add_fp_thm
                                                     , invariant_booth'_thm
                                                     , precomputed_table_invariant_thm
                                                     //, precomputed_table_is_table_thm
                                                     ]
                                                     empty_ss))));
    w4_unint_z3 ec_mult_unints; }) ;


// Proof experiments:
let xscript =   do {
    simplify (addsimps ec_mult_structure_thms
                       (addsimps POINTonE1_thms
                                 (addsimps e1_scalar_mult_alg_thms
                                           (addsimps [ point_add_fp_thm
                                                     , invariant_booth'_thm
                                                     , precomputed_table_invariant_thm
                                                     , booth'_precomputed_table_thm
                                                     // , precomputed_table_is_table_thm
                                                     ]
                                                     empty_ss))));
    print_goal;
    goal_eval_unint ec_mult_unints;
    print_goal;
    w4_unint_z3 ec_mult_unints; } ;

 let ss = addsimps (concat POINTonE1_thms (concat e1_scalar_mult_alg_thms curve_op_thms)) (cryptol_ss());
 let ss' = addsimp booth'_precomputed_table_thm ss;
 P <- fresh_symbolic "P" {| POINTonE1_t |} ;

*/
