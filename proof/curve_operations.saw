/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

include "fp_overrides.saw";

//include "helpers.saw";
//include "list_utils.saw";
//include "types.saw";

//let POINTonE1_type = llvm_type "{i384, i384, i384}" ;
//let POINTonE1_affine_type = llvm_type "{i384, i384}";
let POINTonE1_type = llvm_struct "struct.POINTonE1";
let POINTonE1_affine_type = llvm_struct "struct.POINTonE1_affine";

import "../spec/ShortWeierstrassCurve.cry";
import "../spec/ProjectiveCurveOperations.cry";
import "../spec/implementation/Types.cry";
import "../spec/implementation/CurveOperation.cry";

let do_prove = true;
include "proof-helpers.saw";

propositional_rewrites <- for
  [ "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (ite Bool a True b) (or a b))"
  , "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (ite Bool a b False) (and a b))"
  , "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (not (and a b)) (or (not a) (not b)))"
  , "(a:Bool) -> (b:Bool) -> EqTrue (eq Bool (not (or a b)) (and (not a) (not b)))"
   ] (prove_core abc);

let prop_simpset = add_prelude_eqs
  [ "ite_true", "ite_false", "ite_eq"
  , "not_True", "not_False", "not_not"
  , "and_True1", "and_True2", "and_False1", "and_False2", "and_idem"
  , "or_True1", "or_True2", "or_False1", "or_False2", "or_idem"]
  (addsimps propositional_rewrites empty_ss);

let cleanup_simpset = add_cryptol_defs ["ecEq", "PEqInteger"] prop_simpset;

let print_goal_readably_fp = do {
    unfolding ["Fp", "prime_field_bv", "prime_field_integer", "prime_field"];
    simplify cleanup_simpset;
    print_goal;
    };

// In order to get the necessary rewrites to happen, there are some "administrative" type
// rewrites that help bring the terms we need together.    We start with them:

core_rewrites <- for
  [ "EqTrue (eq Nat (intToNat (natToInt 0)) 0)"
  , "EqTrue (eq Nat (intToNat (natToInt 1)) 1)"

  , "(x: (Vec 6 (Vec 64 Bool))) -> (y: (Vec 6 (Vec 64 Bool))) -> EqTrue (eq (Vec 6 (Vec 64 Bool)) (at 2 (Vec 6 (Vec 64 Bool)) [x,y] 0) x)"
  , "(x: (Vec 6 (Vec 64 Bool))) -> (y: (Vec 6 (Vec 64 Bool))) -> EqTrue (eq (Vec 6 (Vec 64 Bool)) (at 2 (Vec 6 (Vec 64 Bool)) [x,y] 1) y)"
  
  , "(b: Bool) -> (x: (Vec 2 (Vec 6 (Vec 64 Bool)))) -> (y: (Vec 2 (Vec 6 (Vec 64 Bool)))) -> EqTrue (eq (Vec 6 (Vec 64 Bool)) (at 2 (Vec 6 (Vec 64 Bool)) (ite (Vec 2 (Vec 6 (Vec 64 Bool))) b x y) 0) (ite (Vec 6 (Vec 64 Bool)) b (at 2 (Vec 6 (Vec 64 Bool)) x 0) (at 2 (Vec 6 (Vec 64 Bool)) y 0)))"
  , "(b: Bool) -> (x: (Vec 2 (Vec 6 (Vec 64 Bool)))) -> (y: (Vec 2 (Vec 6 (Vec 64 Bool)))) -> EqTrue (eq (Vec 6 (Vec 64 Bool)) (at 2 (Vec 6 (Vec 64 Bool)) (ite (Vec 2 (Vec 6 (Vec 64 Bool))) b x y) 1) (ite (Vec 6 (Vec 64 Bool)) b (at 2 (Vec 6 (Vec 64 Bool)) x 1) (at 2 (Vec 6 (Vec 64 Bool)) y 1)))"
   ] (prove_core abc);

more_rewrites <- for
  [ {{ \ b (x:(Integer,Integer,Integer)) y -> (if b then x else y).0 == (if b then x.0 else y.0) }}
  , {{ \ b (x:(Integer,Integer,Integer)) y -> (if b then x else y).1 == (if b then x.1 else y.1) }}
  , {{ \ b (x:(Integer,Integer,Integer)) y -> (if b then x else y).2 == (if b then x.2 else y.2) }}

  , {{ \ b (x:([6][64], [6][64], [6][64])) y -> (if b then x else y).0 == (if b then x.0 else y.0) }}
  , {{ \ b (x:([6][64], [6][64], [6][64])) y -> (if b then x else y).1 == (if b then x.1 else y.1) }}
  , {{ \ b (x:([6][64], [6][64], [6][64])) y -> (if b then x else y).2 == (if b then x.2 else y.2) }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss()) t) []);

let structural_rewrites = concat more_rewrites core_rewrites;


////////////////////////////////////////////////////////////////
//
// Operations on E1, over Fp
//

// ... first some useful overrides
// ... starting with vec_select
let vec_select_asm_spec (bytes:Int) = do {
  ret_ptr <- crucible_alloc (llvm_array bytes (llvm_int 8));
  (a, a_ptr) <- ptr_to_fresh_readonly "a" (llvm_array bytes (llvm_int 8));
  (b, b_ptr) <- ptr_to_fresh_readonly "b" (llvm_array bytes (llvm_int 8));
  sel_a <- crucible_fresh_var "sel_a" limb_type;
  crucible_execute_func [ret_ptr, a_ptr, b_ptr, crucible_term sel_a];
  crucible_points_to ret_ptr (crucible_term {{ if (sel_a != 0) then a else b }});
};

let vec_select_asm_alias_1_3_spec bytes = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret" (llvm_array bytes (llvm_int 8));
  (a, a_ptr) <- ptr_to_fresh_readonly "a" (llvm_array bytes (llvm_int 8));
  sel_a <- crucible_fresh_var "sel_a" limb_type;
  crucible_execute_func [ret_ptr, a_ptr, ret_ptr, crucible_term sel_a];
  crucible_points_to ret_ptr (crucible_term {{ if (sel_a != 0) then a else ret }});
};

let mk_vec_select_asm_ov bytes = crucible_llvm_unsafe_assume_spec m (str_concat "vec_select_" (show bytes)) (vec_select_asm_spec bytes);

let mk_vec_select_asm_alias_1_3_ov bytes = crucible_llvm_unsafe_assume_spec m (str_concat "vec_select_" (show bytes)) (vec_select_asm_alias_1_3_spec bytes);

let vec_select_sizes = [48, 96, 144, 192, 288];
vec_select_asm_ovs <- do {
  ovs <- (for vec_select_sizes mk_vec_select_asm_ov);
  // ovs_1_2  <- (for vec_select_sizes mk_vec_select_alias_1_2_ov);
  ovs_1_3  <- (for vec_select_sizes mk_vec_select_asm_alias_1_3_ov);
  // return (foldr concat [ovs, ovs_1_2] ovs_1_3);
  return (concat ovs ovs_1_3);
  };

//fp_abs_select_thm  <- prove_print (w4_unint_z3 ["fp_abs"])
//  {{ \ a b c -> fp_abs (select a b c) == select (fp_abs a) (fp_abs b) c }};

point_abs_select_thm  <- prove_print (w4_unint_z3 ["POINTonE1_abs"])
  {{ \ a b c -> POINTonE1_abs (select_POINTonE1_rep a b c) == select_POINTonE1 (POINTonE1_abs a) (POINTonE1_abs b) c }};


let vec_select_spec bytes ty = do {
  ret_ptr <- crucible_alloc ty;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" ty;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" ty;
  sel_a <- crucible_fresh_var "sel_a" limb_type;
  crucible_execute_func [ret_ptr, a_ptr, b_ptr, crucible_term {{`bytes:Size_t }}, crucible_term sel_a];
  crucible_points_to ret_ptr (crucible_term {{ select a b (sel_a != 0)}});
};

let vec_select_alias_1_3_spec bytes ty = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret" ty;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" ty;
  sel_a <- crucible_fresh_var "sel_a" limb_type;
  crucible_execute_func [ret_ptr, a_ptr, ret_ptr, crucible_term {{`bytes:Size_t}}, crucible_term sel_a];
  crucible_points_to ret_ptr (crucible_term {{ select a ret (sel_a != 0)}});
};

vec_select_POINTonE1_ov <- verify "vec_select" vec_select_asm_ovs (vec_select_spec 144 POINTonE1_type);

vec_select_alias_1_3_POINTonE1_ov <- verify "vec_select" vec_select_asm_ovs (vec_select_alias_1_3_spec 144 POINTonE1_type);

vec_select_Fp_ov <- verify "vec_select" vec_select_asm_ovs (vec_select_spec 48 vec384_type);

vec_select_Fp_alias_1_3_ov <- verify "vec_select" vec_select_asm_ovs (vec_select_alias_1_3_spec 48 vec384_type);

vec_select_2Fp_ov <- verify "vec_select" vec_select_asm_ovs (vec_select_spec 96 (llvm_array 2 vec384_type));

vec_select_2Fp_alias_1_3_ov <- verify "vec_select" vec_select_asm_ovs (vec_select_alias_1_3_spec 96 (llvm_array 2 vec384_type));

let vec_select_overrides = [vec_select_POINTonE1_ov, vec_select_alias_1_3_POINTonE1_ov
                           , vec_select_Fp_ov, vec_select_Fp_alias_1_3_ov
                           , vec_select_2Fp_ov, vec_select_2Fp_alias_1_3_ov
                           ];

// ... and continuing with vec_is_zero

/*
let vec_is_zero_spec n = do { // n is size IN LIMBS; routine takes size in bytes
  (a, a_ptr) <- ptr_to_fresh "a" (llvm_array n limb_type);
  crucible_execute_func [a_ptr, crucible_term {{ (8 * (`n:Size_t)) }}]; // Non-portable
  crucible_return (crucible_term {{ if a == (zero:[n]Limb) then 1 else (0:Limb) }});
  // crucible_return (crucible_term {{ if fp_equal_rep a Fp_rep.field_zero then 1 else (0:Limb) }});
  // crucible_return (crucible_term {{ if xeq a (zero:[n]Limb) then 1 else (0:Limb) }});
  };

// vec_is_zero_48_ov <- crucible_llvm_verify m "vec_is_zero" [] false (vec_is_zero_spec 6) z3;
*/

// ... we actually want the is-0 test in the abstract domain

let vec_is_zero_fp_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  crucible_precond {{ fp_invariant a }};
  crucible_execute_func [a_ptr, crucible_term {{ (48:Size_t) }}]; // Non-portable
  // crucible_return (crucible_term {{ if fp_equal_rep a Fp_rep.field_zero then 1 else (0:Limb) }});
  crucible_return (crucible_term {{ if (fp_abs a) ==  Fp.field_zero then 1 else (0:Limb) }});
  };

// TODO: Prove
vec_is_zero_fp_ov <- test "vec_is_zero" [] vec_is_zero_fp_spec;
//  do { unfolding ["fp_invariant", "fp_abs", "vec384_abs" ]; beta_reduce_goal; print_goal; quickcheck 100; };
//  do { unfolding ["fp_invariant", "fp_abs", "vec384_abs" ]; beta_reduce_goal; print_goal; z3; };

// dadd needs a 2*Fp version of is_zero

let vec_is_zero_2fp_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" (llvm_array 2 vec384_type);
  crucible_precond {{ fp_invariant (a@0) /\ fp_invariant (a@1) }};
  crucible_execute_func [a_ptr, crucible_term {{ (96:Size_t) }}]; // Non-portable
  crucible_return (crucible_term {{ if fp_abs (a@0) ==  Fp.field_zero /\ fp_abs (a@1) == Fp.field_zero then 1 else (0:Limb) }});
  };

// TODO: prove
vec_is_zero_2fp_ov <- test "vec_is_zero" []  vec_is_zero_2fp_spec;

// ... continuing with vec_is_equal

let vec_is_equal_fp_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384_type;
  crucible_precond {{ fp_invariant a /\  fp_invariant b }};
  crucible_execute_func [a_ptr, b_ptr, crucible_term {{ (48:Size_t) }}]; // Non-portable
  crucible_return (crucible_term {{ if fp_abs a ==  fp_abs b then 1 else (0:Limb) }});
  };

//TODO: prove
vec_is_equal_fp_ov <- test "vec_is_equal" []  vec_is_equal_fp_spec;

let vec_is_equal_2fp_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" (llvm_array 2 vec384_type);
  (b, b_ptr) <- ptr_to_fresh_readonly "b" (llvm_array 2 vec384_type);
  crucible_precond {{     fp_invariant (a@0) /\ fp_invariant (a@1)
                      /\  fp_invariant (b@0) /\ fp_invariant (b@1) }};
  crucible_execute_func [a_ptr, b_ptr, crucible_term {{ (96:Size_t) }}]; // Non-portable
  crucible_return (crucible_term {{ if fp_abs (a@0) ==  fp_abs (b@0) /\ fp_abs (a@1) ==  fp_abs (b@1) 
                                    then 1 else (0:Limb) }});
  };

// TODO: prove
vec_is_equal_2fp_ov <- test "vec_is_equal" []  vec_is_equal_2fp_spec;

let vec_overrides = concat [ vec_is_zero_fp_ov, vec_is_zero_2fp_ov
                           , vec_is_equal_fp_ov, vec_is_equal_2fp_ov
                           ] vec_select_overrides;


////////////////////////////////////////////////////////////////
//
// Now the point operations:

enable_what4_hash_consing;

// ... POINTonE1_add


/*
mul_assoc_thm <- prove_cryptol
  {{ \ x y z -> Fp.mul (Fp.mul (x, y), z) == Fp.mul (x, Fp.mul (y, z)) }}
  [];
add_assoc_thm <- prove_cryptol {{ \ x y z -> Fp.add (Fp.add (x, y), z) == Fp.add (x, Fp.add (y, z)) }} [];
sub_elim_thm <- prove_cryptol {{ \ x y -> Fp.sub (x, y) == Fp.add (x, Fp.neg y) }} [];
neg_neg_thm <- prove_cryptol {{ \ x -> Fp.neg (Fp.neg x) == Fp.normalize x }} [];
neg_add_thm <- prove_cryptol {{ \ x y -> Fp.neg (Fp.add (x, y)) == Fp.add (Fp.neg x, Fp.neg y) }} [];
distr_left_thm <- prove_cryptol
  {{ \ x y z -> Fp.mul (Fp.add (x, y), z) == Fp.add (Fp.mul (x,z), Fp.mul(y,z)) }} [];
distr_right_thm <- prove_cryptol
  {{ \ x y z -> Fp.mul (z, Fp.add (x, y)) == Fp.add (Fp.mul (z,x), Fp.mul(z,y)) }} [];
mul_0_left_thm <- prove_cryptol {{ \x -> Fp.mul (x, Fp.field_zero) == Fp.field_zero }} [];
mul_0_right_thm <- prove_cryptol {{ \x -> Fp.mul (Fp.field_zero, x) == Fp.field_zero }} [];
mul_1_left_thm <- prove_cryptol {{ \x -> Fp.mul (x, Fp.field_unit) == Fp.normalize x }} [];
mul_1_right_thm <- prove_cryptol {{ \x -> Fp.mul (Fp.field_unit, x) == Fp.normalize x }} [];
add_0_left_thm <- prove_cryptol {{ \x -> Fp.add (x, Fp.field_zero) == Fp.normalize x }} [];
add_0_right_thm <- prove_cryptol {{ \x -> Fp.add (Fp.field_zero, x) == Fp.normalize x }} [];
neg_0_thm <- prove_cryptol {{ Fp.neg Fp.field_zero == Fp.field_zero }} [];

let fp_alg_thms = [ mul_assoc_thm, add_assoc_thm, sub_elim_thm, neg_neg_thm, neg_add_thm
                  , mul_0_left_thm, mul_0_right_thm, mul_1_left_thm, mul_1_right_thm
                  , add_0_left_thm, add_0_right_thm
                  ]; // , distr_left_thm, distr_right_thm];
*/

fp_alg_thms <- for
  [ {{ \ x y z -> Fp.mul (Fp.mul (x, y), z) == Fp.mul (x, Fp.mul (y, z)) }} // mul associates
  , {{ \x -> Fp.mul (x, Fp.field_zero) == Fp.field_zero }} // x*0 = 0
  , {{ \x -> Fp.mul (Fp.field_zero, x) == Fp.field_zero }} // 0*x = 0
  , {{ \x -> Fp.mul (x, Fp.field_unit) == Fp.normalize x }} // x*1 = x ish
  // , {{ \x -> Fp.mul (x, Fp.field_unit) == x }} // x*1 = x TODO
  , {{ \x -> Fp.mul (Fp.field_unit, x) == Fp.normalize x }} // 1*x = x ish
  // , {{ \x -> Fp.mul (Fp.field_unit, x) == x }} // 1*x = x TODO

  , {{ \x -> Fp.sq x == Fp.mul (x,x) }} // eliminate squaring.  Not always a good idea

  , {{ \ x y z -> Fp.add (Fp.add (x, y), z) == Fp.add (x, Fp.add (y, z)) }} // add associates
  , {{ \x -> Fp.add (x, Fp.field_zero) == Fp.normalize x }} // x+0 = x ish
  , {{ \x -> Fp.add (Fp.field_zero, x) == Fp.normalize x }}//  0+x = x ish

  , {{ \ x y -> Fp.sub (x, y) == Fp.add (x, Fp.neg y) }} // eliminate sub in favour of neg

  , {{ \ x -> Fp.neg (Fp.neg x) == Fp.normalize x }} // double negative
  , {{ \ x y -> Fp.neg (Fp.add (x, y)) == Fp.add (Fp.neg x, Fp.neg y) }} // push neg inside a sum
  , {{ Fp.neg Fp.field_zero == Fp.field_zero }} // -0 = 0
  ] (\ t -> prove_cryptol t []);


POINTonE1_add_equiv_thm <-
  custom_prove_cryptol
  // {{ \p1 p2 -> p1.2 != 0 /\ p2.2 != 0 ==> point_add Fp p1 p2 == p_add_bl Fp p1 p2 }}
  {{ \p1 p2 -> point_add Fp p1 p2 == if  p1.2 == 0 then p2
                                     else if p2.2 == 0 then p1
                                     else p_add_bl Fp p1 p2 }}
  do {
    unfolding ["point_add", "p_add_bl"];
    simplify (addsimps fp_alg_thms (cryptol_ss ()));
    // w4_unint_z3 fp_unints; ...fails with unints, need to commute a product
    z3; 
    } ;


let POINTonE1_add_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  (p2, p2_ptr) <- ptr_to_fresh_readonly "p2" POINTonE1_type;
  crucible_precond {{ POINTonE1_invariant p1 /\ POINTonE1_invariant p2 }};
  crucible_execute_func [out_ptr, p1_ptr, p2_ptr];
  if use_abs_method
  then do {
    out <- crucible_fresh_var "new_POINTonE1_add_out" POINTonE1_type;
    crucible_points_to out_ptr (crucible_term out);
    crucible_postcond {{ POINTonE1_invariant out }};
    crucible_postcond {{ POINTonE1_abs out == point_add Fp (POINTonE1_abs p1) (POINTonE1_abs p2)}};
    }
  else
    crucible_points_to out_ptr (crucible_term  {{ POINTonE1_rep (point_add Fp (POINTonE1_abs p1) (POINTonE1_abs p2)) }} );
};


POINTonE1_add_ov <- custom_verify "POINTonE1_add"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_add_spec
                      // (do {apply_fp_rewrites; w4_unint_z3 fp_unints;});
                      (do {apply_fp_rewrites; goal_eval_unint fp_unints;
                      unfolding ["Fp.is_equal"];
                      simplify (addsimp unrip_thm (cryptol_ss ()));
                      apply_fp_rewrites;
                      simplify (addsimp unrip_thm (cryptol_ss ()));
                      w4_unint_z3 fp_unints;});

// ... POINTonE1_add_affine

POINTonE1_add_affine_equiv_thm <-
  custom_prove_cryptol
  {{ \p1 p2 -> point_add_affine Fp p1 p2 == if  p1.2 == 0 then projectify E p2
                                     else p_add_madd_2007_bl E p1 p2 }}
  do {
    unfolding ["point_add_affine", "p_add_madd_2007_bl", "projecify", "E"];
    simplify (addsimps fp_alg_thms (cryptol_ss ()));
    // w4_unint_z3 fp_unints; ... fails
    z3; 
    } ;


let POINTonE1_add_affine_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  (p2, p2_ptr) <- ptr_to_fresh_readonly "p2" POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_invariant p1 /\ POINTonE1_affine_invariant p2 }};
  crucible_execute_func [out_ptr, p1_ptr, p2_ptr];
  if use_abs_method
  then do {
    out <- crucible_fresh_var "new_POINTonE1_add_out" POINTonE1_type;
    crucible_points_to out_ptr (crucible_term out);
    crucible_postcond {{ POINTonE1_invariant out }};
    crucible_postcond {{ POINTonE1_abs out == point_add_affine Fp (POINTonE1_abs p1) (POINTonE1_affine_abs p2) }};
    }
  else
    crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep ( point_add_affine Fp (POINTonE1_abs p1) (POINTonE1_affine_abs p2)) }});
};

//let {{
//  one_mont_p = [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
//               , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]
//  }};

one_mont_p_invariant_thm <-
  prove_cryptol (rewrite (cryptol_ss ())
    {{fp_invariant [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
                   , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]
//      {{ fp_invariant 0x15f65ec3fa80e4935c071a97a256ec6d77ce5853705257455f48985753c758baebf4000bc40c0002760900000002fffd
       == True}}) [];

// for the abs method:
one_mont_p_abs_thm <-
  prove_cryptol (rewrite (cryptol_ss ())
       {{fp_abs [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
                , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]
//         {{ fp_abs 0x15f65ec3fa80e4935c071a97a256ec6d77ce5853705257455f48985753c758baebf4000bc40c0002760900000002fffd
          == Fp.field_unit }}) [];


// for the concrete method:
one_mont_p_rep_thm <- prove_cryptol (rewrite (cryptol_ss ())
  {{ fp_rep Fp.field_unit == [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
                             , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493] }}) [] ;


// need to show: fp_invariant of `one` (in this case, BLS12_381_Rx.p, == ONE_MONT_P

POINTonE1_add_affine_ov <- custom_verify "POINTonE1_add_affine"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_add_affine_spec
                      // (do {apply_fp_rewrites; w4_unint_z3 fp_unints;});
                      do {// apply_fp_rewrites;
                          unfolding ["point_add_affine", "POINTonE1_abs", "POINTonE1_affine_abs"
                                    , "POINTonE1_invariant", "POINTonE1_affine_invariant"
                                    , "POINTonE1_rep"
                                    , "select", "/\\", "Fp.is_equal"];
                          simplify
                             (addsimps structural_rewrites
                                    (addsimps [unrip_thm, one_mont_p_abs_thm, one_mont_p_invariant_thm
                                              , one_mont_p_rep_thm] fp_simpset));
                          w4_unint_z3 fp_unints;
                          };


// ...  POINTonE1_double


POINTonE1_double_eqv_thm <-
  custom_prove_cryptol
  {{ \p1 -> point_double Fp p1 == p_double_a0_l Fp p1 }}
  z3;
/*
  do {
       //unfolding ["point_double", "p_double"]; beta_reduce_goal;
       //simplify (addsimp fp_sub_sub_thm (cryptol_ss ()));
       //print_goal;
       //unfolding ["point_double", "p_double", "E", "Fp", "F_double", "F_by4", "F_by8"
       //          , "mul_by_3", "mul_by_8", "two", "three", "prime_field_integer"];
       //beta_reduce_goal;
       //simplify (cryptol_ss()); beta_reduce_goal;
       //print_goal;
       // w4_unint_z3 fp_unints;
       };
*/

let POINTonE1_double_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  crucible_precond {{ POINTonE1_invariant p1 }};
  crucible_execute_func [out_ptr, p1_ptr];
  if use_abs_method
  then do {
    out <- crucible_fresh_var "new_POINTonE1_double_out" POINTonE1_type;
    crucible_points_to out_ptr (crucible_term out);
    crucible_postcond {{ POINTonE1_invariant out }};
    crucible_postcond {{ POINTonE1_abs out == point_double Fp (POINTonE1_abs p1)}};
    }
  else 
    crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep (point_double Fp (POINTonE1_abs p1)) }});
};

POINTonE1_double_ov <- custom_verify "POINTonE1_double"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_double_spec
                      (do {apply_fp_rewrites; goal_eval_unint fp_unints;
                           simplify (addsimp unrip_thm (cryptol_ss ()));
                           apply_fp_rewrites;
                           w4_unint_z3 fp_unints;});


// ... POINTonE1_dadd
//
//     dadd has a possible null pointer argument, so we use 2 specs.

// ... and uses a weird call to vec_is_zero to check 2 things at once.
//     We need the "structural" rewrites to deal with that:


let POINTonE1_dadd_null_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  (p2, p2_ptr) <- ptr_to_fresh_readonly "p2" POINTonE1_type;
  crucible_precond {{ POINTonE1_invariant p1 /\ POINTonE1_invariant p2 }};
  crucible_execute_func [out_ptr, p1_ptr, p2_ptr, crucible_null];
  if use_abs_method
  then do {
    out <- crucible_fresh_var "new_POINTonE1_dadd_out" POINTonE1_type;
    crucible_points_to out_ptr (crucible_term out);
    crucible_postcond {{ POINTonE1_invariant out }};
    crucible_postcond {{ POINTonE1_abs out == point_dadd Fp (POINTonE1_abs p1) (POINTonE1_abs p2) Fp.field_zero True }};
    }
  else
     crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep (point_dadd Fp (POINTonE1_abs p1) (POINTonE1_abs p2) Fp.field_zero True) }});
};

POINTonE1_dadd_null_ov <- custom_verify "POINTonE1_dadd"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_dadd_null_spec
                      // (do {apply_fp_rewrites; w4_unint_z3 fp_unints;});
                      (do {
                          unfolding ["point_dadd", "POINTonE1_abs", "POINTonE1_affine_abs"
                                    , "POINTonE1_invariant", "POINTonE1_affine_invariant"
                                    , "POINTonE1_rep"
                                    , "select"
                                    , "/\\", "Fp", "prime_field_bv", "prime_field_integer", "prime_field"
                                    , "F_is_zero"];
                          simplify (addsimps (concat [unrip_thm] structural_rewrites) fp_simpset);
                          w4_unint_z3 fp_unints;
                          });


let POINTonE1_dadd_nonnull_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  (p2, p2_ptr) <- ptr_to_fresh_readonly "p2" POINTonE1_type;
  (a4, a4_ptr) <- ptr_to_fresh_readonly "a4" vec384_type;
  crucible_precond {{ POINTonE1_invariant p1 /\ POINTonE1_invariant p2 /\ fp_invariant a4 }};
  crucible_execute_func [out_ptr, p1_ptr, p2_ptr, a4_ptr];
  if use_abs_method
  then do {
    out <- crucible_fresh_var "new_POINTonE1_dadd_out" POINTonE1_type;
    crucible_points_to out_ptr (crucible_term out);
    crucible_postcond {{ POINTonE1_invariant out }};
    crucible_postcond {{ POINTonE1_abs out == point_dadd Fp (POINTonE1_abs p1) (POINTonE1_abs p2) (fp_abs a4) False}};
    }
  else
    crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep (point_dadd Fp (POINTonE1_abs p1) (POINTonE1_abs p2) (fp_abs a4) False) }});
};


POINTonE1_dadd_nonnull_ov <- custom_verify "POINTonE1_dadd"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_dadd_nonnull_spec
                      // (do {apply_fp_rewrites; w4_unint_z3 fp_unints;});
                      (do {
                          unfolding ["point_dadd", "POINTonE1_abs", "POINTonE1_affine_abs"
                                    , "POINTonE1_invariant", "POINTonE1_affine_invariant"
                                    , "POINTonE1_rep"
                                    , "select"
                                    , "/\\", "Fp", "prime_field_bv", "prime_field_integer", "prime_field"
                                    , "F_is_zero"];
                          simplify (addsimps (concat [unrip_thm] structural_rewrites) fp_simpset);
                          w4_unint_z3 fp_unints;
                          });


// ... POINTonE1_dadd_affine

let POINTonE1_dadd_affine_spec = do {
  out_ptr <- crucible_alloc POINTonE1_type;
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  (p2, p2_ptr) <- ptr_to_fresh_readonly "p2" POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_invariant p1 /\ POINTonE1_affine_invariant p2 }};
  crucible_execute_func [out_ptr, p1_ptr, p2_ptr];
  if use_abs_method
  then do {
    out <- crucible_fresh_var "new_POINTonE1_dadd_out" POINTonE1_type;
    crucible_points_to out_ptr (crucible_term out);
    crucible_postcond {{ POINTonE1_invariant out }};
    crucible_postcond {{ POINTonE1_abs out == point_dadd_affine Fp (POINTonE1_abs p1) (POINTonE1_affine_abs p2) }};
    }
  else
     // crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep (point_dadd Fp (POINTonE1_abs p1) (projectify E (POINTonE1_affine_abs p2)) Fp.field_zero True) }});
     crucible_points_to out_ptr (crucible_term {{ POINTonE1_rep (point_dadd_affine Fp (POINTonE1_abs p1) (POINTonE1_affine_abs p2)) }});
};

POINTonE1_dadd_affine_ov <- custom_verify "POINTonE1_dadd_affine"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_dadd_affine_spec
                      (do {
                          unfolding ["point_dadd_affine", "POINTonE1_abs", "POINTonE1_affine_abs"
                                    , "POINTonE1_invariant", "POINTonE1_affine_invariant"
                                    , "POINTonE1_rep"
                                    , "select"
                                    , "/\\"
                                    , "F_is_zero", "Fp.is_equal"];
                          simplify (addsimps (concat (concat [unrip_thm, one_mont_p_rep_thm, one_mont_p_invariant_thm]
                                                             fp_alg_thms)
                                                     structural_rewrites)
                                             fp_simpset);
                          w4_unint_z3 fp_unints;
                          });

// ... POINTonE1_is_equal

let POINTonE1_is_equal_spec = do {
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  (p2, p2_ptr) <- ptr_to_fresh_readonly "p2" POINTonE1_type;
  crucible_precond {{ POINTonE1_invariant p1 /\ POINTonE1_invariant p2 }};
  crucible_execute_func [p1_ptr, p2_ptr];
  crucible_return (crucible_term
   {{ bool_to_limb ((same_point E (POINTonE1_abs p1) (POINTonE1_abs p2))
                    /\ ((Fp.field_zero ==  fp_abs p1.2) ^ (Fp.field_zero == fp_abs p2.2) ^ True))
    }} );
};

POINTonE1_is_equal_ov <- custom_verify "POINTonE1_is_equal"
     (concat vec_overrides fp_overrides)
     POINTonE1_is_equal_spec
     do {unfolding ["bool_to_limb", "same_point" 
                   , "POINTonE1_abs", "POINTonE1_invariant"
                   , "E", "cubed", "/\\"
                   ];
         simplify (addsimps (concat (concat [unrip_thm] fp_alg_thms) structural_rewrites) fp_simpset);
         w4_unint_z3 fp_unints;
         };



////////////////////////////////////////////////////////////////
/// Other functions from ec1.c
///

//  POINTonE1_affine_on_curve
normalize_b_thm <- prove_cryptol {{ Fp.normalize b == b }} [];

POINTonE1_affine_on_curve_eqv_thm <- custom_prove_cryptol
   {{ \p -> is_point_affine E p == (Fp.is_val p.0 /\ Fp.is_val p.1 /\ POINTonE1_affine_on_curve p) }}
   z3;

let POINTonE1_affine_on_curve_spec = do {
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_affine_type;
  crucible_precond {{ POINTonE1_affine_invariant p1 }};
  crucible_execute_func [p1_ptr];
  crucible_return (crucible_term {{ if is_point_affine E (POINTonE1_affine_abs p1) then (1:Limb) else 0 }});
};

//let {{
//  B_E1 = [ 0xaa270000000cfff3, 0x53cc0032fc34000a, 0x478fe97a6b0a807f
//         , 0xb1d37ebee6ba24d7, 0x8ec9733bbf78ab2f, 0x09d645513d83de7e ]
//  }};
B_E1_invariant_thm <-
  prove_cryptol (rewrite (cryptol_ss ())
    {{fp_invariant [ 0xaa270000000cfff3, 0x53cc0032fc34000a, 0x478fe97a6b0a807f
                   , 0xb1d37ebee6ba24d7, 0x8ec9733bbf78ab2f, 0x09d645513d83de7e ]
       == True}}) [];

B_E1_abs_thm <-
  prove_cryptol (rewrite (cryptol_ss ())
    {{fp_abs       [ 0xaa270000000cfff3, 0x53cc0032fc34000a, 0x478fe97a6b0a807f
                   , 0xb1d37ebee6ba24d7, 0x8ec9733bbf78ab2f, 0x09d645513d83de7e ]
       == b }}) [];

POINTonE1_affine_on_curve_ov <- custom_verify "POINTonE1_affine_on_curve"
                      (concat vec_overrides fp_overrides)
                      POINTonE1_affine_on_curve_spec
                      (do {
                          // replace the post as written with the implementation-specific post
                          simplify (addsimp POINTonE1_affine_on_curve_eqv_thm basic_ss);
                          unfolding ["is_point_affine", "POINTonE1_affine_abs"
                                    , "POINTonE1_affine_invariant"
                                    , "POINTonE1_affine_on_curve"
                                    , "/\\", "\\/"
                                    , "E", "is_point_O", "same_point_affine", "point_O"
                                    , "cubed", "select", "Fp.is_equal", "F_is_zero"
                                    ];
                          simplify (addsimps structural_rewrites
                            (addsimps [unrip_thm, seq_ite_thm
                             , B_E1_abs_thm, B_E1_invariant_thm
                             , invariant_ite_thm, abs_ite_thm] fp_simpset));
                          w4_unint_z3 fp_unints;
                          });

// ... POINTonE1_on_curve

//     calls the assembly function `mul_by_b_onE1`, so we assume a spec

let mul_by_b_onE1_alias_1_2_spec = 
  unop_alias_1_2_spec "mul_by_b_onE1" vec384_type {{ fp_invariant }} {{fp_rep}} {{fp_abs}}
                                        {{ \x -> Fp.mul (b, x) }};
 mul_by_b_onE1_alias_1_2_ov <-
   admit "mul_by_b_onE1" []  mul_by_b_onE1_alias_1_2_spec;


let {{
   POINTonE1_on_curve: ProjectivePoint t_Fp -> Bool
   POINTonE1_on_curve (x,y,z) = (Fp.sq y == xxx \/ z == Fp.field_zero) where
      xxx = Fp.add (Fp.mul (Fp.sq x, x), Fp.mul (b, z6))
      z6 = Fp.sq (Fp.mul (Fp.sq z, z))
   }};


let POINTonE1_on_curve_spec = do {
  (p1, p1_ptr) <- ptr_to_fresh_readonly "p1" POINTonE1_type;
  crucible_precond {{ POINTonE1_invariant p1 }};
  crucible_execute_func [p1_ptr];
  crucible_return (crucible_term {{ if POINTonE1_on_curve (POINTonE1_abs p1) then (1:Limb) else 0 }});
};

// TODO:
// Note that `is_point_projective` does not have the check for point_O

//POINTonE1_on_curve_eqv_thm <- custom_prove_cryptol
//   {{ \p -> is_point_projective E p == (Fp.is_val p.0 /\ Fp.is_val p.1 /\ Fp.is_val p.2 /\ 
//                                       POINTonE1_projective_on_curve p) }}
//   z3;

POINTonE1_on_curve_ov <- custom_verify "POINTonE1_on_curve"
                      (concat [mul_by_b_onE1_alias_1_2_ov] (concat vec_overrides fp_overrides))
                      POINTonE1_on_curve_spec
                      (do {
                          // replace the post as written with the implementation-specific post
                          // simplify (addsimp POINTonE1_on_curve_eqv_thm basic_ss);
                          unfolding ["is_point_projective", "POINTonE1_abs"
                                    , "POINTonE1_invariant", "POINTonE1_on_curve"
                                    , "/\\", "\\/"
                                    , "E", "is_point_O", "same_point", "point_O"
                                    , "cubed", "select", "Fp.is_equal", "F_is_zero"
                                    ];
                          simplify (addsimps structural_rewrites
                            (addsimps [unrip_thm, seq_ite_thm
                             , B_E1_abs_thm, B_E1_invariant_thm
                             , invariant_ite_thm, abs_ite_thm] fp_simpset));
                          w4_unint_z3 fp_unints;
                          });
