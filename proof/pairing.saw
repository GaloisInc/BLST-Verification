/*
 * Copyright (c) 2021 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

/* Specifications and proofs for pairing.c.  While the Cryptol
   specification (and the IETF specifications) work in curve E over
   Fp_12, since these functions are applied to images of points on E1
   and E2 many optimizations are possible.  These are described in the
   Cryptol sources for implementation::Pairing.
*/

import "../spec/implementation/Pairing.cry";

////////////////////////////////////////////////////////////////
//
// Specifications


// Only ever called with count=2, and aliased
let lshift_mod_384_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "x" vec384_type;
  n_ptr <- crucible_alloc_readonly vec384_type;
  crucible_precond {{ fp_invariant a}};
  crucible_points_to n_ptr p_representation;
  crucible_execute_func [a_ptr, a_ptr, crucible_term {{2:Size_t}} , n_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp_rep (lshift_fp (fp_abs a) 2) }});
  };

let lshift_fp2_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "x" vec384x_type;
  crucible_precond {{ fp2_invariant a}};
  crucible_execute_func [a_ptr, a_ptr, crucible_term {{2:Size_t}}];
  crucible_points_to a_ptr (crucible_term {{ fp2_rep (lshift_fp2 (fp2_abs a) 2) }});
  };


let line_by_Px2_spec = do {
    (line, line_ptr) <- ptr_to_fresh "line" vec384fp6_type;
    (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" POINTonE1_affine_type;
    crucible_precond {{ POINTonE1_affine_invariant Px2 }};
    crucible_precond {{ fp6_invariant line }};
    crucible_execute_func [line_ptr, Px2_ptr];
    crucible_points_to line_ptr (crucible_term
      {{ fp6_rep (line_by_Px2 (fp6_abs line) (POINTonE1_affine_abs Px2)) }});
};

let line_dbl_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  T_ptr <- crucible_alloc POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_dbl_Q" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term {{ POINTonE2_rep (point_double Fp_2 (POINTonE2_abs Q)) }});
  crucible_points_to line_ptr (crucible_term {{ fp6_rep (line_double_imp (POINTonE2_abs Q)) }});
};

let line_dbl_alias_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_dbl_T" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_execute_func [line_ptr, T_ptr, T_ptr];
  crucible_points_to T_ptr (crucible_term {{ POINTonE2_rep (point_double Fp_2 (POINTonE2_abs T)) }});
  crucible_points_to line_ptr (crucible_term {{ fp6_rep (line_double_imp (POINTonE2_abs T)) }});
};

let line_add_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_add_T" POINTonE2_type;
  (R, R_ptr) <- ptr_to_fresh_readonly "line_add_R" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_invariant R }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, R_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term
    {{ POINTonE2_rep (point_add_affine_alt Fp_2 (POINTonE2_abs R) (POINTonE2_affine_abs Q)) }});
  crucible_points_to line_ptr (crucible_term
    {{ fp6_rep (line_add_imp (POINTonE2_abs R) (POINTonE2_affine_abs Q)) }});
};

let line_add_alias_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_add_T" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, T_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term
    {{ POINTonE2_rep (point_add_affine_alt Fp_2 (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
  crucible_points_to line_ptr (crucible_term
    {{ fp6_rep (line_add_imp (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
};

let start_dbl_n_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" (llvm_array n POINTonE2_type);
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ all POINTonE2_invariant T }};
  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Px2_ptr, llvm_term {{ (`n:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (start_dbl_n_imp (map POINTonE2_abs T) (map POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (crucible_term {{ map (\ Q -> POINTonE2_rep (point_double Fp_2 (POINTonE2_abs Q))) T }});
  };

let add_n_dbl_n_1_spec k = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret_add_n_dbl_n" vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" POINTonE1_affine_type;
  crucible_precond {{ fp12_invariant ret }};
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_precond {{ POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Q_ptr, Px2_ptr, llvm_term {{ (1:Size_t) }}
                        , llvm_term {{ (`k:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (add_n_dbl_ret`{k} (fp12_abs ret) (POINTonE2_abs T) (POINTonE2_affine_abs Q) (POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (llvm_term
    {{ POINTonE2_rep (add_n_dbl`{k}  (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
  };

let {{
  add_n_dbl_n_ret: {n, k} (fin n, n >= 1, fin k) =>
     t_Fp_12 ->[n](ProjectivePoint t_Fp_2) -> [n](AffinePoint t_Fp_2) -> [n](AffinePoint t_Fp) -> t_Fp_12
  add_n_dbl_n_ret r Ts Qs Px2s = F_prod Fp_12 rets where
    rets = [add_n_dbl_ret`{k} r (Ts@0) (Qs@0) (Px2s@0)] #
           [add_n_dbl_ret`{k} Fp_12.field_unit T Q Px2 | T <- tail Ts | Q <- tail Qs | Px2 <- tail Px2s]
  }};
  
let add_n_dbl_n_spec n k = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret_add_n_dbl_n" vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" (llvm_array n POINTonE2_type);
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" (llvm_array n POINTonE2_affine_type);
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ fp12_invariant ret }};
  crucible_precond {{ all POINTonE2_invariant T }};
  crucible_precond {{ all POINTonE2_affine_invariant Q }};
  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Q_ptr, Px2_ptr, llvm_term {{ (`n:Size_t) }}
                        , llvm_term {{ (`k:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (add_n_dbl_n_ret`{n,k} (fp12_abs ret) (map POINTonE2_abs T)
                                       (map POINTonE2_affine_abs Q) (map POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (llvm_term
    {{ [ POINTonE2_rep (add_n_dbl`{k} (POINTonE2_abs Ti) (POINTonE2_affine_abs Qi)) | Ti <- T | Qi <- Q ] }});
  };

// The Miller loop `miller_loop_n` takes three arrays of `n` inputs each, and behaves a bit
// differently when n=1.  So here I have separated out that case into a separate spec.

// TODO: recast these in terms of `miller_loop_opt`.

let miller_loop_n_1_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (Q, Q_ptr) <- ptr_to_fresh "Q" POINTonE2_affine_type; // array in general
  (P, P_ptr) <- ptr_to_fresh_readonly "P" POINTonE1_affine_type; // array in general
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_precond {{ POINTonE1_affine_invariant P }};
  crucible_execute_func [ret_ptr, Q_ptr, P_ptr, llvm_term {{ (1:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (miller_loop_n_1_imp (POINTonE2_affine_abs Q) (POINTonE1_affine_abs P)) }});
  };

// In the general case, n >= 2, we get the product of several Miller loop results.
let miller_loop_n_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (Qs, Q_ptr) <- ptr_to_fresh "Q" (llvm_array n POINTonE2_affine_type);
  (Ps, P_ptr) <- ptr_to_fresh_readonly "P" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ all POINTonE2_affine_invariant Qs }};
  crucible_precond {{ all POINTonE1_affine_invariant Ps }};
  crucible_execute_func [ret_ptr, Q_ptr, P_ptr, llvm_term {{ (`n:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (F_prod Fp_12 [miller_loop_imp Q P | Q <- map POINTonE2_affine_abs Qs
                                                   | P <- map POINTonE1_affine_abs Ps ]) }});
  };


////////////////////////////////////////////////////////////////
//
// Proofs

// We prove the miller_loop_n function for just a few concrete values of `n`, as
// SW cannot do a fully generic proof.

let miller_loop_n_values_proved = [1,2,3];

// we only use this on E', over Fp_2.
point_add_affine_alt_equiv_thm <- prove_cryptol
   {{ \ P Q -> point_add_affine_alt Fp_2 P Q ==
                   if P.2 == Fp_2.field_zero
                   then apply point_add_affine_alt Fp_2 P Q
                   else point_add_affine Fp_2 P Q }} [] ;

// assembler routine
lshift_mod_384_alias_ov <- admit "lshift_mod_384" lshift_mod_384_alias_spec;

lshift_fp2_alias_ov <- verify "lshift_fp2" [lshift_mod_384_alias_ov] lshift_fp2_alias_spec;

// The doubling code in `line_dbl` differs from POINTonE2_double only in a replacement of
// `Z3 = 2*Z1*Y1` by `Z3 = (Y1+Z1)^2-Y1^2-Z1^2, so we can make a lemma for that.

line_dbl_alg_thm <- prove_cryptol
  {{ \ y z -> Fp_2.sub (Fp_2.sub (Fp_2.sq (Fp_2.add (y, z)), Fp_2.sq y), Fp_2.sq z)
                == Fp_2.mul (Fp_2.add (z, z), y) }} [];

lshift_by_2_thm <- prove_cryptol (rewrite (cryptol_ss()) {{ \ x -> lshift_fp2 x 2 == mul_by_4 Fp_2 x }}) [];

line_by_Px2_ov <- custom_verify "line_by_Px2" fp_overrides line_by_Px2_spec
  do { unfolding ["line_by_Px2", "fp6_rep", "fp6_abs", "fp2_rep", "fp2_abs"];
       simplify fp_simpset;
       z3; };

// line_by_Px2 just does multiplications in Fp_2
line_py_Px2_equiv_thm <- prove_cryptol
  {{ \ A P -> (
    line_by_Px2 A P == [l2', l1', l0] where
      [l2,l1,l0] = A
      (xP, yP) = P
      l2' = Fp_2.mul (l2, Fp_to_Fp_2 yP)
      l1' = Fp_2.mul (l1, Fp_to_Fp_2 xP) ) }} [];

// line_by_Px2 after line_dbl_imp gives the right answer
line_double_equiv_thm <- prove_cryptol
  {{ \T P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_double_imp T) Px2) == line_double_opt T P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   [];

line_add_equiv_thm <- custom_prove_cryptol
  {{ \T Q P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2) == line_add_opt T Q P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   do { unfolding ["line_add_opt", "line_add_imp", "mul_by_4", "mul_by_2"];
        rw_with_1 line_py_Px2_equiv_thm;
        rw_with (concat fp_alg_thms fp2_alg_thms);
        z3; };



let curve_unints =
    [ "POINTonE1_abs", "POINTonE1_rep", "POINTonE1_invariant", "POINTonE1_normalize"
    , "POINTonE1_affine_abs", "POINTonE1_affine_rep", "POINTonE1_affine_invariant"
    , "POINTonE2_abs", "POINTonE2_rep", "POINTonE2_invariant", "POINTonE2_normalize"
    , "POINTonE2_affine_abs", "POINTonE2_affine_rep", "POINTonE2_affine_invariant"
    ];

let foo_unints_small = (concat_all [ curve_unints, fp12_unints
                                   , ["line_by_Px2", "line_double_imp"]]);

let foo_unints = (concat_all [ curve_unints //, fp12_unints
                             , fp2_unints, fp_unints
                             , ["line_by_Px2", "line_double_imp", "Fp_12"
                               ]]);

fp2_rep_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_rep [0,0] == zero }}) [];

fp2_invariant_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_invariant [z,z] == True where z = [0,0,0,0,0,0]}}) [];

fp2_abs_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_abs [z,z] == zero  where z = [0,0,0,0,0,0]}}) [];


let start_dbl_n_ss = addsimps [ unrip_thm, fp2_unrip_thm, fp6_unrip_thm, fp2_rep_unrip_thm
                              , fp2_rep_zero_thm, fp2_invariant_zero_thm, fp2_abs_zero_thm]
                           fp2_simpset;

line_dbl_line_ovs <- for [line_dbl_spec, line_dbl_alias_spec]
  (\ spec ->  custom_verify "line_dbl"
                      (foldr concat [vec_fp2_overrides, fp2_overrides, fp12_overrides]
                                    [vec_is_zero_fp2_ov, lshift_fp2_alias_ov])
                      spec
                      do {
                        unfolding [ "POINTonE2_rep", "POINTonE2_abs", "POINTonE2_affine_rep"
                                  , "POINTonE2_affine_abs", "point_double", "line_double_imp"
                                  , "fp6_rep", "fp6_abs"];
                        simplify simpset; // simpset is from curve_operations_e2.saw
                        rw_with_1 line_dbl_alg_thm;
                        w4_unint_z3 fp2_unints;
                      });


line_add_ovs <- for [line_add_spec, line_add_alias_spec]
  ( \ spec -> custom_verify "line_add"
                      fp2_overrides
                      spec
                      do {
                        unfolding [ "POINTonE2_rep","POINTonE2_abs","POINTonE2_affine_rep"
                                  , "POINTonE2_affine_abs","point_add_affine", "select"];
                        simplify simpset;
                        w4_unint_z3 fp2_unints;
                        });

// start_dbl_n

fp12_unrip_thms <- for
  [ {{ \ (x:Fp_12_rep_t) -> ([[x0,x1,x2],[x3,x4,x5]] == x where [[x0,x1,x2],[x3,x4,x5]] = x) }}
  , {{ \ (x:Fp_12_rep_t) -> ([x0,x1] == x where [x0,x1] = x) }}
  , {{ \ (x: t_Fp_12) -> ([x0,x1] == x where [x0,x1] = x) }}
  , {{ \ (x: Fp_6_rep_t) -> ([x0,x1,x2] == x where  [x0,x1,x2] = x) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []) ;

e2_unrip_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:POINTonE2_t) -> ((x0,x1,x2) == x where (x0,x1,x2) = x) }})
  [];

fp6_extra_abs_rep_thms <- for
  [ {{ \ x y -> fp6_abs (fp6_rep (line_by_Px2 x y)) == line_by_Px2 x y }}
  , {{ \ x y -> fp6_abs (fp6_rep (line_add_imp x y)) == line_add_imp x y }}
  , {{ \ x   -> fp6_abs (fp6_rep (line_double_imp x)) == line_double_imp x }}
  ] (\ t -> custom_prove_cryptol t
            do { unfolding ["fp6_abs", "fp6_rep", "fp2_abs", "fp2_rep"];
                 simplify fp_simpset;
                 w4_unint_z3 fp_unints; });


let add_n_dbl_n_ss = addsimps (concat_all[ fp12_rep_thms, POINTonE2_thms, fp12_unrip_thms
                                         , fp6_extra_abs_rep_thms
                                         , [ e2_unrip_thm
                                           , fp12_abs_ite_thm, fp12_invariant_ite_thm
                                           , fp12_rep_ite_thm]])
                              start_dbl_n_ss;
let {{
  start_dbl_1: (t_Fp_2, t_Fp_2, t_Fp_2) -> (t_Fp, t_Fp) -> t_Fp_12
  start_dbl_1 T Px2 = ret where
    line_a = line_double_imp T
    line_b = line_by_Px2 line_a Px2
    ret = fp6_to_fp12_xy00z0 line_b
  }};

/*
for [2,3,4,5,6] (\ n -> 
 custom_prove_cryptol
  {{ \ Ts Ps -> start_dbl_n_imp`{n} Ts Ps == F_prod Fp_12 [start_dbl_1 T P | T <- Ts | P <- Ps] }}
  do { goal_eval_unint foo_unints;
       simplify add_n_dbl_n_ss; // TODO: forward reference in this file
       rw_with fp12_laws;
       // print_goal_nicely;
       w4_unint_z3 foo_unints;
       });
*/

// Fails for n=1!
start_dbl_n_equiv_thms <- for [2,3] (\ n ->  
 custom_prove_cryptol
  {{ \ Ts Ps -> start_dbl_n_imp`{n} Ts Ps == F_prod Fp_12 [start_dbl_1 T P | T <- Ts | P <- Ps] }}
  do { goal_eval_unint foo_unints;
       simplify add_n_dbl_n_ss; // TODO: forward reference in this file
       rw_with fp12_laws;
       w4_unint_z3 foo_unints;
       });

start_dbl_n_1_equiv_thm <- custom_prove_cryptol
  {{ \ T P -> start_dbl_n_imp [T] [P] == start_dbl_1 T P }}
  do { goal_eval_unint foo_unints;
       simplify add_n_dbl_n_ss; // TODO: forward reference in this file
       rw_with fp12_laws;
       w4_unint_z3 foo_unints;
       };

/*
// TODO: drop these first two overrides, use the list instead.
start_dbl_n_1_ov <- custom_verify "start_dbl_n"
   (concat_all [[line_by_Px2_ov], line_dbl_line_ovs, mul_by_xy00z0_fp12_ovs])
   (start_dbl_n_spec 1)
   do { goal_eval_unint foo_unints;
        simplify start_dbl_n_ss;
        w4_unint_z3 foo_unints;
        };

start_dbl_n_2_ov <- custom_verify "start_dbl_n"
   (concat_all [[line_by_Px2_ov], line_dbl_line_ovs, mul_by_xy00z0_fp12_ovs])
   (start_dbl_n_spec 2)
   do { goal_eval_unint foo_unints;
        simplify start_dbl_n_ss;
        w4_unint_z3 foo_unints;
        };
*/

start_dbl_n_ovs <- for miller_loop_n_values_proved
 (\ n -> custom_verify "start_dbl_n"
   (concat_all [[line_by_Px2_ov], line_dbl_line_ovs, mul_by_xy00z0_fp12_ovs])
   (start_dbl_n_spec n)
   do { goal_eval_unint foo_unints;
        simplify start_dbl_n_ss;
        w4_unint_z3 foo_unints;
        });

// add_n_dbl_n

// Just as for the proofs of scalar multiplication, we need a non-higher-order cover function
// for point_add_affine_alt.

let {{ point_add_affine_alt_fp2 = point_add_affine_alt Fp_2 }};

point_add_affine_alt_fp2_thm <- prove_cryptol
  {{  \p1 p2 -> point_add_affine_alt Fp_2 p1 p2 == point_add_affine_alt_fp2 p1 p2 }} ["Fp_2"];

let remove_higher_order_function_simpset_alt =
    addsimp point_add_affine_alt_fp2_thm  remove_higher_order_function_simpset;

let add_n_dbl_n_unints = (concat_all [ curve_unints, fp12_unints
                                     , fp2_unints, fp_unints
                                     , [ "line_by_Px2", "line_double_imp", "line_add_imp", "xy00z0_expander"
                                       , "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                                       ] ] );

let add_n_dbl_n_unints' = concat ["fp6_invariant", "fp6_rep", "fp6_abs", "Fp_6"]
                                 add_n_dbl_n_unints;

/*
// For proof development, allow Fp_12 fields to be printed readably

let {{
  ff_zero_fp12 = Fp_12.field_zero
  ff_unit_fp12 = Fp_12.field_unit
  ff_mul_fp12 = Fp_12.mul
  ff_sq_fp12  = Fp_12.sq
  ff_add_fp12 = Fp_12.add
  ff_sub_fp12 = Fp_12.sub
  ff_neg_fp12 = Fp_12.neg
  ff_div_fp12 = Fp_12.div
  ff_normalize_fp12 = Fp_12.normalize
  ff_is_val_fp12 = Fp_12.is_val
}};

ff12_cover_thms <- for
 [ {{ Fp_12.field_zero == ff_zero_fp12 }}
 , {{ Fp_12.field_unit == ff_unit_fp12 }}
 , {{ \x -> Fp_12.mul x == ff_mul_fp12 x}}
 , {{ \x -> Fp_12.add x == ff_add_fp12 x }}
 , {{ \x -> Fp_12.sub x == ff_sub_fp12 x }}
 , {{ \x -> Fp_12.sq x == ff_sq_fp12 x }}
 , {{ \x -> Fp_12.neg x == ff_neg_fp12 x }}
 , {{ \x -> Fp_12.div x == ff_div_fp12 x }}
 , {{ \x -> Fp_12.is_val x == ff_is_val_fp12 x }}
 , {{ \x -> Fp_12.normalize x == ff_normalize_fp12 x }}
 ] ( \t -> prove_cryptol t ["Fp_12"] );

ff12_uncover_thms <- for
 [ {{ ff_zero_fp12 == Fp_12.field_zero }}
 , {{ ff_unit_fp12 == Fp_12.field_unit }}
 , {{ \x -> ff_mul_fp12 x == Fp_12.mul x }}
 , {{ \x -> ff_add_fp12 x == Fp_12.add x }}
 , {{ \x -> ff_sub_fp12 x == Fp_12.sub x }}
 , {{ \x -> ff_sq_fp12 x == Fp_12.sq x }}
 , {{ \x -> ff_neg_fp12 x == Fp_12.neg x }}
 , {{ \x -> ff_div_fp12 x == Fp_12.div x }}
 , {{ \x -> ff_normalize_fp12 x == Fp_12.normalize x }}
 , {{ \x -> ff_is_val_fp12 x == Fp_12.is_val x }}
 ] ( \t -> prove_cryptol t ["Fp_12"] );

let print_nicely = do {
    unfolding ["/\\", "\\/", "==>"];
    simplify (addsimps ff12_cover_thms (cryptol_ss ()));
    simplify prop_simpset;
    print_goal;
    simplify (addsimps ff12_uncover_thms (cryptol_ss ())); // put things back. ish
    };

let print_goal_nicely = do {
    unfolding ["/\\", "\\/", "==>"];
    expand_fp2;
    simplify (addsimps ffx_cover_thms (cryptol_ss ()));
    simplify (addsimps ffx2_cover_thms (cryptol_ss ()));
    simplify (addsimps ff12_cover_thms (cryptol_ss ()));
    simplify prop_simpset;
    print_goal;
    simplify (addsimps ff12_uncover_thms (cryptol_ss ()));
    simplify (addsimps ffx2_uncover_thms (cryptol_ss ()));
    simplify (addsimps ffx_uncover_thms (cryptol_ss ()));
    simplify (addsimps ff_uncover_thms (cryptol_ss ())); // put things back. ish
    };

*/

//

xy00z0_expander_thm <- prove_cryptol
  {{ \x -> fp12_abs (xy00z0_expander x) == fp6_to_fp12_xy00z0 (fp6_abs x) }} [] ;

/*
// WORKS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 1)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        goal_num_ite 8
          do { goal_eval_unint add_n_dbl_n_unints';
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; };

// FAILS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 1)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        print_nicely;
        goal_eval_unint add_n_dbl_n_unints';
        simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
        w4_unint_z3 add_n_dbl_n_unints; };


// EXPERIMENT
*/

fp6_extra_inv_rep_thms <- for
  [ {{ \ x y -> fp6_invariant (fp6_rep (line_by_Px2 x y)) == True }}
  , {{ \ x y -> fp6_invariant (fp6_rep (line_add_imp x y)) == True }}
  , {{ \ x   -> fp6_invariant (fp6_rep (line_double_imp x)) == True }}
  ] (\ t -> custom_prove_cryptol t
            do { unfolding ["fp6_invariant", "fp6_rep"];
                 simplify fp2_simpset;
                 w4_unint_z3 fp2_unints; });
/*

//WORKS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 1)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        goal_eval_unint add_n_dbl_n_unints';
        simplify (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss));
        print_goal_nicely;
        w4_unint_z3 add_n_dbl_n_unints'; };


// Actual k values used are:
//  2, 3, 9, 32, and 16

// WORKS k=2
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 2)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        print_nicely; // print_goal_consts;
        goal_num_ite 12
          do { goal_eval_unint add_n_dbl_n_unints';
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; };
*/

// WORKS: all the needed k! (for n=1).  Slow, ~11m on my hardware
add_dbl_n_ovs <- for [(2,12), (3,16), (9, 40), (16, 68), (32, 132)] // (k, 4k+4)
 (\ (k, goal_n) ->
  custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec k)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        goal_num_ite goal_n
          do { goal_eval_unint add_n_dbl_n_unints';
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; });

// Larger n

/*
// ... def alternative, breaking the add_n_dbl_ret into two parts

let {{
  add_n_dbl_ret': {k} (fin k) =>
      t_Fp_12 -> ProjectivePoint t_Fp_2 -> AffinePoint t_Fp_2 -> AffinePoint t_Fp -> t_Fp_12
  add_n_dbl_ret' r T Q Px2 = add_n_dbl_ret_k_loop`{k} ret_a T_a Px2 where
    (ret_a, T_a) = add_n_dbl_n_start r T Q Px2

  add_n_dbl_n_start: t_Fp_12 -> ProjectivePoint t_Fp_2 -> AffinePoint t_Fp_2 -> AffinePoint t_Fp
                     -> (t_Fp_12, ProjectivePoint t_Fp_2)
  add_n_dbl_n_start r T Q Px2 = (ret_a, T_a) where
    ret_a = Fp_12.mul (r, fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2))
    T_a = point_add_affine_alt Fp_2 T Q

  add_n_dbl_ret_k_loop: {k} (fin k) =>
      t_Fp_12 -> ProjectivePoint t_Fp_2 -> AffinePoint t_Fp -> t_Fp_12
  add_n_dbl_ret_k_loop ret_a T_a Px2 = rets@`k where
    // standard loop-to-comprehension transcription of the C code, for the loop on `k`
    Ts = [T_a] # [point_double Fp_2 Ti | Ti <- Ts]
    lines = [line_by_Px2 (line_double_imp Ti) Px2 | Ti <- Ts ]
    rets = [ret_a] # [Fp_12.mul (Fp_12.sq ret, fp6_to_fp12_xy00z0 line) | ret <- rets | line <- lines] 
  }};
  
custom_prove_cryptol
  {{ \ r T Q P -> add_n_dbl_ret'`{2} r T Q P == add_n_dbl_ret`{2} r T Q P }}
  (w4_unint_z3 foo_unints);

custom_prove_cryptol
  {{ \ r T Q P -> add_n_dbl_ret'`{16} r T Q P == add_n_dbl_ret`{16} r T Q P }}
  (w4_unint_z3 foo_unints);

custom_prove_cryptol
  {{ \ r T Q P -> add_n_dbl_ret'`{32} r T Q P == add_n_dbl_ret`{32} r T Q P }}
  (w4_unint_z3 foo_unints);

prove_cryptol
  {{ \ r T Q P -> add_n_dbl_ret'`{32} r T Q P == add_n_dbl_ret`{32} r T Q P }}
  foo_unints;

let {{
  add_n_dbl_n_ret_imp: {n, k} (fin n, n >= 1, fin k) =>
     t_Fp_12 ->[n](ProjectivePoint t_Fp_2) -> [n](AffinePoint t_Fp_2) -> [n](AffinePoint t_Fp) -> t_Fp_12
  add_n_dbl_n_ret_imp r Ts Qs Px2s =
    // first loop
    start_rets = [r] # [add_n_dbl_start r' T Q Px2 | r' <- start_rets | T <- Ts | Q <- Qs | Px2 <- Px2s]
    // second loop
    rets = [start_rets!0] #
           [add_n_dbl_ret'`{k} ( T Q Px2 | T <- tail Ts | Q <- tail Qs | Px2 <- tail Px2s]
  }};
*/

/* CHECK are these needed
size_2_expander_thms <- for
  [ {{ \ xs -> (all POINTonE2_invariant xs == (POINTonE2_invariant x0 /\ POINTonE2_invariant x1)
                where [x0,x1] = xs) }}
  , {{ \ xs -> (all POINTonE2_affine_invariant xs ==
                  (POINTonE2_affine_invariant x0 /\ POINTonE2_affine_invariant x1)
                where [x0,x1] = xs) }}
  , {{ \ xs -> (all POINTonE1_affine_invariant xs ==
                  (POINTonE1_affine_invariant x0 /\ POINTonE1_affine_invariant x1)
               where [x0,x1] = xs) }}
  , {{ \ xs -> (map POINTonE2_abs xs == [POINTonE2_abs x0, POINTonE2_abs x1] where [x0,x1] = xs) }}
  , {{ \ xs -> (map POINTonE2_affine_abs xs == [POINTonE2_affine_abs x0, POINTonE2_affine_abs x1] where [x0,x1] = xs) }}
  , {{ \ xs -> (map POINTonE1_affine_abs xs == [POINTonE1_affine_abs x0, POINTonE1_affine_abs x1] where [x0,x1] = xs) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);


let add_n_dbl_n_2_expander_term k =
 {{ \ r T0 T1 Q0 Q1 P0 P1 ->
       add_n_dbl_n_ret`{2,k} r [T0,T1] [Q0,Q1] [P0,P1] ==
       add_n_dbl_ret`{k} (add_n_dbl_ret`{k} r T0 Q0 P0) T1 Q1 P1 }};

add_n_dbl_n_2_expander_thms <- [1,2,3]
  ( \ k -> prove_cryptol (rewrite (cryptol_ss()) (add_n_dbl_n_2_expander_term k)) ["add_n_dbl_ret"]);
*/
/*
// WORKS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 1) // n=2 k=1
   do { rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        goal_num_ite 14
          do { // print_goal_consts;
               goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
               // lost control there, some point_add_affine_alt still getting expanded.
               unfolding ["point_add_affine_alt_fp2", "point_add_affine_alt"];
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               rw_with fp12_laws;
               //print_goal_nicely;
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; };

// To avoid opening up the point operations, cannot just leave them uninterpreted, as they are
// higher-order.  See saw-script issue #906.  So we need to unfold:
//  "add_n_dbl_ret", "add_n_dbl", add_n_dbl_n_ret

// WORKS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 2) // n=2 k=2
   do { rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        // print_goal_nicely;
        goal_num_ite 21
          do { // print_goal_consts;
               goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
               // lost control there, some point_add_affine_alt still getting expanded.
               // unfolding ["point_add_affine_alt_fp2", "point_add_affine_alt"];
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               rw_with fp12_laws;
               //print_goal_nicely;
               w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints); }
          do { goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints); // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               // w4_unint_z3 add_n_dbl_n_unints;
               w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints);
               }; };

// WORKS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 3) // n=2 k=3
   do { rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        // print_goal_nicely;
        goal_num_ite 28
          do { // print_goal_consts;
               goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
               // lost control there, some point_add_affine_alt still getting expanded.
               // unfolding ["point_add_affine_alt_fp2", "point_add_affine_alt"];
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               rw_with fp12_laws;
               //print_goal_nicely;
               w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints); }
          do { goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints); // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               // w4_unint_z3 add_n_dbl_n_unints;
               w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints);
               }; };

*/
/*
add_dbl_n_2_ovs <- for [(16,119)] // [(2,21), (3,28), (9, 70), (16, 112), (32, 224)] // (k, 7(k+1))
 (\ (k, goal_n) -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 k) // n=2
   do { rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        // 
        goal_num_ite goal_n
          do { // print_goal_consts;
               goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               rw_with fp12_laws;
               print_goal_nicely;
               w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints); }
          do { goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints); // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               // print_goal_nicely;
               w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints);
               }; });

// Approx. 4h 20m for this proof.  (13,98) takes about 1h 7m, k=10 or 11 in minutes.
add_dbl_n_2_ovs <- for [(14,105)] // [(16,119)] // [(2,21), (3,28), (9, 70), (16, 112), (32, 224)] // (k, 7(k+1))
 (\ (k, goal_n) -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 k) // n=2
   do { rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        //let junk1 = run (print "before goal_eval_unint");
        goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
        //let junk2 = run (print "before simplify");
        simplify (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss));
        let junk3 =run (print "before fp12 laws");
        // goal_num_when goal_n print_goal_nicely;
        goal_num_when goal_n print_goal_size;
        rw_with fp12_laws;
        let junk4 = run (print "before z3");
        goal_num_when goal_n print_goal_size;
        w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); });
*/

// Another idea: customize the fp12_laws to avoid exapanding sq.

/* works
add_dbl_n_2_ovs <- for [(32,238)] // [(16,119)] // [(2,21), (3,28), (9, 70), (16, 112), (32, 224)] // (k, 7(k+1))
 (\ (k, goal_n) -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 k) // n=2
   do { rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        //let junk1 = run (print "before goal_eval_unint");
        goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
        //let junk2 = run (print "before simplify");
        simplify (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss));
        //let junk3 =run (print "before fp12 laws");
        // goal_num_when goal_n print_goal_nicely;
        goal_num_when goal_n print_goal_size;
        rw_with fp12_ring_laws;
        //let junk4 = run (print "before z3");
        goal_num_when goal_n print_goal_size;
        w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); });
*/

// WORKS, but a long proof.  About 27 minutes on my hardware!
add_dbl_n_2_ovs <- for [2,3,9,16,32]
 (\ k -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 k) // n=2
   do { // rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms); // CHECK-may be needed
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
        simplify (addsimps fp12_ring_laws (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss)));
        w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); });

add_dbl_n_3_ovs <- for [2,3,9,16,32]
 (\ k -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 3 k) // n=2
   do { //let junk = run (print "... start proof script");
        // rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms);
        unfolding ["add_n_dbl_ret", "add_n_dbl", "add_n_dbl_n_ret"];
        //let junk1 = run (print "... after rw, unfold");
        simplify remove_higher_order_function_simpset_alt;
        goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
        //let junk2 = run (print "... after simplify, goal_eval_unint");
        simplify (addsimps fp12_ring_laws (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss)));
        w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); });


// miller_loop_n, for n=1

// for the optimization in `start_dbl_n`, avoiding squaring FP_12.field_unit and a multiplication by that.
small_algebra_fp12 <- for
  [ {{ Fp_12.sq Fp_12.field_unit == Fp_12.field_unit }}
  , {{ \ x y -> Fp_12.mul (Fp_12.field_unit, line_double_opt x y) == line_double_opt x y }}
  ] (\ t -> prove_cryptol t []);


e2_unrip_affine_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:POINTonE2_affine_t) -> ((x0,x1) == x where (x0,x1) = x) }})
  [];

e2_hoist_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ c (x1:t_Fp_2) x2 (y1:t_Fp_2) y2 (z1:t_Fp_2) z2  ->
                                 (if c then x1 else x2, if c then y1 else y2, if c then z1 else z2)
                                 == if c then (x1,y1,z1) else (x2,y2,z2) }})
  [];


seq_ite_thms <- for
  [ {{ \ x (y0:Integer) y1 z0 z1 -> [if x then y0 else z0, if x then y1 else z1] ==
           if x then [y0,y1] else [z0,z1] }}
  ,  {{ \ x (y0:[2]Integer) y1 y2 z0 z1 z2 ->
           [if x then y0 else z0, if x then y1 else z1, if x then y2 else z2] ==
           if x then [y0,y1,y2] else [z0,z1,z2] }}
  , {{ \ x (y0:[3][2]Integer) y1 z0 z1 -> [if x then y0 else z0, if x then y1 else z1] ==
           if x then [y0,y1] else [z0,z1] }}
  ] (\ t -> prove_cryptol t []);


miller_loop_n_1_equiv_thm <- custom_prove_cryptol
    {{ \ Q P -> miller_loop_n_1_imp Q P ==
                   (if Q == (z2,z2) \/ P == (z1,z1)
                    then Fp_12.field_unit
                    else miller_loop_opt P Q) where  z1 = Fp.field_zero; z2 = Fp_2.field_zero}}
  do { // open up the _imp, and simplify
       unfolding ["miller_loop_opt", "miller_step_opt", "miller_loop_n_1_imp", "add_n_dbl", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms
                               [ unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm
                               , e2_unrip_thm, e2_unrip_affine_thm, e2_hoist_thm]));
       rw_with (concat small_algebra_fp12 [line_add_equiv_thm, line_double_equiv_thm]);
       w4_unint_z3 [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       };



let ovs_for_miller_loop =
  concat_all [ add_dbl_n_ovs, start_dbl_n_ovs, fp_overrides, fp12_overrides, vec_overrides, vec_fp2_overrides
             , [vec_copy_fp12_ov]];

let miller_loop_n_unints =
  concat_all [ fp_unints, fp2_unints, fp12_unints
             , ["add_n_dbl", "add_n_dbl_ret", "start_dbl_n_imp", "point_double_fp2"
               , "fp12_conjugate"]]; // why is that not in fp12_unints?

/*
 For miller_loop_n:
 - need BLS12_381_Rx.p12 == fp12_rep Fp_12.field_unit
 - Know POINTonE1_invariant P, want fp_invariant on the coordinates (for the add_fp calls)
 - there are 3 vec_copy calls: an fp12_element (576 bytes), two coordinates on E' (192 bytes),
   and a third coordinate (96 bytes)
     576: vec_copy_fp12_ov; 192: vec_copy_POINTonE2_affine_ov; 96: vec_copy_POINTonE1_affine_ov?
 - 2 calls to vec_is_zero: 192 (fp2), 96 (fp)
*/

let {{
  one_mont_p = [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
              , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]

  bls12_381_rx = [one_mont_p, [0,0,0,0,0,0]]
  bls12_381_rx_p12 = [[bls12_381_rx,z2,z2], [z2,z2,z2]] where z2 = [z,z]; z = [0,0,0,0,0,0]
 }};

bls12_381_rx_thms <- for
  [ {{ fp2_invariant bls12_381_rx == True }}
  , {{ fp2_abs bls12_381_rx == Fp_2.field_unit }}
  , {{ fp12_rep Fp_12.field_unit == bls12_381_rx_p12 }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss())
                            (unfold_term ["one_mont_p", "bls12_381_rx", "bls12_381_rx_p12"] t)) []);

/*
// start_n_dbl has preconditions
//  crucible_precond {{ all POINTonE2_invariant T }};
//  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};

all_expansion_n_1_thms <- for
  [ {{ \ T -> all POINTonE2_invariant [T] == POINTonE2_invariant T }}
  , {{ \ P -> all POINTonE1_affine_invariant [P] == POINTonE1_affine_invariant P }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);

// BUT: For some reason all_expansion does not apply when we try to use it later.
*/

field_rewrites_for_miller_loop <- for
  [ {{ Fp.field_zero == 0 }}
  , {{ Fp_2.field_zero == [0,0] }}
  , {{ \ x y -> Fp.is_equal (x,y) == (x==y) }}
  , {{ \ x y -> Fp_2.is_equal (x,y) == (x==y) }}
  ] (\ t -> prove_cryptol t []);

miller_loop_n_1_ov <- custom_verify "miller_loop_n"
  (concat_all [ add_dbl_n_ovs, start_dbl_n_ovs, fp_overrides, fp12_overrides
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  miller_loop_n_1_spec
  do { simplify fp_simpset;
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       unfolding ["miller_loop_n_1_imp"]; //  to expose the contained "point_double", for the next step...
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       simplify fp12_simpset;
       rw_with (concat_all [bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop]);
       w4_unint_z3 miller_loop_n_unints;
       };

// for n > 2.  Here n=2.

let {{
  miller_loop_imp:  AffinePoint t_Fp_2 -> AffinePoint t_Fp -> t_Fp_12
  miller_loop_imp Q P = fp12_conjugate ret_f where
    z1 = Fp.field_zero
    z2 = Fp_2.field_zero
    (xP, yP) = P
    Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))
    (xQ, yQ) = Q
    T = (xQ, yQ, Fp_2.field_unit)
    ret_a = start_dbl_n_imp [T] [Px2]
    T_a = point_double Fp_2 T
    ret_b = add_n_dbl_ret`{2} ret_a T_a Q Px2
    T_b = add_n_dbl`{2} T_a Q
    ret_c = add_n_dbl_ret`{3} ret_b T_b Q Px2
    T_c = add_n_dbl`{3} T_b Q
    ret_d = add_n_dbl_ret`{9} ret_c T_c Q Px2
    T_d = add_n_dbl`{9} T_c Q
    ret_e = add_n_dbl_ret`{32} ret_d T_d Q Px2
    T_e = add_n_dbl`{32} T_d Q
    ret_f = add_n_dbl_ret`{16} ret_e T_e Q Px2
  }};

/* The plan:

The miller_loop_n implementation does not just multiply together the results of several miller_loop
evaluations, but instead interleaves the computations.  So the proof is mostly an exercise in
showing that the order of multiplications does not matter.

The single miller loop

We have shown that start_dbl_n Ts Ps returns  `start_dbl_n_inp Ts Ps`, then in theorems
start_dbl_n_equiv_thms andstart_dbl_n_1_equiv_thm shown
   `start_dbl_n_inp Ts Ps == product [start_dbl_n_1 T P | t <- Ts | P <- Ps ]

We have shown (for the specific values of `k` used in the miller loop), that calling
`add_n_dbl_n` Ts Qs Ps returns `add_n_dbl_n_ret Ts Ps Qs`, which is defined as 
  product [ZZZ T Q P | ...]

*/

miller_loop_imp_equiv_thm <- custom_prove_cryptol
    {{ \ Q P -> miller_loop_imp Q P == miller_loop_opt P Q }}
  do { // open up the _imp, and simplify
       unfolding ["miller_loop_opt", "miller_step_opt", "miller_loop_imp", "add_n_dbl", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms
                               [ unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm
                               , e2_unrip_thm, e2_unrip_affine_thm, e2_hoist_thm]));
       rw_with (concat small_algebra_fp12 [line_add_equiv_thm, line_double_equiv_thm]);
       w4_unint_z3 [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       };

fp12_conjugate_thms <- for
  [ {{ \ x y -> fp12_conjugate (Fp_12.mul (x,y)) == Fp_12.mul (fp12_conjugate x, fp12_conjugate y) }}
  , {{ fp12_conjugate Fp_12.field_unit == Fp_12.field_unit }}
  ] (\ t -> prove_cryptol t []);


// WORKS!
add_n_dbl_n_ret_n2_thms <- for [2,3,9,16,32] (\ k ->
  custom_prove_cryptol
    {{ \ r0 r1 T0 T1 Q0 Q1 P0 P1 ->
       add_n_dbl_n_ret`{2,k} (Fp_12.mul (r0,r1)) [T0,T1] [Q0,Q1] [P0,P1] ==
       Fp_12.mul (add_n_dbl_ret`{k} r0 T0 Q0 P0, add_n_dbl_ret`{k} r1 T1 Q1 P1) }}
  do { let unints =  concat_all [ fp_unints, fp2_unints, fp12_unints
                                , ["point_add_affine_alt_fp2", "point_double_fp2" , "fp12_conjugate"
                                 , "fp6_to_fp12_xy00z0", "line_by_Px2", "line_double_imp"]];
       unfolding ["add_n_dbl_n_ret", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint unints;
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       rw_with fp12_ring_laws;
       w4_unint_z3 unints; });

let miller_loop_n_2_unints =
  concat_all [ fp_unints, fp2_unints, fp12_unints
             , ["add_n_dbl", "add_n_dbl_ret", "add_n_dbl_n_ret", "start_dbl_n_imp", "start_dbl_1"
               , "point_double_fp2", "point_add_affine_alt_fp2"
               , "fp12_conjugate"]];


miller_loop_n_2_ov <- custom_verify "miller_loop_n"
  (concat_all [ add_dbl_n_2_ovs, start_dbl_n_ovs, fp_overrides, fp12_overrides
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  (miller_loop_n_spec 2)
  do { simplify fp_simpset;
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       unfolding ["miller_loop_imp"]; //  to expose the contained "point_double", for the next step...
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_2_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       // simplify fp12_simpset;
       rw_with (concat fp12_ring_laws fp12_conjugate_thms);
       rw_with (concat_all [ bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop
                           , add_n_dbl_n_ret_n2_thms]);
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       rw_with fp12_conjugate_thms; // Why do I need this again?
       // goal_num_when 13 print_goal_nicely;
       w4_unint_z3 miller_loop_n_2_unints;
       };

add_n_dbl_n_ret_n3_thms <- for [2,3,9,16,32] (\ k ->
  custom_prove_cryptol
    {{ \ r0 r1 r2 T0 T1 T2 Q0 Q1 Q2 P0 P1 P2 ->
       add_n_dbl_n_ret`{3,k} (Fp_12.mul (r0,Fp_12.mul (r1,r2))) [T0,T1,T2] [Q0,Q1,Q2] [P0,P1,P2] ==
       Fp_12.mul (add_n_dbl_ret`{k} r0 T0 Q0 P0,
                  Fp_12.mul (add_n_dbl_ret`{k} r1 T1 Q1 P1,
                             add_n_dbl_ret`{k} r2 T2 Q2 P2)) }}
  do { let unints =  concat_all [ fp_unints, fp2_unints, fp12_unints
                                , ["point_add_affine_alt_fp2", "point_double_fp2" , "fp12_conjugate"
                                 , "fp6_to_fp12_xy00z0", "line_by_Px2", "line_double_imp"]];
       unfolding ["add_n_dbl_n_ret", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint unints;
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       rw_with fp12_ring_laws;
       w4_unint_z3 unints; });


miller_loop_n_3_ov <- custom_verify "miller_loop_n"
  (concat_all [ add_dbl_n_3_ovs, fp_overrides, fp12_overrides, start_dbl_n_ovs
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  (miller_loop_n_spec 3)
  do { simplify fp_simpset;
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       unfolding ["miller_loop_imp"]; //  to expose the contained "point_double", for the next step...
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_2_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       // simplify fp12_simpset;
       rw_with (concat fp12_ring_laws fp12_conjugate_thms);
       rw_with (concat_all [ bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop
                           , add_n_dbl_n_ret_n3_thms]);
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       rw_with fp12_conjugate_thms; // Why do I need this again?
       // goal_num_when 13 print_goal_nicely;
       w4_unint_z3 miller_loop_n_2_unints;
       };
