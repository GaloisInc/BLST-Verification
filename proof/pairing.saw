/*
 * Copyright (c) 2021 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

/* Specifications and proofs for pairing.c.  While the Cryptol
   specification (and the IETF specifications) work in curve E over
   Fp_12, since these functions are applied to images of points on E1
   and E2 many optimizations are possible.  These are described in the
   Cryptol sources for implementation::Pairing.
*/

import "../spec/implementation/Pairing.cry";

////////////////////////////////////////////////////////////////
//
// Specifications


// Only ever called with count=2, and aliased
let lshift_mod_384_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "x" vec384_type;
  n_ptr <- crucible_alloc_readonly vec384_type;
  crucible_precond {{ fp_invariant a}};
  crucible_points_to n_ptr p_representation;
  crucible_execute_func [a_ptr, a_ptr, crucible_term {{2:Size_t}} , n_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp_rep (lshift_fp (fp_abs a) 2) }});
  };

let lshift_fp2_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "x" vec384x_type;
  crucible_precond {{ fp2_invariant a}};
  crucible_execute_func [a_ptr, a_ptr, crucible_term {{2:Size_t}}];
  crucible_points_to a_ptr (crucible_term {{ fp2_rep (lshift_fp2 (fp2_abs a) 2) }});
  };


let line_by_Px2_spec = do {
    (line, line_ptr) <- ptr_to_fresh "line" vec384fp6_type;
    (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" POINTonE1_affine_type;
    crucible_precond {{ POINTonE1_affine_invariant Px2 }};
    crucible_precond {{ fp6_invariant line }};
    crucible_execute_func [line_ptr, Px2_ptr];
    crucible_points_to line_ptr (crucible_term
      {{ fp6_rep (line_by_Px2 (fp6_abs line) (POINTonE1_affine_abs Px2)) }});
};

let line_dbl_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  T_ptr <- crucible_alloc POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_dbl_Q" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term {{ POINTonE2_rep (point_double Fp_2 (POINTonE2_abs Q)) }});
  crucible_points_to line_ptr (crucible_term {{ fp6_rep (line_double_imp (POINTonE2_abs Q)) }});
};

let line_dbl_alias_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_dbl_T" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_execute_func [line_ptr, T_ptr, T_ptr];
  crucible_points_to T_ptr (crucible_term {{ POINTonE2_rep (point_double Fp_2 (POINTonE2_abs T)) }});
  crucible_points_to line_ptr (crucible_term {{ fp6_rep (line_double_imp (POINTonE2_abs T)) }});
};

let line_add_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_add_T" POINTonE2_type;
  (R, R_ptr) <- ptr_to_fresh_readonly "line_add_R" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_invariant R }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, R_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term
    {{ POINTonE2_rep (point_add_affine_alt Fp_2 (POINTonE2_abs R) (POINTonE2_affine_abs Q)) }});
  crucible_points_to line_ptr (crucible_term
    {{ fp6_rep (line_add_imp (POINTonE2_abs R) (POINTonE2_affine_abs Q)) }});
};

let line_add_alias_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_add_T" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, T_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term
    {{ POINTonE2_rep (point_add_affine_alt Fp_2 (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
  crucible_points_to line_ptr (crucible_term
    {{ fp6_rep (line_add_imp (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
};

let start_dbl_n_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" (llvm_array n POINTonE2_type);
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ all POINTonE2_invariant T }};
  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Px2_ptr, llvm_term {{ (`n:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (start_dbl_n_imp (map POINTonE2_abs T) (map POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (crucible_term {{ map (\ Q -> POINTonE2_rep (point_double Fp_2 (POINTonE2_abs Q))) T }});
  };

let add_n_dbl_n_1_spec k = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret_add_n_dbl_n" vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" POINTonE1_affine_type;
  crucible_precond {{ fp12_invariant ret }};
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_precond {{ POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Q_ptr, Px2_ptr, llvm_term {{ (1:Size_t) }}
                        , llvm_term {{ (`k:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (add_n_dbl_ret`{k} (fp12_abs ret) (POINTonE2_abs T) (POINTonE2_affine_abs Q) (POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (llvm_term
    {{ POINTonE2_rep (add_n_dbl`{k}  (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
  };

let miller_loop_n_1_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (Q, Q_ptr) <- ptr_to_fresh "Q" POINTonE2_affine_type; // array in general
  (P, P_ptr) <- ptr_to_fresh_readonly "P" POINTonE1_affine_type; // array in general
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_precond {{ POINTonE1_affine_invariant P }};
  crucible_execute_func [ret_ptr, Q_ptr, P_ptr, llvm_term {{ (1:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (miller_loop_n_1_imp (POINTonE2_affine_abs Q) (POINTonE1_affine_abs P)) }});
  };


////////////////////////////////////////////////////////////////
//
// Proofs

// we only use this on E', over Fp_2.
point_add_affine_alt_equiv_thm <- prove_cryptol
   {{ \ P Q -> point_add_affine_alt Fp_2 P Q ==
                   if P.2 == Fp_2.field_zero
                   then apply point_add_affine_alt Fp_2 P Q
                   else point_add_affine Fp_2 P Q }} [] ;

// assembler routine
lshift_mod_384_alias_ov <- admit "lshift_mod_384" lshift_mod_384_alias_spec;

lshift_fp2_alias_ov <- verify "lshift_fp2" [lshift_mod_384_alias_ov] lshift_fp2_alias_spec;

// The doubling code in `line_dbl` differs from POINTonE2_double only in a replacement of
// `Z3 = 2*Z1*Y1` by `Z3 = (Y1+Z1)^2-Y1^2-Z1^2, so we can make a lemma for that.

line_dbl_alg_thm <- prove_cryptol
  {{ \ y z -> Fp_2.sub (Fp_2.sub (Fp_2.sq (Fp_2.add (y, z)), Fp_2.sq y), Fp_2.sq z)
                == Fp_2.mul (Fp_2.add (z, z), y) }} [];

lshift_by_2_thm <- prove_cryptol (rewrite (cryptol_ss()) {{ \ x -> lshift_fp2 x 2 == mul_by_4 Fp_2 x }}) [];

line_by_Px2_ov <- custom_verify "line_by_Px2" fp_overrides line_by_Px2_spec
  do { unfolding ["line_by_Px2", "fp6_rep", "fp6_abs", "fp2_rep", "fp2_abs"];
       simplify fp_simpset;
       z3; };

// line_by_Px2 just does multiplications in FP_2
line_py_Px2_equiv_thm <- prove_cryptol
  {{ \ A P -> (
    line_by_Px2 A P == [l2', l1', l0] where
      [l2,l1,l0] = A
      (xP, yP) = P
      l2' = Fp_2.mul (l2, Fp_to_Fp_2 yP)
      l1' = Fp_2.mul (l1, Fp_to_Fp_2 xP) ) }} [];

// line_by_Px2 after line_dbl_imp gives the right answer
line_double_equiv_thm <- prove_cryptol
  {{ \T P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_double_imp T) Px2) == line_double_opt T P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   [];

/* Using the fuller set of algebraic laws:
custom_prove_cryptol
  {{ \T Q P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2) == line_add_opt T Q P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   do { unfolding ["line_add_opt", "line_add_imp", "mul_by_4", "mul_by_2"];
        rw_with_1 line_py_Px2_equiv_thm;
        // rw_with (concat fp_laws fp2_laws);
        rw_with (concat_all [fp_laws, fp2_laws, fp_to_fp2_thms]);
        //print_goal_nicely;
        z3; };
// NOTE: did not rewrite to the same forms.  Because we do not cancel terms in sums.
*/

line_add_equiv_thm <- custom_prove_cryptol
  {{ \T Q P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2) == line_add_opt T Q P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   do { unfolding ["line_add_opt", "line_add_imp", "mul_by_4", "mul_by_2"];
        rw_with_1 line_py_Px2_equiv_thm;
        rw_with (concat fp_alg_thms fp2_alg_thms);
        z3; };


/// start_dbl_n

let curve_unints =
    [ "POINTonE1_abs", "POINTonE1_rep", "POINTonE1_invariant", "POINTonE1_normalize"
    , "POINTonE1_affine_abs", "POINTonE1_affine_rep", "POINTonE1_affine_invariant"
    , "POINTonE2_abs", "POINTonE2_rep", "POINTonE2_invariant", "POINTonE2_normalize"
    ];

let foo_unints_small = (concat_all [ curve_unints, fp12_unints
                                   , ["line_by_Px2", "line_double_imp"]]);

let foo_unints = (concat_all [ curve_unints //, fp12_unints
                             , fp2_unints, fp_unints
                             , ["line_by_Px2", "line_double_imp", "Fp_12"
                               ]]);

fp2_rep_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_rep [0,0] == zero }}) [];

fp2_invariant_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_invariant [z,z] == True where z = [0,0,0,0,0,0]}}) [];

fp2_abs_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_abs [z,z] == zero  where z = [0,0,0,0,0,0]}}) [];


let start_dbl_n_ss = addsimps [ unrip_thm, fp2_unrip_thm, fp6_unrip_thm, fp2_rep_unrip_thm
                              , fp2_rep_zero_thm, fp2_invariant_zero_thm, fp2_abs_zero_thm]
                           fp2_simpset;

line_dbl_line_ovs <- for [line_dbl_spec, line_dbl_alias_spec]
  (\ spec ->  custom_verify "line_dbl"
                      (foldr concat [vec_fp2_overrides, fp2_overrides, fp12_overrides]
                                    [vec_is_zero_fp2_ov, lshift_fp2_alias_ov])
                      spec
                      do {
                        unfolding [ "POINTonE2_rep", "POINTonE2_abs", "POINTonE2_affine_rep"
                                  , "POINTonE2_affine_abs", "point_double", "line_double_imp"
                                  , "fp6_rep", "fp6_abs"];
                        simplify simpset; // simpset is from curve_operations_e2.saw
                        rw_with_1 line_dbl_alg_thm;
                        w4_unint_z3 fp2_unints;
                      });


line_add_ovs <- for [line_add_spec, line_add_alias_spec]
  ( \ spec -> custom_verify "line_add"
                      fp2_overrides
                      spec
                      do {
                        unfolding [ "POINTonE2_rep","POINTonE2_abs","POINTonE2_affine_rep"
                                  , "POINTonE2_affine_abs","point_add_affine", "select"];
                        simplify simpset;
                        w4_unint_z3 fp2_unints;
                        });

// start_dbl_n

start_dbl_n_1_ov <- custom_verify "start_dbl_n"
   (concat_all [[line_by_Px2_ov], line_dbl_line_ovs, mul_by_xy00z0_fp12_ovs])
   (start_dbl_n_spec 1)
   do { goal_eval_unint foo_unints;
        simplify start_dbl_n_ss;
        w4_unint_z3 foo_unints;
        };

for [1,2,3,4,5]
 (\ n -> custom_verify "start_dbl_n"
   (concat_all [[line_by_Px2_ov], line_dbl_line_ovs, mul_by_xy00z0_fp12_ovs])
   (start_dbl_n_spec n)
   do { goal_eval_unint foo_unints;
        simplify start_dbl_n_ss;
        w4_unint_z3 foo_unints;
        });

// add_n_dbl_n
// focus just on the n=1 case for now.

// Just as for the proofs of scalar multiplication, we need a non-higher-order cover function
// for point_add_affine_alt.

let {{ point_add_affine_alt_fp2 = point_add_affine_alt Fp_2 }};

point_add_affine_alt_fp2_thm <- prove_cryptol
  {{  \p1 p2 -> point_add_affine_alt Fp_2 p1 p2 == point_add_affine_alt_fp2 p1 p2 }} ["Fp_2"];

let remove_higher_order_function_simpset_alt =
    addsimp point_add_affine_alt_fp2_thm  remove_higher_order_function_simpset;

let add_n_dbl_n_unints = (concat_all [ curve_unints, fp12_unints
                                     , fp2_unints, fp_unints
                                     , [ "line_by_Px2", "line_double_imp", "line_add_imp", "xy00z0_expander"
                                       , "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                                       // , "fp6_invariant", "fp6_rep", "fp6_abs", "Fp_6"
                                       ] ] );

let add_n_dbl_n_unints' = concat ["fp6_invariant", "fp6_rep", "fp6_abs", "Fp_6"]
                                 add_n_dbl_n_unints;

/*
fp12_unrip_rep_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:Fp_12_rep_t) -> ([[x0,x1,x2],[x3,x4,x5]] == x where [[x0,x1,x2],[x3,x4,x5]] = x) }})
  [];
*/

fp12_unrip_thms <- for
  [ {{ \ (x:Fp_12_rep_t) -> ([[x0,x1,x2],[x3,x4,x5]] == x where [[x0,x1,x2],[x3,x4,x5]] = x) }}
  , {{ \ (x:Fp_12_rep_t) -> ([x0,x1] == x where [x0,x1] = x) }}
  , {{ \ (x: t_Fp_12) -> ([x0,x1] == x where [x0,x1] = x) }}
  , {{ \ (x: Fp_6_rep_t) -> ([x0,x1,x2] == x where  [x0,x1,x2] = x) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []) ;

e2_unrip_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:POINTonE2_t) -> ((x0,x1,x2) == x where (x0,x1,x2) = x) }})
  [];

fp6_extra_abs_rep_thms <- for
  [ {{ \ x y -> fp6_abs (fp6_rep (line_by_Px2 x y)) == line_by_Px2 x y }}
  , {{ \ x y -> fp6_abs (fp6_rep (line_add_imp x y)) == line_add_imp x y }}
  , {{ \ x   -> fp6_abs (fp6_rep (line_double_imp x)) == line_double_imp x }}
  ] (\ t -> custom_prove_cryptol t
            do { unfolding ["fp6_abs", "fp6_rep", "fp2_abs", "fp2_rep"];
                 simplify fp_simpset;
                 w4_unint_z3 fp_unints; });

let add_n_dbl_n_ss = addsimps (concat_all[ fp12_rep_thms, POINTonE2_thms, fp12_unrip_thms
                                         , fp6_extra_abs_rep_thms
                                         , [ e2_unrip_thm
                                           , fp12_abs_ite_thm, fp12_invariant_ite_thm
                                           , fp12_rep_ite_thm]])
                              start_dbl_n_ss;

/*
// For proof development, allow Fp_12 fields to be printed readably

let {{
  ff_zero_fp12 = Fp_12.field_zero
  ff_unit_fp12 = Fp_12.field_unit
  ff_mul_fp12 = Fp_12.mul
  ff_sq_fp12  = Fp_12.sq
  ff_add_fp12 = Fp_12.add
  ff_sub_fp12 = Fp_12.sub
  ff_neg_fp12 = Fp_12.neg
  ff_div_fp12 = Fp_12.div
  ff_normalize_fp12 = Fp_12.normalize
  ff_is_val_fp12 = Fp_12.is_val
}};

ff12_cover_thms <- for
 [ {{ Fp_12.field_zero == ff_zero_fp12 }}
 , {{ Fp_12.field_unit == ff_unit_fp12 }}
 , {{ \x -> Fp_12.mul x == ff_mul_fp12 x}}
 , {{ \x -> Fp_12.add x == ff_add_fp12 x }}
 , {{ \x -> Fp_12.sub x == ff_sub_fp12 x }}
 , {{ \x -> Fp_12.sq x == ff_sq_fp12 x }}
 , {{ \x -> Fp_12.neg x == ff_neg_fp12 x }}
 , {{ \x -> Fp_12.div x == ff_div_fp12 x }}
 , {{ \x -> Fp_12.is_val x == ff_is_val_fp12 x }}
 , {{ \x -> Fp_12.normalize x == ff_normalize_fp12 x }}
 ] ( \t -> prove_cryptol t ["Fp_12"] );

ff12_uncover_thms <- for
 [ {{ ff_zero_fp12 == Fp_12.field_zero }}
 , {{ ff_unit_fp12 == Fp_12.field_unit }}
 , {{ \x -> ff_mul_fp12 x == Fp_12.mul x }}
 , {{ \x -> ff_add_fp12 x == Fp_12.add x }}
 , {{ \x -> ff_sub_fp12 x == Fp_12.sub x }}
 , {{ \x -> ff_sq_fp12 x == Fp_12.sq x }}
 , {{ \x -> ff_neg_fp12 x == Fp_12.neg x }}
 , {{ \x -> ff_div_fp12 x == Fp_12.div x }}
 , {{ \x -> ff_normalize_fp12 x == Fp_12.normalize x }}
 , {{ \x -> ff_is_val_fp12 x == Fp_12.is_val x }}
 ] ( \t -> prove_cryptol t ["Fp_12"] );

/*
let print_nicely = do {
    unfolding ["/\\", "\\/", "==>"];
    simplify (addsimps ff12_cover_thms (cryptol_ss ()));
    simplify prop_simpset;
    print_goal;
    simplify (addsimps ff12_uncover_thms (cryptol_ss ())); // put things back. ish
    };
*/

let print_goal_nicely = do {
    unfolding ["/\\", "\\/", "==>"];
    expand_fp2;
    simplify (addsimps ffx_cover_thms (cryptol_ss ()));
    simplify (addsimps ffx2_cover_thms (cryptol_ss ()));
    simplify (addsimps ff12_cover_thms (cryptol_ss ()));
    simplify prop_simpset;
    print_goal;
    simplify (addsimps ff12_uncover_thms (cryptol_ss ()));
    simplify (addsimps ffx2_uncover_thms (cryptol_ss ()));
    simplify (addsimps ffx_uncover_thms (cryptol_ss ()));
    simplify (addsimps ff_uncover_thms (cryptol_ss ())); // put things back. ish
    };

*/

//

xy00z0_expander_thm <- prove_cryptol
  {{ \x -> fp12_abs (xy00z0_expander x) == fp6_to_fp12_xy00z0 (fp6_abs x) }} [] ;

/*
// WORKS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 1)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        print_nicely;
        goal_num_ite 8
          do { goal_eval_unint add_n_dbl_n_unints';
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; };

// FAILS
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 1)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        print_nicely;
        goal_eval_unint add_n_dbl_n_unints';
        simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
        w4_unint_z3 add_n_dbl_n_unints; };


// Actual k values used are:
//  2, 3, 9, 32, and 16

// WORKS k=2
custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec 2)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        print_nicely; // print_goal_consts;
        goal_num_ite 12
          do { goal_eval_unint add_n_dbl_n_unints';
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; };
*/

// WORKS: all the needed k!
add_dbl_n_ovs <- for [(2,12), (3,16), (9, 40), (16, 68), (32, 132)] // (k, 4k+4)
 (\ (k, goal_n) ->
  custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec k)
   do { unfolding ["add_n_dbl_ret", "add_n_dbl"];
        simplify remove_higher_order_function_simpset_alt;
        // print_goal_consts;
        goal_num_ite goal_n
          do { goal_eval_unint add_n_dbl_n_unints';
               simplify (addsimp xy00z0_expander_thm add_n_dbl_n_ss);
               w4_unint_z3 add_n_dbl_n_unints; }
          do { goal_eval_unint add_n_dbl_n_unints; // evaluate the comprehensions in the Cryptol spec
               simplify add_n_dbl_n_ss;
               w4_unint_z3 add_n_dbl_n_unints;
               }; });

// miller_loop_n, for n=1

// for the optimization in `start_dbl_n`, avoiding squaring FP_12.field_unit and a multiplication by that.
small_algebra_fp12 <- for
  [ {{ Fp_12.sq Fp_12.field_unit == Fp_12.field_unit }}
  , {{ \ x y -> Fp_12.mul (Fp_12.field_unit, line_double_opt x y) == line_double_opt x y }}
  ] (\ t -> prove_cryptol t []);


e2_unrip_affine_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:POINTonE2_affine_t) -> ((x0,x1) == x where (x0,x1) = x) }})
  [];

e2_hoist_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ c (x1:t_Fp_2) x2 (y1:t_Fp_2) y2 (z1:t_Fp_2) z2  ->
                                 (if c then x1 else x2, if c then y1 else y2, if c then z1 else z2)
                                 == if c then (x1,y1,z1) else (x2,y2,z2) }})
  [];


seq_ite_thms <- for
  [ {{ \ x (y0:Integer) y1 z0 z1 -> [if x then y0 else z0, if x then y1 else z1] ==
           if x then [y0,y1] else [z0,z1] }}
  ,  {{ \ x (y0:[2]Integer) y1 y2 z0 z1 z2 ->
           [if x then y0 else z0, if x then y1 else z1, if x then y2 else z2] ==
           if x then [y0,y1,y2] else [z0,z1,z2] }}
  , {{ \ x (y0:[3][2]Integer) y1 z0 z1 -> [if x then y0 else z0, if x then y1 else z1] ==
           if x then [y0,y1] else [z0,z1] }}
  ] (\ t -> prove_cryptol t []);


miller_loop_n_1_equiv_thm <- custom_prove_cryptol
    {{ \ Q P -> miller_loop_n_1_imp Q P ==
                   (if Q == (z2,z2) \/ P == (z1,z1)
                    then Fp_12.field_unit
                    else miller_loop_opt P Q) where  z1 = Fp.field_zero; z2 = Fp_2.field_zero}}
  do { // open up the _imp, and simplify
       unfolding ["miller_loop_opt", "miller_step_opt", "miller_loop_n_1_imp", "add_n_dbl", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms
                               [ unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm
                               , e2_unrip_thm, e2_unrip_affine_thm, e2_hoist_thm]));
       rw_with (concat small_algebra_fp12 [line_add_equiv_thm, line_double_equiv_thm]);
       // print_nicely;
       w4_unint_z3 [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       };



let ovs_for_miller_loop =
  concat_all [ add_dbl_n_ovs, fp_overrides, fp12_overrides, vec_overrides, vec_fp2_overrides
             , [start_dbl_n_1_ov, vec_copy_fp12_ov]];

let miller_loop_n_unints =
  concat_all [ fp_unints, fp2_unints, fp12_unints
             , ["add_n_dbl", "add_n_dbl_ret", "start_dbl_n_imp", "point_double_fp2"
               , "fp12_conjugate"]]; // why is that not in fp12_unints?

/*
 For miller_loop_n:
 - need BLS12_381_Rx.p12 == fp12_rep Fp_12.field_unit
 - Know POINTonE1_invariant P, want fp_invariant on the coordinates (for the add_fp calls)
 - there are 3 vec_copy calls: an fp12_element (576 bytes), two coordinates on E' (192 bytes),
   and a third coordinate (96 bytes)
     576: vec_copy_fp12_ov; 192: vec_copy_POINTonE2_affine_ov; 96: vec_copy_POINTonE1_affine_ov?
 - 2 calls to vec_is_zero: 192 (fp2), 96 (fp)
*/

let {{
  one_mont_p = [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
              , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]

  bls12_381_rx = [one_mont_p, [0,0,0,0,0,0]]
  bls12_381_rx_p12 = [[bls12_381_rx,z2,z2], [z2,z2,z2]] where z2 = [z,z]; z = [0,0,0,0,0,0]
 }};

bls12_381_rx_thms <- for
  [ {{ fp2_invariant bls12_381_rx == True }}
  , {{ fp2_abs bls12_381_rx == Fp_2.field_unit }}
  , {{ fp12_rep Fp_12.field_unit == bls12_381_rx_p12 }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss())
                            (unfold_term ["one_mont_p", "bls12_381_rx", "bls12_381_rx_p12"] t)) []);

/*
// start_n_dbl has preconditions
//  crucible_precond {{ all POINTonE2_invariant T }};
//  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};

all_expansion_n_1_thms <- for
  [ {{ \ T -> all POINTonE2_invariant [T] == POINTonE2_invariant T }}
  , {{ \ P -> all POINTonE1_affine_invariant [P] == POINTonE1_affine_invariant P }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);
// FAILS: all_expansion does not apply?
*/

field_rewrites_for_miller_loop <- for
  [ {{ Fp.field_zero == 0 }}
  , {{ Fp_2.field_zero == [0,0] }}
  , {{ \ x y -> Fp.is_equal (x,y) == (x==y) }}
  , {{ \ x y -> Fp_2.is_equal (x,y) == (x==y) }}
  ] (\ t -> prove_cryptol t []);

miller_loop_n_1_ov <- custom_verify "miller_loop_n"
  // ovs_for_miller_loop
  (concat_all [ add_dbl_n_ovs, fp_overrides, fp12_overrides //, vec_overrides, vec_fp2_overrides
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ start_dbl_n_1_ov, vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  miller_loop_n_1_spec
  do { simplify fp_simpset;
       // rw_with (concat all_expansion_n_1_thms POINTonE2_thms);
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       unfolding ["miller_loop_n_1_imp"]; //  to expose the contained "point_double", for the next step...
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       simplify fp12_simpset;
       rw_with (concat_all [bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop]);
       w4_unint_z3 miller_loop_n_unints;
       };
