/*
 * Copyright (c) 2021 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

/* Specifications and proofs for pairing.c.  While the Cryptol
   specification (and the IETF specifications) work in curve E over
   Fp_12, since these functions are applied to images of points on E1
   and E2 many optimizations are possible.  These are described in the
   Cryptol sources for implementation::Pairing.
*/

import "../spec/implementation/Pairing.cry";

/* Notes:

  1.  We show here that the `miller_loop_n` function computes what the specification
  `miller_loop_opt` describes.  This is not the same thing as what `ate_pairing'`
  computes; instead it is something that will give the same result after the final
  exponentiation step.  Callers will need to apply some assumption like

    (*) final_exponentiation_opt (miller_loop_opt P Q) == ate_pairing P Q

  which is justified by the informal notes in spec/implementation/Pairing.cry.
  (But the assumption  will not look exactly like that because the final exponentiation
  implementation is not applied directly to the result of the miller loop.)

  2.  The ate pairing should only be applied to points that are in the subgroups,
  that is, P should be in G1 and Q in G2.  Possibly this should be added as a
  precondition to the functions here, although it has not been needed for the code
  proofs. 

  3. Property (*) only holds when  Q is not the point at infinity.  This is
  checked by `miller_loop_n` when n==1 (which then returns the correct result for that
  case).  It is not checked for when n > 1, and indeed we can compute

    miller_loop_opt P::BP ([0,0],[0,0]) == Fp_12.field_zero

 */
  
////////////////////////////////////////////////////////////////
//
// Specifications


// Only ever called with count=2, and aliased
let lshift_mod_384_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "x" vec384_type;
  n_ptr <- crucible_alloc_readonly vec384_type;
  crucible_precond {{ fp_invariant a}};
  crucible_points_to n_ptr p_representation;
  crucible_execute_func [a_ptr, a_ptr, crucible_term {{2:Size_t}} , n_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp_rep (lshift_fp (fp_abs a) 2) }});
  };

let lshift_fp2_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "x" vec384x_type;
  crucible_precond {{ fp2_invariant a}};
  crucible_execute_func [a_ptr, a_ptr, crucible_term {{2:Size_t}}];
  crucible_points_to a_ptr (crucible_term {{ fp2_rep (lshift_fp2 (fp2_abs a) 2) }});
  };


let line_by_Px2_spec = do {
    (line, line_ptr) <- ptr_to_fresh "line" vec384fp6_type;
    (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" POINTonE1_affine_type;
    crucible_precond {{ POINTonE1_affine_invariant Px2 }};
    crucible_precond {{ fp6_invariant line }};
    crucible_execute_func [line_ptr, Px2_ptr];
    crucible_points_to line_ptr (crucible_term
      {{ fp6_rep (line_by_Px2 (fp6_abs line) (POINTonE1_affine_abs Px2)) }});
};

let line_dbl_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  T_ptr <- crucible_alloc POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_dbl_Q" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term {{ POINTonE2_rep (point_double Fp_2 (POINTonE2_abs Q)) }});
  crucible_points_to line_ptr (crucible_term {{ fp6_rep (line_double_imp (POINTonE2_abs Q)) }});
};

let line_dbl_alias_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_dbl_T" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_execute_func [line_ptr, T_ptr, T_ptr];
  crucible_points_to T_ptr (crucible_term {{ POINTonE2_rep (point_double Fp_2 (POINTonE2_abs T)) }});
  crucible_points_to line_ptr (crucible_term {{ fp6_rep (line_double_imp (POINTonE2_abs T)) }});
};

let line_add_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_add_T" POINTonE2_type;
  (R, R_ptr) <- ptr_to_fresh_readonly "line_add_R" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_invariant R }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, R_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term
    {{ POINTonE2_rep (point_add_affine_alt Fp_2 (POINTonE2_abs R) (POINTonE2_affine_abs Q)) }});
  crucible_points_to line_ptr (crucible_term
    {{ fp6_rep (line_add_imp (POINTonE2_abs R) (POINTonE2_affine_abs Q)) }});
};

let line_add_alias_spec = do {
  line_ptr <- crucible_alloc vec384fp6_type;
  (T, T_ptr) <- ptr_to_fresh "line_add_T" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_execute_func [line_ptr, T_ptr, T_ptr, Q_ptr];
  crucible_points_to T_ptr (crucible_term
    {{ POINTonE2_rep (point_add_affine_alt Fp_2 (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
  crucible_points_to line_ptr (crucible_term
    {{ fp6_rep (line_add_imp (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
};

let start_dbl_n_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" (llvm_array n POINTonE2_type);
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ all POINTonE2_invariant T }};
  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Px2_ptr, llvm_term {{ (`n:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (start_dbl_n_imp (map POINTonE2_abs T) (map POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (crucible_term {{ map (\ Q -> POINTonE2_rep (point_double Fp_2 (POINTonE2_abs Q))) T }});
  };

let add_n_dbl_n_1_spec k = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret_add_n_dbl_n" vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" POINTonE2_type;
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" POINTonE2_affine_type;
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" POINTonE1_affine_type;
  crucible_precond {{ fp12_invariant ret }};
  crucible_precond {{ POINTonE2_invariant T }};
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_precond {{ POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Q_ptr, Px2_ptr, llvm_term {{ (1:Size_t) }}
                        , llvm_term {{ (`k:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (add_n_dbl_ret`{k} (fp12_abs ret) (POINTonE2_abs T) (POINTonE2_affine_abs Q) (POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (llvm_term
    {{ POINTonE2_rep (add_n_dbl_alt`{k}  (POINTonE2_abs T) (POINTonE2_affine_abs Q)) }});
  };

let add_n_dbl_n_spec n k = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret_add_n_dbl_n" vec384fp12_type;
  (T, T_ptr) <- ptr_to_fresh "T" (llvm_array n POINTonE2_type);
  (Q, Q_ptr) <- ptr_to_fresh_readonly "line_add_Q" (llvm_array n POINTonE2_affine_type);
  (Px2, Px2_ptr) <- ptr_to_fresh_readonly "Px2" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ fp12_invariant ret }};
  crucible_precond {{ all POINTonE2_invariant T }};
  crucible_precond {{ all POINTonE2_affine_invariant Q }};
  crucible_precond {{ all POINTonE1_affine_invariant Px2 }};
  crucible_execute_func [ret_ptr, T_ptr, Q_ptr, Px2_ptr, llvm_term {{ (`n:Size_t) }}
                        , llvm_term {{ (`k:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (add_n_dbl_n_ret`{n,k} (fp12_abs ret) (map POINTonE2_abs T)
                                       (map POINTonE2_affine_abs Q) (map POINTonE1_affine_abs Px2)) }});
  crucible_points_to T_ptr (llvm_term
    {{ [ POINTonE2_rep (add_n_dbl_alt`{k} (POINTonE2_abs Ti) (POINTonE2_affine_abs Qi)) | Ti <- T | Qi <- Q ] }});
  };

// The Miller loop `miller_loop_n` takes three arrays of `n` inputs each, and behaves a bit
// differently when n=1.  So here I have separated out that case into a separate spec.

let miller_loop_n_1_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (Q, Q_ptr) <- ptr_to_fresh "Q" POINTonE2_affine_type; // array in general
  (P, P_ptr) <- ptr_to_fresh_readonly "P" POINTonE1_affine_type; // array in general
  crucible_precond {{ POINTonE2_affine_invariant Q }};
  crucible_precond {{ POINTonE1_affine_invariant P }};
  crucible_execute_func [ret_ptr, Q_ptr, P_ptr, llvm_term {{ (1:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (miller_loop_opt_checked (POINTonE1_affine_abs P) (POINTonE2_affine_abs Q)) }});
  };

// In the general case, n >= 2, we get the product of several Miller loop results.
let miller_loop_n_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (Qs, Q_ptr) <- ptr_to_fresh "Q" (llvm_array n POINTonE2_affine_type);
  (Ps, P_ptr) <- ptr_to_fresh_readonly "P" (llvm_array n POINTonE1_affine_type);
  crucible_precond {{ all POINTonE2_affine_invariant Qs }};
  crucible_precond {{ all POINTonE1_affine_invariant Ps }};
  crucible_execute_func [ret_ptr, Q_ptr, P_ptr, llvm_term {{ (`n:Size_t) }}];
  crucible_points_to ret_ptr (llvm_term
    {{ fp12_rep (F_prod Fp_12 [miller_loop_opt P Q | Q <- map POINTonE2_affine_abs Qs
                                                   | P <- map POINTonE1_affine_abs Ps ]) }});
  };


////////////////////////////////////////////////////////////////
//
// Proofs

// We prove the miller_loop_n function for just a few concrete values of `n`, as
// saw cannot do a fully generic proof.

let miller_loop_n_values_proved = [1,2,3];

// we only use this on E', over Fp_2.
point_add_affine_alt_equiv_thm <- prove_cryptol
   {{ \ P Q -> point_add_affine_alt Fp_2 P Q ==
                   if P.2 == Fp_2.field_zero
                   then apply point_add_affine_alt Fp_2 P Q
                   else point_add_affine Fp_2 P Q }} [] ;

// assembler routine
lshift_mod_384_alias_ov <- admit "lshift_mod_384" lshift_mod_384_alias_spec;

lshift_fp2_alias_ov <- verify "lshift_fp2" [lshift_mod_384_alias_ov] lshift_fp2_alias_spec;

// The doubling code in `line_dbl` differs from POINTonE2_double only in a replacement of
// `Z3 = 2*Z1*Y1` by `Z3 = (Y1+Z1)^2-Y1^2-Z1^2, so we can make a lemma for that.

line_dbl_alg_thm <- prove_cryptol
  {{ \ y z -> Fp_2.sub (Fp_2.sub (Fp_2.sq (Fp_2.add (y, z)), Fp_2.sq y), Fp_2.sq z)
                == Fp_2.mul (Fp_2.add (z, z), y) }} [];

lshift_by_2_thm <- prove_cryptol (rewrite (cryptol_ss()) {{ \ x -> lshift_fp2 x 2 == mul_by_4 Fp_2 x }}) [];

line_by_Px2_ov <- custom_verify "line_by_Px2" fp_overrides line_by_Px2_spec
  do { unfolding ["line_by_Px2", "fp6_rep", "fp6_abs", "fp2_rep", "fp2_abs"];
       simplify fp_simpset;
       z3; };

// line_by_Px2 just does multiplications in Fp_2
line_py_Px2_equiv_thm <- prove_cryptol
  {{ \ A P -> (
    line_by_Px2 A P == [l2', l1', l0] where
      [l2,l1,l0] = A
      (xP, yP) = P
      l2' = Fp_2.mul (l2, Fp_to_Fp_2 yP)
      l1' = Fp_2.mul (l1, Fp_to_Fp_2 xP) ) }} [];

// line_by_Px2 after line_dbl_imp gives the right answer
line_double_equiv_thm <- prove_cryptol
  {{ \T P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_double_imp T) Px2) == line_double_opt T P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   [];

line_add_equiv_thm <- custom_prove_cryptol
  {{ \T Q P -> (fp6_to_fp12_xy00z0 (line_by_Px2 (line_add_imp T Q) Px2) == line_add_opt T Q P
     where (xP, yP) = P
           Px2 = (Fp.neg (Fp.add (xP, xP)), Fp.add (yP, yP))) }}
   do { unfolding ["line_add_opt", "line_add_imp", "mul_by_4", "mul_by_2"];
        rw_with_1 line_py_Px2_equiv_thm;
        rw_with (concat fp_alg_thms fp2_alg_thms);
        z3; };

line_dbl_line_ovs <- for [line_dbl_spec, line_dbl_alias_spec]
  (\ spec ->  custom_verify "line_dbl"
                      (foldr concat [vec_fp2_overrides, fp2_overrides, fp12_overrides]
                                    [vec_is_zero_fp2_ov, lshift_fp2_alias_ov])
                      spec
                      do {
                        unfolding [ "POINTonE2_rep", "POINTonE2_abs", "POINTonE2_affine_rep"
                                  , "POINTonE2_affine_abs", "point_double", "line_double_imp"
                                  , "fp6_rep", "fp6_abs"];
                        simplify simpset; // simpset is from curve_operations_e2.saw
                        rw_with_1 line_dbl_alg_thm;
                        w4_unint_z3 fp2_unints;
                      });

line_add_ovs <- for [line_add_spec, line_add_alias_spec]
  ( \ spec -> custom_verify "line_add"
                      fp2_overrides
                      spec
                      do {
                        unfolding [ "POINTonE2_rep","POINTonE2_abs","POINTonE2_affine_rep"
                                  , "POINTonE2_affine_abs","point_add_affine", "select"];
                        simplify simpset;
                        w4_unint_z3 fp2_unints;
                        });

// start_dbl_n


let curve_unints =
    [ "POINTonE1_abs", "POINTonE1_rep", "POINTonE1_invariant", "POINTonE1_normalize"
    , "POINTonE1_affine_abs", "POINTonE1_affine_rep", "POINTonE1_affine_invariant"
    , "POINTonE2_abs", "POINTonE2_rep", "POINTonE2_invariant", "POINTonE2_normalize"
    , "POINTonE2_affine_abs", "POINTonE2_affine_rep", "POINTonE2_affine_invariant"
    ];

let start_dbl_n_unints_small = (concat_all [ curve_unints, fp12_unints
                                           , ["line_by_Px2", "line_double_imp"]]);

let start_dbl_n_unints = (concat_all [ curve_unints //, fp12_unints
                                     , fp2_unints, fp_unints
                                     , ["line_by_Px2", "line_double_imp", "Fp_12"]]);

fp2_rep_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_rep [0,0] == zero }}) [];

fp2_invariant_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_invariant [z,z] == True where z = [0,0,0,0,0,0]}}) [];

fp2_abs_zero_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ fp2_abs [z,z] == zero  where z = [0,0,0,0,0,0]}}) [];


let start_dbl_n_ss = addsimps [ unrip_thm, fp2_unrip_thm, fp6_unrip_thm, fp2_rep_unrip_thm
                              , fp2_rep_zero_thm, fp2_invariant_zero_thm, fp2_abs_zero_thm]
                           fp2_simpset;


fp12_unrip_thms <- for
  [ {{ \ (x:Fp_12_rep_t) -> ([[x0,x1,x2],[x3,x4,x5]] == x where [[x0,x1,x2],[x3,x4,x5]] = x) }}
  , {{ \ (x:Fp_12_rep_t) -> ([x0,x1] == x where [x0,x1] = x) }}
  , {{ \ (x: t_Fp_12) -> ([x0,x1] == x where [x0,x1] = x) }}
  , {{ \ (x: Fp_6_rep_t) -> ([x0,x1,x2] == x where  [x0,x1,x2] = x) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []) ;

e2_unrip_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:POINTonE2_t) -> ((x0,x1,x2) == x where (x0,x1,x2) = x) }})
  [];

fp6_extra_abs_rep_thms <- for
  [ {{ \ x y -> fp6_abs (fp6_rep (line_by_Px2 x y)) == line_by_Px2 x y }}
  , {{ \ x y -> fp6_abs (fp6_rep (line_add_imp x y)) == line_add_imp x y }}
  , {{ \ x   -> fp6_abs (fp6_rep (line_double_imp x)) == line_double_imp x }}
  ] (\ t -> custom_prove_cryptol t
            do { unfolding ["fp6_abs", "fp6_rep", "fp2_abs", "fp2_rep"];
                 simplify fp_simpset;
                 w4_unint_z3 fp_unints; });


let add_n_dbl_n_ss = addsimps (concat_all[ fp12_rep_thms, POINTonE2_thms, fp12_unrip_thms
                                         , fp6_extra_abs_rep_thms
                                         , [ e2_unrip_thm
                                           , fp12_abs_ite_thm, fp12_invariant_ite_thm
                                           , fp12_rep_ite_thm]])
                              start_dbl_n_ss;

// Fails for n=1!
start_dbl_n_equiv_thms <- for [2,3] (\ n ->  
 custom_prove_cryptol
  {{ \ Ts Ps -> start_dbl_n_imp`{n} Ts Ps == F_prod Fp_12 [start_dbl_1 T P | T <- Ts | P <- Ps] }}
  do { goal_eval_unint start_dbl_n_unints;
       simplify add_n_dbl_n_ss;
       rw_with fp12_laws;
       w4_unint_z3 start_dbl_n_unints;
       });

start_dbl_n_1_equiv_thm <- custom_prove_cryptol
  {{ \ T P -> start_dbl_n_imp [T] [P] == start_dbl_1 T P }}
  do { goal_eval_unint start_dbl_n_unints;
       simplify add_n_dbl_n_ss;
       rw_with fp12_laws;
       w4_unint_z3 start_dbl_n_unints;
       };

start_dbl_n_ovs <- for miller_loop_n_values_proved
 (\ n -> custom_verify "start_dbl_n"
   (concat_all [[line_by_Px2_ov], line_dbl_line_ovs, mul_by_xy00z0_fp12_ovs])
   (start_dbl_n_spec n)
   do { goal_eval_unint start_dbl_n_unints;
        simplify start_dbl_n_ss;
        w4_unint_z3 start_dbl_n_unints;
        });

// add_n_dbl_n

// Just as for the proofs of scalar multiplication, we need a non-higher-order cover function
// for point_add_affine_alt.

let {{ point_add_affine_alt_fp2 = point_add_affine_alt Fp_2 }};

point_add_affine_alt_fp2_thm <- prove_cryptol
  {{  \p1 p2 -> point_add_affine_alt Fp_2 p1 p2 == point_add_affine_alt_fp2 p1 p2 }} ["Fp_2"];

let remove_higher_order_function_simpset_alt =
    addsimp point_add_affine_alt_fp2_thm  remove_higher_order_function_simpset;

let add_n_dbl_n_unints = (concat_all [ curve_unints, fp12_unints
                                     , fp2_unints, fp_unints
                                     , [ "line_by_Px2", "line_double_imp", "line_add_imp", "xy00z0_expander"
                                       , "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                                       ] ] );

let add_n_dbl_n_unints' = concat ["fp6_invariant", "fp6_rep", "fp6_abs", "Fp_6"]
                                 add_n_dbl_n_unints;


//

xy00z0_expander_thm <- prove_cryptol
  {{ \x -> fp12_abs (xy00z0_expander x) == fp6_to_fp12_xy00z0 (fp6_abs x) }} [] ;



fp6_extra_inv_rep_thms <- for
  [ {{ \ x y -> fp6_invariant (fp6_rep (line_by_Px2 x y)) == True }}
  , {{ \ x y -> fp6_invariant (fp6_rep (line_add_imp x y)) == True }}
  , {{ \ x   -> fp6_invariant (fp6_rep (line_double_imp x)) == True }}
  ] (\ t -> custom_prove_cryptol t
            do { unfolding ["fp6_invariant", "fp6_rep"];
                 simplify fp2_simpset;
                 w4_unint_z3 fp2_unints; });

add_dbl_n_ovs <- for [(2,12), (3,16), (9, 40), (16, 68), (32, 132)] // (k, 4k+4)
 (\ (k, goal_n) -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_1_spec k) // n=2
   do { goal_num_ite goal_n
        do {
          unfolding ["add_n_dbl_ret", "add_n_dbl_alt", "add_n_dbl_n_ret"];
          simplify remove_higher_order_function_simpset_alt;
          goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
          simplify (addsimps fp12_ring_laws (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss)));
          w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); }
        do {
          simplify (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss));
          w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); };
        } );

// Larger n

// WORKS, but a long proof.  About 27 minutes on my hardware!
add_dbl_n_2_ovs <- for [2,3,9,16,32]
 (\ k -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 2 k) // n=2
   do { // rw_with (concat size_2_expander_thms add_n_dbl_n_2_expander_thms); // CHECK-may be needed
        unfolding ["add_n_dbl_ret", "add_n_dbl_alt", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
        simplify (addsimps fp12_ring_laws (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss)));
        w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); });

add_dbl_n_3_ovs <-for [2,3,9,16,32]
 (\ k -> custom_verify "add_n_dbl_n"
   (concat_all [[line_by_Px2_ov], line_add_ovs, line_dbl_line_ovs, fp12_overrides])
   (add_n_dbl_n_spec 3 k) // n=2
   do { unfolding ["add_n_dbl_ret", "add_n_dbl_alt", "add_n_dbl_n_ret"];
        simplify remove_higher_order_function_simpset_alt;
        goal_eval_unint (concat ["point_double_fp2"] add_n_dbl_n_unints');
        simplify (addsimps fp12_ring_laws (addsimps fp6_extra_inv_rep_thms (addsimp xy00z0_expander_thm add_n_dbl_n_ss)));
        w4_unint_z3 (concat ["point_double_fp2"] add_n_dbl_n_unints'); });


// miller_loop_n, for n=1

// for the optimization in `start_dbl_n`, avoiding squaring FP_12.field_unit and a multiplication by that.
small_algebra_fp12 <- for
  [ {{ Fp_12.sq Fp_12.field_unit == Fp_12.field_unit }}
  , {{ \ x y -> Fp_12.mul (Fp_12.field_unit, line_double_opt x y) == line_double_opt x y }}
  ] (\ t -> prove_cryptol t []);


e2_unrip_affine_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ (x:POINTonE2_affine_t) -> ((x0,x1) == x where (x0,x1) = x) }})
  [];

e2_hoist_thm <- prove_cryptol
  (rewrite (cryptol_ss ()) {{ \ c (x1:t_Fp_2) x2 (y1:t_Fp_2) y2 (z1:t_Fp_2) z2  ->
                                 (if c then x1 else x2, if c then y1 else y2, if c then z1 else z2)
                                 == if c then (x1,y1,z1) else (x2,y2,z2) }})
  [];


seq_ite_thms <- for
  [ {{ \ x (y0:Integer) y1 z0 z1 -> [if x then y0 else z0, if x then y1 else z1] ==
           if x then [y0,y1] else [z0,z1] }}
  ,  {{ \ x (y0:[2]Integer) y1 y2 z0 z1 z2 ->
           [if x then y0 else z0, if x then y1 else z1, if x then y2 else z2] ==
           if x then [y0,y1,y2] else [z0,z1,z2] }}
  , {{ \ x (y0:[3][2]Integer) y1 z0 z1 -> [if x then y0 else z0, if x then y1 else z1] ==
           if x then [y0,y1] else [z0,z1] }}
  ] (\ t -> prove_cryptol t []);


miller_loop_imp_equiv_thm <- custom_prove_cryptol
    {{ \ Q P -> miller_loop_opt Q P == miller_loop_imp P Q }}
  do { // open up the _imp, and simplify
       unfolding ["miller_loop_opt", "miller_step_opt", "miller_loop_imp", "add_n_dbl_alt", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms
                               [ unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm
                               , e2_unrip_thm, e2_unrip_affine_thm, e2_hoist_thm]));
       rw_with (concat small_algebra_fp12 [line_add_equiv_thm, line_double_equiv_thm]);
       w4_unint_z3 [ "point_add_affine_alt_fp2", "Fp_12", "fp6_to_fp12_xy00z0"
                       , "Fp_2", "Fp", "fp12_conjugate", "point_double_fp2", "line_add_imp"
                       , "line_double_imp", "line_by_Px2", "line_add_opt", "line_double_opt"
                       , "point_add_affine_fp2"];
       };


is_point_O_E_thm <- prove_cryptol {{ \ P -> is_point_O E P == (P == (Fp.field_zero, Fp.field_zero)) }} [];
is_point_O_E'_thm <- prove_cryptol {{ \ P -> is_point_O E' P == (P == (Fp_2.field_zero, Fp_2.field_zero)) }} [];

miller_loop_n_1_equiv_thm <- custom_prove_cryptol
    {{ \ Q P -> miller_loop_opt_checked P Q == miller_loop_n_1_imp Q P }}
  do { unfolding [ "miller_loop_n_1_imp", "miller_loop_opt_checked"];
       rw_with [miller_loop_imp_equiv_thm, is_point_O_E_thm, is_point_O_E'_thm];
       w4_unint_z3 ["miller_loop_opt", "Fp", "Fp_2"];
       };

let ovs_for_miller_loop =
  concat_all [ add_dbl_n_ovs, start_dbl_n_ovs, fp_overrides, fp12_overrides, vec_overrides, vec_fp2_overrides
             , [vec_copy_fp12_ov]];

let miller_loop_n_unints =
  concat_all [ fp_unints, fp2_unints, fp12_unints
             , ["add_n_dbl_alt", "add_n_dbl_ret", "start_dbl_n_imp", "point_double_fp2"
               , "fp12_conjugate"]]; // why is that not in fp12_unints?

/*
 For miller_loop_n:
 - need BLS12_381_Rx.p12 == fp12_rep Fp_12.field_unit
 - Know POINTonE1_invariant P, want fp_invariant on the coordinates (for the add_fp calls)
 - there are 3 vec_copy calls: an fp12_element (576 bytes), two coordinates on E' (192 bytes),
   and a third coordinate (96 bytes)
     576: vec_copy_fp12_ov; 192: vec_copy_POINTonE2_affine_ov; 96: vec_copy_POINTonE1_affine_ov?
 - 2 calls to vec_is_zero: 192 (fp2), 96 (fp)
*/

let {{
  one_mont_p = [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
              , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]

  bls12_381_rx = [one_mont_p, [0,0,0,0,0,0]]
  bls12_381_rx_p12 = [[bls12_381_rx,z2,z2], [z2,z2,z2]] where z2 = [z,z]; z = [0,0,0,0,0,0]
 }};

bls12_381_rx_thms <- for
  [ {{ fp2_invariant bls12_381_rx == True }}
  , {{ fp2_abs bls12_381_rx == Fp_2.field_unit }}
  , {{ fp12_rep Fp_12.field_unit == bls12_381_rx_p12 }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss())
                            (unfold_term ["one_mont_p", "bls12_381_rx", "bls12_381_rx_p12"] t)) []);

field_rewrites_for_miller_loop <- for
  [ {{ Fp.field_zero == 0 }}
  , {{ Fp_2.field_zero == [0,0] }}
  , {{ \ x y -> Fp.is_equal (x,y) == (x==y) }}
  , {{ \ x y -> Fp_2.is_equal (x,y) == (x==y) }}
  ] (\ t -> prove_cryptol t []);

miller_loop_n_1_ov <- custom_verify "miller_loop_n"
  (concat_all [ add_dbl_n_ovs, start_dbl_n_ovs, fp_overrides, fp12_overrides
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  miller_loop_n_1_spec
  do { rw_with_1 miller_loop_n_1_equiv_thm; // massage the postcondition
       simplify fp_simpset;
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       unfolding ["miller_loop_n_1_imp", "miller_loop_imp"];
       //  ... unfolding to expose the contained "point_double", for the next step
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       simplify (addsimps (concat_all [bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop])
                          fp12_simpset);
       rw_with fp12_ring_laws;
       w4_unint_z3 miller_loop_n_unints;
       };

// miller_loop_n for n > 2.


/*
The miller_loop_n implementation does not just multiply together the results of several miller_loop
evaluations, but instead interleaves the computations.  So the proof is mostly an exercise in
showing that the order of multiplications does not matter.
*/

fp12_conjugate_thms <- for
  [ {{ \ x y -> fp12_conjugate (Fp_12.mul (x,y)) == Fp_12.mul (fp12_conjugate x, fp12_conjugate y) }}
  , {{ fp12_conjugate Fp_12.field_unit == Fp_12.field_unit }}
  ] (\ t -> prove_cryptol t []);


// WORKS!
add_n_dbl_n_ret_n2_thms <- for [2,3,9,16,32] (\ k ->
  custom_prove_cryptol
    {{ \ r0 r1 T0 T1 Q0 Q1 P0 P1 ->
       add_n_dbl_n_ret`{2,k} (Fp_12.mul (r0,r1)) [T0,T1] [Q0,Q1] [P0,P1] ==
       Fp_12.mul (add_n_dbl_ret`{k} r0 T0 Q0 P0, add_n_dbl_ret`{k} r1 T1 Q1 P1) }}
  do { let unints =  concat_all [ fp_unints, fp2_unints, fp12_unints
                                , ["point_add_affine_alt_fp2", "point_double_fp2" , "fp12_conjugate"
                                 , "fp6_to_fp12_xy00z0", "line_by_Px2", "line_double_imp"]];
       unfolding ["add_n_dbl_n_ret", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint unints;
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       rw_with fp12_ring_laws;
       w4_unint_z3 unints; });

let miller_loop_n_2_unints =
  concat_all [ fp_unints, fp2_unints, fp12_unints
             , ["add_n_dbl_alt", "add_n_dbl_ret", "add_n_dbl_n_ret", "start_dbl_n_imp", "start_dbl_1"
               , "point_double_fp2", "point_add_affine_alt_fp2"
               , "fp12_conjugate"]];

miller_loop_n_2_ov <- custom_verify "miller_loop_n"
  (concat_all [ add_dbl_n_2_ovs, start_dbl_n_ovs, fp_overrides, fp12_overrides
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  (miller_loop_n_spec 2)
  do { rw_with_1 miller_loop_imp_equiv_thm; // replace `miller_loop_opt` by `miller_loop_imp` in the post.
       simplify fp_simpset;
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       unfolding ["miller_loop_imp"]; //  to expose the contained "point_double", for the next step...
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_2_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       // simplify fp12_simpset;
       rw_with (concat fp12_ring_laws fp12_conjugate_thms);
       rw_with (concat_all [ bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop
                           , add_n_dbl_n_ret_n2_thms]);
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       rw_with fp12_conjugate_thms; // Why do I need this again?
       w4_unint_z3 miller_loop_n_2_unints;
       };

add_n_dbl_n_ret_n3_thms <- for [2,3,9,16,32] (\ k ->
  custom_prove_cryptol
    {{ \ r0 r1 r2 T0 T1 T2 Q0 Q1 Q2 P0 P1 P2 ->
       add_n_dbl_n_ret`{3,k} (Fp_12.mul (r0,Fp_12.mul (r1,r2))) [T0,T1,T2] [Q0,Q1,Q2] [P0,P1,P2] ==
       Fp_12.mul (add_n_dbl_ret`{k} r0 T0 Q0 P0,
                  Fp_12.mul (add_n_dbl_ret`{k} r1 T1 Q1 P1,
                             add_n_dbl_ret`{k} r2 T2 Q2 P2)) }}
  do { let unints =  concat_all [ fp_unints, fp2_unints, fp12_unints
                                , ["point_add_affine_alt_fp2", "point_double_fp2" , "fp12_conjugate"
                                 , "fp6_to_fp12_xy00z0", "line_by_Px2", "line_double_imp"]];
       unfolding ["add_n_dbl_n_ret", "add_n_dbl_ret"];
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint unints;
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       rw_with fp12_ring_laws;
       w4_unint_z3 unints; });


miller_loop_n_3_ov <- custom_verify "miller_loop_n"
  (concat_all [ add_dbl_n_3_ovs, fp_overrides, fp12_overrides, start_dbl_n_ovs
              , [vec_is_zero_2fp_ov, vec_is_zero_2fp2_ov]
              , [ vec_copy_fp12_ov, vec_copy_POINTonE2_affine_ov
                , vec_copy_POINTonE1_affine_ov]])
  (miller_loop_n_spec 3)
  do { rw_with_1 miller_loop_imp_equiv_thm; // replace `miller_loop_opt` by `miller_loop_imp` in the post.
       simplify fp_simpset;
       rw_with POINTonE2_thms;
       unfolding ["POINTonE2_invariant", "POINTonE2_affine_invariant", "POINTonE1_affine_invariant", "/\\"];
       simplify (addsimps bls12_381_rx_thms fp2_simpset);
       simplify fp_simpset;
       simplify fp12_simpset;
       simplify prop_simpset;
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       unfolding ["miller_loop_imp"]; //  to expose the contained "point_double", for the next step...
       simplify remove_higher_order_function_simpset_alt;
       goal_eval_unint miller_loop_n_2_unints; // ... otherwise "point_double" is unfolded here!
       // the goal_eval was needed to deal with the `all` and `map` functions, now undo the damage:
       rw_with (concat fp12_unrip_thms
                       (concat seq_ite_thms [unrip_thm, fp2_unrip_thm, fp2_rep_unrip_thm, fp6_unrip_thm]));
       simplify fp_simpset;
       simplify fp2_simpset;
       rw_with (concat fp12_ring_laws fp12_conjugate_thms);
       rw_with (concat_all [ bls12_381_rx_thms, POINTonE2_thms, field_rewrites_for_miller_loop
                           , add_n_dbl_n_ret_n3_thms]);
       rw_with (concat [start_dbl_n_1_equiv_thm] start_dbl_n_equiv_thms);
       rw_with fp12_conjugate_thms; // Why do I need this again?
       w4_unint_z3 miller_loop_n_2_unints;
       };

