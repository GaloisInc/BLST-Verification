// TODO: Copyright notice (here and in all of the BLS wrapper proofs)

let {{
  finalverify_B: ProjectivePoint t_Fp_2 -> t_Fp_12 -> Bit
  finalverify_B e2 ctx_GT = is_head_one /\ is_tail_zero where
    e2_affine = affinify E' e2
    GT0 = miller_loop_opt_checked (POINTonE1_affine_abs (G1.0, G1.1)) e2_affine
    GT1 = fp12_conjugate GT0
    GT2 = Fp_12.mul (GT1, ctx_GT)
    GT3 = fp12_rep (final_exponentiation_impl GT2)
    [[a0, a1, a2], [a3, a4, a5]] = GT3
    is_head_one = Fp_2.is_equal (fp2_abs a0, fp2_abs one_mont_px)
    is_tail_zero = Fp_2.is_equal (fp2_abs a1, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a2, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a3, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a4, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a5, Fp_2.field_zero)
}};

let blst_pairing_finalverify_B_spec = do {
  ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.blst_pairing_st");
  GT <- llvm_fresh_var "GT" vec384fp12_type;
  llvm_precond {{ fp12_invariant GT }};
  AggrSign <- llvm_fresh_var "AggrSign" POINTonE2_type;
  llvm_precond {{ POINTonE2_invariant AggrSign }};
  crucible_precond {{ is_point_projective E' (POINTonE2_abs AggrSign) }}; // on the curve
  crucible_precond {{ ~(Fp_2.is_equal ((fp2_abs (AggrSign.2)), Fp_2.field_zero)) }};
  llvm_points_to (llvm_elem ctx_ptr 0)
                 (llvm_term {{ AGGR_HASH_OR_ENCODE
                            || AGGR_MIN_PK
                            || AGGR_SIGN_SET
                            || AGGR_GT_SET }});
  llvm_points_to (llvm_elem ctx_ptr 4) (llvm_term GT);
  llvm_points_to (llvm_elem ctx_ptr 5) (llvm_term AggrSign);
  llvm_execute_func [ ctx_ptr, llvm_null ];
  llvm_return (llvm_term {{ bool_to_limb (finalverify_B (POINTonE2_abs AggrSign)
                                                        (fp12_abs GT)) }});
};

let blst_pairing_aggregate_pk_in_g1_null_sig_spec ctx_nelems aggr_gt_set = do {
  ctx_ptr <- llvm_alloc (llvm_struct "struct.blst_pairing_st");
  //
  // ctx->ctrl must have AGGR_HASH_OR_ENCODE set and AGGR_MIN_SIG unset, but we
  // leave the rest uninterpreted
  ctx_ctrl <- llvm_fresh_var "ctx.ctrl" (llvm_int 32);
  llvm_precond {{ (ctx_ctrl && AGGR_HASH_OR_ENCODE) != 0 }};
  llvm_precond {{ (ctx_ctrl && AGGR_MIN_SIG) == 0 }};
  llvm_points_to (llvm_elem ctx_ptr 0) (llvm_term ctx_ctrl);
  //
  // Set ctx.nelems
  llvm_points_to (llvm_elem ctx_ptr 1) (llvm_term {{ `ctx_nelems : [32] }});
  //
  dst_ptr <- llvm_alloc_readonly (llvm_array dst_len (llvm_int 8));
  llvm_points_to dst_ptr (llvm_term {{ BMPKS::reexport_DST }});
  llvm_points_to (llvm_elem ctx_ptr 2) dst_ptr;
  llvm_points_to (llvm_elem ctx_ptr 3) (llvm_term {{ `dst_len : [64] }});
  ctx_GT <- if aggr_gt_set
            then llvm_fresh_var "ctx.GT" vec384fp12_type
            else return {{ undefined }};
  if aggr_gt_set
    then do {
      llvm_precond {{ (ctx_ctrl && AGGR_GT_SET) != 0 }};
      llvm_precond {{ fp12_invariant ctx_GT }};
      llvm_points_to (llvm_elem ctx_ptr 4) (llvm_term ctx_GT);
    } else llvm_precond {{ (ctx_ctrl && AGGR_GT_SET) == 0 }};
  ctx_Q0 <- if eval_bool {{ `ctx_nelems == (`N_MAX - 1) }}
            then llvm_fresh_var "ctx.Q0" POINTonE2_affine_type
            else return {{ undefined }};
  ctx_P0 <- if eval_bool {{ `ctx_nelems == (`N_MAX - 1) }}
            then llvm_fresh_var "ctx.P0" POINTonE1_affine_type
            else return {{ undefined }};
  ctx_AggrSign <- llvm_fresh_var "ctx.AggrSign" POINTonE2_type;
  llvm_points_to (llvm_elem ctx_ptr 5) (llvm_term ctx_AggrSign);
  //
  // Constrain ctx.P and ctx.Q if approaching N_MAX
  if eval_bool {{ `ctx_nelems == (`N_MAX - 1) }}
  then do {
    llvm_points_to (llvm_elem (llvm_elem ctx_ptr 6) 0) (llvm_term ctx_Q0);
    llvm_points_to (llvm_elem (llvm_elem ctx_ptr 7) 0) (llvm_term ctx_P0);
    llvm_precond {{ POINTonE2_affine_invariant ctx_Q0 }};
    llvm_precond {{ POINTonE1_affine_invariant ctx_P0 }};
  } else do { return (); };
  //
  (pk, pk_ptr) <- ptr_to_fresh_readonly "pk" POINTonE1_affine_type;
  llvm_precond {{ ~(is_point_O E (POINTonE1_affine_abs pk)) }};
  llvm_precond {{ POINTonE1_affine_invariant pk }};
  //
  let msg_len = 32;
  (msg, msg_ptr) <-
      ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  llvm_execute_func [ ctx_ptr
                    , pk_ptr
                    , llvm_null
                    , msg_ptr
                    , llvm_term {{ `msg_len : [64] }}
                    , llvm_null
                    , llvm_term {{ 0 : [64] }} ];
  let Q = {{ POINTonE2_affine_rep
               (affinify E' (hash_to_curve_E2_opt_impl (msg, BMPKS::reexport_DST))) }};
  if eval_bool {{ `ctx_nelems == (`N_MAX - 1) }}
  then do {
    llvm_points_to (llvm_elem ctx_ptr 1) (llvm_term {{ 0 : [32] }});
    llvm_points_to (llvm_elem ctx_ptr 0)
                   (llvm_term {{ ctx_ctrl || AGGR_GT_SET  || AGGR_MIN_PK }});
    let GT =
      {{ fp12_rep (F_prod Fp_12
                          [ miller_loop_opt (POINTonE1_affine_abs ctx_P0)
                                            (POINTonE2_affine_abs ctx_Q0)
                          , miller_loop_opt (POINTonE1_affine_abs pk)
                                            (POINTonE2_affine_abs Q) ]) }};
    if aggr_gt_set
    then do {
      llvm_points_to (llvm_elem ctx_ptr 4) (llvm_term
        {{ fp12_rep (Fp_12.mul (fp12_abs ctx_GT, fp12_abs GT)) }});
    } else do {
      // ctx->GT is set for the first time
      llvm_points_to (llvm_elem ctx_ptr 4) (llvm_term GT);
    };
  } else do {
    llvm_points_to (llvm_elem ctx_ptr 0)
                   (llvm_term {{ ctx_ctrl || AGGR_MIN_PK }});
    llvm_points_to (llvm_elem ctx_ptr 1)
                   (llvm_term {{ `ctx_nelems + 1 : [32]}});
    // ctx->GT is unchanged (if set)
    if aggr_gt_set
    then llvm_points_to (llvm_elem ctx_ptr 4) (llvm_term ctx_GT)
    else return ();
    // These postconditions on Q and P are true in the commit case too, but it
    // doesn't matter because they've already been processed in that case, so
    // we ignore them to simplify the proof.
    // ctx.Q[ctx.nelems] == Q
    llvm_points_to (llvm_elem (llvm_elem ctx_ptr 6) ctx_nelems) (llvm_term Q);
    // ctx.P[ctx.nelems] == pk
    llvm_points_to (llvm_elem (llvm_elem ctx_ptr 7) ctx_nelems)
                   (llvm_term pk);
  };
  // DST, dst_len, and AggrSign are unchanged
  llvm_points_to (llvm_elem ctx_ptr 2) dst_ptr;
  llvm_points_to (llvm_elem ctx_ptr 3) (llvm_term {{ `dst_len : [64] }});
  llvm_points_to (llvm_elem ctx_ptr 5) (llvm_term ctx_AggrSign);
  llvm_return (llvm_term {{ `BLST_SUCCESS : [32] }});
};

Hash_to_G2_ov <- prove_Hash_to_G2_impl msg_len dst_len aug_len;

hash_to_curve_opt_impl_POINTonE2_from_Jacobian_precond_thms <-
  core_verify_pk_in_g1_POINTonE2_from_Jacobian_hash_preconds msg_len dst_len aug_len;

// NOTE: normalize_hash_to_curve_impl is for E2, while
// normalize_hash_to_curve_impl_thms is for E1...
normalize_hash_to_curve_E2_opt_impl_rws <-
  normalize_hash_to_curve_impl msg_len dst_len aug_len;

blst_pairing_aggregate_pk_in_g1_null_sig_0_ov <- custom_verify
  "blst_pairing_aggregate_pk_in_g1"
  (foldr concat [vec_fp2_overrides, vec_overrides, mul_fp12_ovs]
                [ Hash_to_G2_ov
                , POINTonE2_from_Jacobian_alias_ov
                , vec_copy_2fp_ov
                , miller_loop_n_2_ov ])
  // AGGR_GT_SET will always be set in null_sig case for N_MAX == 2
  (blst_pairing_aggregate_pk_in_g1_null_sig_spec 0 true)
  do {
    unfolding [ "POINTonE1_affine_invariant"
              , "is_point_O"
              , "same_point_affine"
              , "point_O"
              , "POINTonE1_affine_abs"
              , "BMPKS::reexport_DST"
              , "BLSMinimalPublicKeySize::DST" ];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with POINTonE2_base_thms;
    unfolding ["POINTonE2_rep"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp2_rep_thms;
    rw_with normalize_hash_to_curve_E2_opt_impl_rws;
    rw_with hash_to_curve_opt_impl_POINTonE2_from_Jacobian_precond_thms;
    rw_with remove_ho_rules;
    print_goal;
    //print_readably;
    w4_unint_z3 (concat [ "affinify_E'"
                        , "hash_to_curve_E2_opt_impl" ]
                        BasicVerify_B_unints);
  };

let map_size_2_fp2_term = parse_core "\\(f : ((Vec 2 (Vec 6 (Vec 64 Bool))) * (Vec 2 (Vec 6 (Vec 64 Bool)))) -> ((Vec 2 Integer) * (Vec 2 Integer))) -> \\(y : Vec 2 ((Vec 2 (Vec 6 (Vec 64 Bool))) * (Vec 2 (Vec 6 (Vec 64 Bool))))) -> map ((Vec 2 (Vec 6 (Vec 64 Bool))) * (Vec 2 (Vec 6 (Vec 64 Bool)))) ((Vec 2 Integer) * (Vec 2 Integer)) f 2 y";

unfold_map_fp2 <- admit_cryptol (rewrite (cryptol_ss())
  {{ \f xs -> (map_size_2_fp2_term f xs) == ([f x1, f x2] where [x1, x2] = xs) }});

blst_pairing_aggregate_pk_in_g1_null_sig_1_first_commit_ov <- custom_verify
  "blst_pairing_aggregate_pk_in_g1"
  (foldr concat [vec_fp2_overrides, vec_overrides, mul_fp12_ovs]
                [ Hash_to_G2_ov
                , POINTonE2_from_Jacobian_alias_ov
                , vec_copy_2fp_ov
                , miller_loop_n_2_ov ])
  (blst_pairing_aggregate_pk_in_g1_null_sig_spec 1 false)
  do {
    // BEGIN N == 2 specific
    rw_with [ unfold_all_POINTonE1_affine_invariant_2_thm
            , unfold_all_POINTonE2_affine_invariant_2_thm ];
    unfolding [ "Cryptol::map" ];
    rw_with [unfold_map_fp2];
    // END N == 2 specific
    unfolding [ "POINTonE1_affine_invariant"
              , "is_point_O"
              , "same_point_affine"
              , "point_O"
              , "POINTonE1_affine_abs"
              , "BMPKS::reexport_DST"
              , "BLSMinimalPublicKeySize::DST" ];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with POINTonE2_base_thms;
    unfolding ["POINTonE2_rep"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp2_rep_thms;
    rw_with normalize_hash_to_curve_E2_opt_impl_rws;
    rw_with hash_to_curve_opt_impl_POINTonE2_from_Jacobian_precond_thms;
    // BEGIN N == 2 specific
    rw_with [normalize_affinify_fp2_thm, F_prod_Fp_12_thm];
    // END N == 2 specific
    rw_with remove_ho_rules;
    print_goal;
    //print_readably;
    w4_unint_z3 (concat [ "affinify_E'"
                        , "fp12_rep"
                        , "F_prod_Fp_12"
                        , "miller_loop_opt"
                        , "hash_to_curve_E2_opt_impl" ]
                        BasicVerify_B_unints);
  };

blst_pairing_aggregate_pk_in_g1_null_sig_1_nth_commit_ov <- custom_verify
  "blst_pairing_aggregate_pk_in_g1"
  (foldr concat [vec_fp2_overrides, vec_overrides, mul_fp12_ovs]
                [ Hash_to_G2_ov
                , POINTonE2_from_Jacobian_alias_ov
                , vec_copy_2fp_ov
                , miller_loop_n_2_ov ])
  (blst_pairing_aggregate_pk_in_g1_null_sig_spec 1 true)
  do {
    rw_with [ unfold_all_POINTonE1_affine_invariant_2_thm
            , unfold_all_POINTonE2_affine_invariant_2_thm ];
    unfolding [ "Cryptol::map" ];
    rw_with [unfold_map_fp2];
    unfolding [ "POINTonE1_affine_invariant"
              , "is_point_O"
              , "same_point_affine"
              , "point_O"
              , "POINTonE1_affine_abs"
              , "BMPKS::reexport_DST"
              , "BLSMinimalPublicKeySize::DST" ];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with POINTonE2_base_thms;
    unfolding ["POINTonE2_rep"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp2_rep_thms;
    rw_with normalize_hash_to_curve_E2_opt_impl_rws;
    rw_with hash_to_curve_opt_impl_POINTonE2_from_Jacobian_precond_thms;
    rw_with [normalize_affinify_fp2_thm, F_prod_Fp_12_thm];
    // BEGIN nth_commit specific
    rw_with fp12_rep_thms;
    // END nth_commit specific
    rw_with remove_ho_rules;
    print_goal;
    //print_readably;
    w4_unint_z3 (concat [ "affinify_E'"
                        , "fp12_rep"
                        , "F_prod_Fp_12"
                        , "miller_loop_opt"
                        , "hash_to_curve_E2_opt_impl" ]
                        BasicVerify_B_unints);
  };

let blst_pairing_aggregate_pk_in_g1_sig_spec = do {
  ctx_ptr <- llvm_alloc (llvm_struct "struct.blst_pairing_st");
  //
  // ctx->ctrl must have AGGR_HASH_OR_ENCODE set and AGGR_MIN_SIG unset, but we
  // leave the rest uninterpreted
  // TODO: Update this comment here and in the A version ^
  ctx_ctrl <- llvm_fresh_var "ctx.ctrl" (llvm_int 32);
  llvm_precond {{ (ctx_ctrl && AGGR_HASH_OR_ENCODE) != 0 }};
  llvm_precond {{ (ctx_ctrl && AGGR_MIN_SIG) == 0 }};
  llvm_precond {{ (ctx_ctrl && AGGR_GT_SET) == 0 }};
  llvm_precond {{ (ctx_ctrl && AGGR_SIGN_SET) == 0 }};
  llvm_points_to (llvm_elem ctx_ptr 0) (llvm_term ctx_ctrl);
  //
  // Set ctx.nelems
  llvm_points_to (llvm_elem ctx_ptr 1) (llvm_term {{ 0 : [32] }});
  //
  dst_ptr <- llvm_alloc_readonly (llvm_array dst_len (llvm_int 8));
  llvm_points_to dst_ptr (llvm_term {{ BMPKS::reexport_DST }});
  llvm_points_to (llvm_elem ctx_ptr 2) dst_ptr;
  llvm_points_to (llvm_elem ctx_ptr 3) (llvm_term {{ `dst_len : [64] }});
  //
  (pk, pk_ptr) <- ptr_to_fresh_readonly "pk" POINTonE1_affine_type;
  llvm_precond {{ ~(is_point_O E (POINTonE1_affine_abs pk)) }};
  llvm_precond {{ POINTonE1_affine_invariant pk }};
  //
  (sig, sig_ptr) <- ptr_to_fresh_readonly "sig" POINTonE2_affine_type;
  llvm_precond {{ ~ (is_point_O E' (POINTonE2_affine_abs sig)) }};
  llvm_precond {{ POINTonE2_affine_invariant sig }};
  llvm_precond {{ is_point_affine E' (POINTonE2_affine_abs sig) }};
  llvm_precond {{ is_in_g2_impl (POINTonE2_affine_abs sig) }};
  // TODO: This handles vec_is_zero, but I think there are rewrite rules to
  // derive is_point_O from (or to) this, which might make for a better spec,
  // and an uglier proof.
  llvm_precond {{ ~(Fp_2.is_equal (fp2_abs x, Fp_2.field_zero) /\
                    Fp_2.is_equal (fp2_abs y, Fp_2.field_zero))
                  where (x, y) = sig }};
  //
  let msg_len = 32;
  (msg, msg_ptr) <-
      ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  llvm_execute_func [ ctx_ptr
                    , pk_ptr
                    , sig_ptr
                    , msg_ptr
                    , llvm_term {{ `msg_len : [64] }}
                    , llvm_null
                    , llvm_term {{ 0 : [64] }} ];
  llvm_points_to (llvm_elem ctx_ptr 0)
                 (llvm_term {{ ctx_ctrl || AGGR_SIGN_SET  || AGGR_MIN_PK }});
  let Q = {{ POINTonE2_affine_rep
               (affinify E' (hash_to_curve_E2_opt_impl (msg, BMPKS::reexport_DST))) }};
  llvm_points_to (llvm_elem ctx_ptr 1) (llvm_term {{ 1 : [32]}});
  // These postconditions on Q and P are true in the commit case too, but it
  // doesn't matter because they've already been processed in that case, so
  // we ignore them to simplify the proof.
  // ctx.Q[ctx.nelems] == Q
  llvm_points_to (llvm_elem (llvm_elem ctx_ptr 6) 0) (llvm_term Q);
  // ctx.P[ctx.nelems] == pk
  llvm_points_to (llvm_elem (llvm_elem ctx_ptr 7) 0) (llvm_term pk);
  // DST, and dst_len are unchanged
  llvm_points_to (llvm_elem ctx_ptr 2) dst_ptr;
  llvm_points_to (llvm_elem ctx_ptr 3) (llvm_term {{ `dst_len : [64] }});
  llvm_points_to
      (llvm_elem ctx_ptr 5)
      (llvm_term {{ ( sig.0, sig.1, one_mont_px ) }});
  llvm_return (llvm_term {{ `BLST_SUCCESS : [32] }});
};

blst_pairing_aggregate_pk_in_g1_sig_ov <- really_custom_verify
  "blst_pairing_aggregate_pk_in_g1"
  (foldr concat [vec_fp2_overrides, vec_overrides, mul_fp12_ovs]
                [ Hash_to_G2_ov
                , POINTonE2_from_Jacobian_alias_ov
                , POINTonE2_in_g2_ov
                , vec_copy_2fp_ov
                , miller_loop_n_2_ov ])
  blst_pairing_aggregate_pk_in_g1_sig_spec
  do {
    unfolding [ "POINTonE2_affine_invariant"
              , "POINTonE1_affine_invariant"
              , "is_point_O"
              , "same_point_affine"
              , "point_O"
              , "POINTonE1_affine_abs"
              , "BMPKS::reexport_DST"
              , "BLSMinimalPublicKeySize::DST" ];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with POINTonE2_base_thms;
    unfolding ["POINTonE2_rep"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp2_rep_thms;
    rw_with normalize_hash_to_curve_E2_opt_impl_rws;
    rw_with hash_to_curve_opt_impl_POINTonE2_from_Jacobian_precond_thms;
    rw_with remove_ho_rules;
    print_goal;
    //print_readably;
    w4_unint_z3 (concat [ "affinify_E'"
                        , "hash_to_curve_E2_opt_impl" ]
                        BasicVerify_B_unints);
  };

// TODO: Continue with basic verify spec

blst_pairing_finalverify_B_ov <- custom_verify
  "blst_pairing_finalverify"
  (concat mul_fp12_ovs
          [ POINTonE2_from_Jacobian_ov
          , conjugate_fp12_ov
          , final_exp_alias_ov
          , vec_is_equal_fp2_ov
          , vec_is_zero_5fp2_ov
          , miller_loop_n_1_ov])
  blst_pairing_finalverify_B_spec
  do {
    rw_with fp12_rep_thms;
    rw_with [ affine_inv_affine_rep_e2_thm , one_mont_px_invariant_thm];
    unfolding ["fp12_rep", "fp6_rep", "finalverify_B", "G1", "one_mont_px"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp2_rep_thms;
    rw_with fp12_normalization_thms;
    rw_with POINTonE2_base_thms;
    rw_with [ normalize_miller_loop_opt_checked_thm
            , normalize_affinify_fp2_thm ];
    rw_with remove_ho_rules;
    print_goal;
    //print_readably;
    w4_unint_z3 (concat [ "all_distinct"
                        , "POINTonE2_abs"
                        , "POINTonE2_invariant"
                        , "is_point_projective_E'"
                        , "fp2_abs"
                        , "final_exponentiation_impl"
                        , "fp12_conjugate"
                        , "miller_loop_opt_checked"
                        , "Fp"
                        , "Fp_2"
                        , "fp12_abs" ]
                        BasicVerify_B_unints);
  };

// TODO: If you get an error about types not being memory compatible, it very
// well may be due to type checking on sig in the
// blst_pairing_aggregate_pk_in_g1 specs, which perform type checking where the
// equivalent g2 spec cannot (due to the union type in the struct).
