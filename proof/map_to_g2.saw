/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import "../spec/implementation/CurveOperation.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/subgroup-g2.cry";

let {{

  z = -15132376222941642752 : Integer
  minus_z = 0xd201000000010000

  is_in_g2_impl : AffinePoint t_Fp_2 -> Bool
  is_in_g2_impl P = is_point_O E' Q where
    Q = add E' (neg E' P1) P
    P1 = add E' P4 P2
    P2 = e2_scalar_mult z' P3
    P3 = psi P4
    P4 = psi (psi P)
    z' = 15132376222941642752

  is_in_g2_impl' P = is_point_O E' Q where
    Q = add E' (neg E' P1) P
    P1 = add E' P4 P2
    P2 = mult E' z' P3
    P3 = psi P4
    P4 = psi (psi P)
    z' = 0xd201000000010000

  // TODO: factor out with map_to_g1.saw
  bool_to_limb: Bool -> Limb
  bool_to_limb c = if c then 1 else 0
}};

// TODO: copied from ec_mult.saw
let {{
  add_exponents': Integer -> Integer -> Integer -> Integer
  add_exponents' e1 e2 order = if (e1-e2)%order == 0 then 0 else e1+e2
  e2_order: AffinePoint t_Fp_2 -> Integer
  e2_order P = undefined // TODO: what is this?
  }};
e2_scalar_mult_alg_thms <- for
  [
    {{ \ p1 -> add E' p1 p1 == e2_scalar_mult 2 p1 }}
  , {{ \ k k' p1 -> e2_scalar_mult k (e2_scalar_mult k' p1) == e2_scalar_mult (k*k') p1 }}

  , {{ \ k k' p1 -> add E' (e2_scalar_mult k p1) (e2_scalar_mult k' p1) ==
                    e2_scalar_mult (k + k') p1 }}
  // plus two special cases for k==1 or k'==1
  , {{ \ k    p1 -> add E' (e2_scalar_mult k p1) p1 == e2_scalar_mult (k + 1) p1 }}
  , {{ \ k    p1 -> add E' p1 (e2_scalar_mult k p1) == e2_scalar_mult (k + 1) p1 }}

  // negation
  , {{ \k p1 -> neg E' (e2_scalar_mult k p1) == e2_scalar_mult (- k) p1 }}
  // for precomputation, may need to know p == [1]p
  // , {{ \p1 -> ec_scalar_mult 1 p1 == p1 }}
  // and get rid of the (0,0,0) that come up
  , {{ \p1 -> point_add Fp (0,0,0) p1 == p1 }}
  // , {{ \p1 -> point_add Fp p1 (0,0,0) == ??? }}
  , {{ point_double Fp (0,0,0) == (0,0,0) }}
  // and arithmetic facts about the curve group
  , {{ \ p1 -> add E' p1 (point_O E') == p1 }}
  , {{ \ p1 -> add E' (point_O E') p1 == p1 }}
  ] admit_cryptol;
let {{
  point_add_fp2 = point_add Fp_2
  point_add_affine_fp2 = point_add_affine Fp_2
  point_dadd_fp2 = point_dadd Fp_2
  point_dadd_affine_fp2 = point_dadd_affine Fp_2
  point_double_fp2 = point_double Fp_2
  point_neg_fp2 = point_neg Fp_2
  add_E' = add E'
  mult_E' = mult E'
  neg_E' = neg E'
  is_point_O_E' = is_point_O E'
  //add'_E' = add' E'
  affinify_E' = affinify E'
  projectify_E' = projectify E'
  is_point_affine_E' = is_point_affine E'
  is_point_projective_E' = is_point_projective E'
  }};

point_add_fp2_thm <- prove_cryptol {{  \p1 p2 -> point_add Fp_2 p1 p2 == point_add_fp2 p1 p2 }} ["Fp_2"];
point_add_affine_fp2_thm <- prove_cryptol {{  \p1 p2 -> point_add_affine Fp_2 p1 p2 == point_add_affine_fp2 p1 p2 }} ["Fp_2"];
point_dadd_fp2_thm <- prove_cryptol {{  \p1 p2 a4 c -> point_dadd Fp_2 p1 p2 a4 c == point_dadd_fp2 p1 p2 a4 c}} ["Fp_2"];
point_dadd_affine_fp2_thm <- prove_cryptol {{  \p1 p2 -> point_dadd_affine Fp_2 p1 p2 == point_dadd_affine_fp2 p1 p2 }} ["Fp_2"];
point_double_fp2_thm <- prove_cryptol {{  \p1 -> point_double Fp_2 p1 == point_double_fp2 p1 }} ["Fp_2"];
point_neg_fp2_thm <- prove_cryptol {{  \p1 -> point_neg Fp_2 p1 == point_neg_fp2 p1 }} ["Fp_2"];
add_E'_thm <- prove_cryptol {{  \p1 p2 -> add E' p1 p2 == add_E' p1 p2 }} ["E'"];
//mult_E'_thm <- prove_cryptol {{  \k p2 -> mult E' k p2 == mult_E' k p2 }} ["E'"];
neg_E'_thm <- prove_cryptol {{  \p1 -> neg E' p1 == neg_E' p1 }} ["E'"];
is_point_O_E'_thm <- prove_cryptol {{  \p1 -> is_point_O E' p1 == is_point_O_E' p1 }} ["E'"];
//add'_E'_thm <- prove_cryptol {{  \p1 p2 -> add' E' p1 p2 == add'_E' p1 p2 }} ["E'"];
affinify_E'_thm <- prove_cryptol {{  \p1 -> affinify E' p1 == affinify_E' p1 }} ["E'"];
projectify_E'_thm <- prove_cryptol {{  \p1 -> projectify E' p1 == projectify_E' p1 }} ["E'"];
is_point_affine_E'_thm <- prove_cryptol {{  \p1 -> is_point_affine E' p1 == is_point_affine_E' p1 }} ["E'"];
is_point_projective_E'_thm <- prove_cryptol {{  \p1 -> is_point_projective E' p1 == is_point_projective_E' p1 }} ["E'"];

let remove_higher_order_function_simpset =
  addsimps [ point_add_fp2_thm, point_dadd_fp2_thm, point_double_fp2_thm, point_neg_fp2_thm
           , point_add_affine_fp2_thm, point_dadd_affine_fp2_thm
           , add_E'_thm, neg_E'_thm
           , affinify_E'_thm, projectify_E'_thm
           , is_point_affine_E'_thm, is_point_projective_E'_thm
           , is_point_O_E'_thm
           ] empty_ss;

is_point_projective_thms <- for
  [ {{ \P Q a4 -> is_point_projective E' (point_dadd Fp_2 P Q a4 True) ==
               if is_point_projective E' P /\ is_point_projective E' Q
               then True
               else apply is_point_projective E' (point_dadd Fp_2 P Q a4 True) }}

  , {{ \P Q -> is_point_projective E' (point_dadd_affine Fp_2 P Q) ==
               if is_point_projective E' P /\ is_point_affine E' Q
               then True
               else apply is_point_projective E' (point_dadd_affine Fp_2 P Q) }}

  , {{ \ P -> is_point_projective E' (point_neg Fp_2 P) ==
              if is_point_projective E' P
              then True
              else apply is_point_projective E' (point_neg Fp_2 P) }}

  , {{ \ P -> is_point_projective E' (point_double Fp_2 P) ==
              if is_point_projective E' P
              then True
              else apply is_point_projective E' (point_double Fp_2 P) }}
  ]
  admit_cryptol;

// times_minus_z

enable_experimental;

// TODO: now that we have goal_num_ite, is it still useful to use extraction here?

// we use the following spec to extract a term
let POINTonE2_times_minus_z_spec_ = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  new_out <- crucible_fresh_var "new_POINTonE2_times_minus_z_spec_out" POINTonE2_type;
  crucible_points_to out_ptr (crucible_term new_out);
  //crucible_points_to out_ptr (crucible_term {{ POINTonE2_rep (projectify E' (e2_scalar_mult (-z) (affinify E' (POINTonE2_abs in_)))) }});
};

POINTonE2_times_minus_z_ov_ <- crucible_llvm_compositional_extract m
  "POINTonE2_times_minus_z"
  "POINTonE2_times_minus_z"
  (foldr concat [vec_fp2_overrides, fp2_overrides, curve_operations_e2_ovs] [])
  true
  POINTonE2_times_minus_z_spec_
    (do {
      simplify (addsimps POINTonE2_thms fp2_simpset);
      w4_unint_z3 (concat fp2_unints e2_unints);
    });


affinify_POINTonE2_times_minus_z_thm <- really_custom_prove_cryptol
  {{ \p -> affinify E' (POINTonE2_abs (POINTonE2_times_minus_z p)) ==
          e2_scalar_mult (-z) (affinify E' (POINTonE2_abs p)) }}
  do {
    unfolding ["POINTonE2_times_minus_z"];
    simplify (addsimps (foldr concat [POINTonE2_thms, e2_curve_op_thms, e2_scalar_mult_alg_thms] []) empty_ss);
    print_goal;
    simplify remove_higher_order_function_simpset;
    w4_unint_z3 ["affinify_E'", "E'", "POINTonE2_abs", "e2_scalar_mult"];
  };

invariant_POINTonE2_times_c_thm <- really_custom_prove_cryptol
  {{ \p -> POINTonE2_invariant (POINTonE2_times_minus_z p) == True }}
  do { unfolding ["POINTonE2_times_minus_z"];
       simplify (addsimps POINTonE2_thms empty_ss);
       w4;
     };

//propositional_lemma <- prove_cryptol {{ \ (x:Bool) c y ->  (if c then y else x == x) == (c ==> x == y) }} [];

is_point_projective_POINTonE1_times_minus_z <- really_custom_prove_cryptol
  {{ \p -> is_point_projective E' (POINTonE2_abs (POINTonE2_times_minus_z p)) ==
           if is_point_projective E' (POINTonE2_abs p)
           then True
           else apply is_point_projective E' (POINTonE2_abs (POINTonE2_times_minus_z p)) }}
  do {
    unfolding ["apply"];
    simplify basic_ss;
    print_goal;
    unfolding ["POINTonE2_times_minus_z"];
    simplify (addsimps (foldr concat [POINTonE2_thms, is_point_projective_thms] []) empty_ss);
    simplify remove_higher_order_function_simpset;
    print_goal;
    w4_unint_z3 ["point_double_fp2","point_dadd_fp2","is_point_projective_E'"];
  };

let POINTonE2_in_g2_spec = do {
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_affine_invariant p }};
  crucible_precond {{ is_point_affine E' (POINTonE2_affine_abs p) }}; // on the curve
  crucible_precond {{ ~ (is_point_O E' (POINTonE2_affine_abs p)) }};  // and not at infinity
  crucible_execute_func [p_ptr];
  crucible_return (crucible_term {{ bool_to_limb (is_in_g2_impl (POINTonE2_affine_abs p)) }});
};

// spec for extraction:
//let POINTonE2_in_g2_spec_ = do {
  //(p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE2_affine_type;
  //crucible_precond {{ POINTonE2_affine_invariant p }};
  //crucible_precond {{ is_point_affine E' (POINTonE2_affine_abs p) }}; // on the curve
  //crucible_execute_func [p_ptr];
  //ret <- crucible_fresh_var "ret" limb_type;
  //crucible_return (crucible_term ret);
//};

//POINTonE2_in_g2_ov_ <- crucible_llvm_compositional_extract m
  //"POINTonE2_in_g2"
  //"POINTonE2_in_g2_term"
  //(foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides, curve_operations_e2_ovs] [psi_alias_1_2_ov', psi_ov', POINTonE2_times_minus_z_ov])
  //true
  //POINTonE2_in_g2_spec_
  //(do {
    //simplify (addsimps POINTonE2_thms (cryptol_ss ()));
    //unfolding ["POINTonE2_rep"];
    //simplify fp2_simpset;
    //w4;
  //});

// TODO: the two rules below are invalid, but used as a shortcut for now (the point
// must satisfy the rep invariant). Those will be valid once we swtich to (Z p)
// instead of Integer
thm1 <- admit_cryptol {{ \ p -> (affinify E' (projectify E' p)) == p }};
thm2 <- admit_cryptol {{ \ p -> (fp2_abs ((POINTonE2_rep p).2)) == p.2 }}; // not sure about that one...

is_point_O_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \p -> Fp_2.is_equal((projectify E' p).2, Fp_2.field_zero) ==
           if is_point_affine E' p
           then is_point_O E' p
           else apply Fp_2.is_equal ((projectify E' p).2, Fp_2.field_zero) }});

let {{
  one_mont_p = [0x760900000002fffd,0xebf4000bc40c0002,0x5f48985753c758ba,0x77ce585370525745,0x5c071a97a256ec6d,0x15f65ec3fa80e493] // see consts.h
  one_mont_px = [[0x760900000002fffd,0xebf4000bc40c0002,0x5f48985753c758ba,0x77ce585370525745,0x5c071a97a256ec6d,0x15f65ec3fa80e493],[0,0,0,0,0,0]] // see consts.h
}};
prove w4 {{ fp_abs one_mont_p == 1 }}; // Valid
prove w4 {{ fp2_abs [one_mont_p,zero] == [0,1] }}; // Valid

let {{
    if_false_rewrite : {a} (Eq a) => (a,a,a) -> (a,a,a) -> Bit
    if_false_rewrite x y = (if False then x else y) == y
  }};
if_false_1 <- prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["if_false_rewrite"] {{ if_false_rewrite`{[2]Integer} }})) []; // TODO: this can also be dealt with with basic_ss

one_abs_thm <- prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["one_mont_px"] {{ \x -> affinify E' (POINTonE2_abs (x.0, x.1, one_mont_px)) == POINTonE2_affine_abs x }})) [];

is_point_affine_thms <- for
  [ {{ \P Q -> is_point_affine_E' (add_E' P Q) ==
               if is_point_affine_E' P /\ is_point_affine_E' Q
               then True
               else apply is_point_affine_E' (add_E' P Q) }}
  , {{ \P -> is_point_affine_E' (neg_E' P) ==
               if is_point_affine_E' P
               then True
               else apply is_point_affine_E' (neg_E' P) }}
  , {{ \P k -> is_point_affine_E' (e2_scalar_mult k P) ==
               if is_point_affine_E' P
               then True
               else apply is_point_affine_E' (e2_scalar_mult k P) }}
  , {{ \P -> is_point_affine_E' (psi P) ==
               if is_point_affine_E' P
               then True
               else apply is_point_affine_E' (psi P) }}
  ]
  admit_cryptol;

//prove (do {
    //unfolding ["prop","POINTonE2_in_g2_term","is_in_g2_impl"];
    //simplify (addsimps (foldr concat [POINTonE2_thms,e2_curve_op_thms_2] [is_point_O_thm,thm1,thm2,if_false_1,one_abs_thm]) (cryptol_ss ()));
    //simplify remove_higher_order_function_simpset_;
    //print_goal;
    //simplify (addsimp test_thm empty_ss);
    //print_goal;
    //w4_unint_z3 ["psi", "add_E'", "is_point_O_E'", "neg_E'", "e2_scalar_mult", "is_point_affine_E'"];
  //})
  //{{prop}};


//POINTonE2_in_g2_ov <- really_custom_verify "POINTonE2_in_g2"
  //(foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides, curve_operations_e2_ovs] [psi_alias_1_2_ov', psi_ov', POINTonE2_times_minus_z_ov])
  //POINTonE2_in_g2_spec
  //(goal_num_ite 8
    //(do {
        //print_goal;
        //unfolding ["is_in_g2_impl"];
        //simplify (addsimps (foldr concat [POINTonE2_thms,e2_curve_op_thms_2] [is_point_O_thm,thm1,thm2,if_false_1,one_abs_thm]) (cryptol_ss ()));
        //simplify remove_higher_order_function_simpset_;
        //simplify (addsimps is_point_affine_thms basic_ss);
        //print_goal;
        //w4_unint_z3 ["psi", "add_E'", "is_point_O_E'", "neg_E'", "e2_scalar_mult", "is_point_affine_E'", "projectify_E'", "affinify_E'", "POINTonE2_affine_abs", "POINTonE2_affine_invariant", "E'", "Fp_2", "psi_imp"];
      //})
    //(do {
      //simplify (addsimps POINTonE2_thms (cryptol_ss ()));
      //unfolding ["POINTonE2_rep"];
      //simplify fp2_simpset;
      //w4;})
  //);

