/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import "../spec/G2SubGroupCheck.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/ShortWeierstrassCurve.cry";

// TODO: starting with POINTonE2_times_minus_z. Looks like we need POINTonE2_add_n_dbl

//let POINTonE2_add_n_dbl_spec = do {
  // looks like this does (out+p)2^n?
  // will need sizes 2, 3, 9, 32, and 16
  // uses POINTonE2_add and POINTonE2_double
//};

enable_experimental;

// We first give specs for POINTonE2_times_minus_z and psi, which we only, summarily test.

let {{ z = -15132376222941642752}};

let POINTonE2_times_minus_z_spec = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  crucible_points_to out_ptr (crucible_term {{ POINTonE2_rep (projectify E' (e2_scalar_mult z (affinify E' (POINTonE2_abs in_)))) }});
};

// spec for extraction:
let POINTonE2_times_minus_z_spec_ = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  new_out <- crucible_fresh_var "new_out" POINTonE2_type;
  crucible_points_to out_ptr (crucible_term new_out);
};

POINTonE2_times_minus_z_ov <- admit "POINTonE2_times_minus_z" POINTonE2_times_minus_z_spec;

POINTonE2_times_minus_z_ov_ <- crucible_llvm_compositional_extract m
  "POINTonE2_times_minus_z"
  "POINTonE2_times_minus_z_term"
  (foldr concat [vec_fp2_overrides, fp2_overrides, curve_operations_e2_ovs] [])
  true
  POINTonE2_times_minus_z_spec_
    (do {
      simplify (addsimps POINTonE2_thms fp2_simpset);
      w4_unint_z3 (concat fp2_unints e2_unints);
    });

let {{
minus_z = 0xd201000000010000
prop_times_minus_z k =
  same_point E' (POINTonE2_abs (POINTonE2_times_minus_z_term p)) (projectify E' (mult E' minus_z (affinify E' (POINTonE2_abs p))))
    where p = POINTonE2_rep (projectify E' (mult E' k BP'))
}};
prove (quickcheck 2) {{\(k:[4]) -> prop_times_minus_z k}};

let psi_spec = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  crucible_points_to out_ptr (crucible_term {{ POINTonE2_rep (projectify E' (psi (affinify E' (POINTonE2_abs in_)))) }});
};

let psi_alias_1_2_spec = do {
  (in_, in_ptr) <- ptr_to_fresh "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [in_ptr, in_ptr];
  crucible_points_to in_ptr (crucible_term {{ POINTonE2_rep (projectify E' (psi (affinify E' (POINTonE2_abs in_)))) }});
};

psi_ov <- admit "psi" psi_spec;
psi_alias_1_2_ov <- admit "psi" psi_alias_1_2_spec;

// spec for extraction:
let psi_spec_ = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  new_out <- crucible_fresh_var "new_out" POINTonE2_type;
  crucible_points_to out_ptr (crucible_term new_out);
};

// constants used in psi:
let {{
iwsc_rep = [[0x1804000000015554,0x855000053ab00001,0x633cb57c253c276f,0x6e22d1ec31ebb502,0xd3916126f2d14ca2,0x17fbb8571a006596],[0xa1fafffffffe5557,0x995bfff976a3fffe,0x03f41d24d174ceb4,0xf6547998c1995dbd,0x778a468f507a6034,0x020559931f7f8103]]
k_cx : [2]Vec384
k_cx = [zero,[0x890dc9e4867545c3,0x2af322533285a5d5,0x50880866309b7e2c,0xa20d1b8c7e881024,0x14e4f04fe2db9068,0x14e56d3f1564853a]]
k_cx_1 = [0x890dc9e4867545c3,0x2af322533285a5d5,0x50880866309b7e2c,0xa20d1b8c7e881024,0x14e4f04fe2db9068,0x14e56d3f1564853a]
k_cy = [[0x3e2f585da55c9ad1,0x4294213d86c18183,0x382844c88b623732,0x92ad2afd19103e18,0x1d794e4fac7cf0b9,0x0bd592fc7d825ec8],[0x7bcfa7a25aa30fda,0xdc17dec12a927e7c,0x2f088dd86b4ebef1,0xd1ca2087da74d4a7,0x2da2596696cebc1d,0x0e2b7eedbbfd87d2]]
k_cy_1 = [0x7bcfa7a25aa30fda,0xdc17dec12a927e7c,0x2f088dd86b4ebef1,0xd1ca2087da74d4a7,0x2da2596696cebc1d,0x0e2b7eedbbfd87d2]
}};

// some rewrite for terms that come up in the override preconditions:
iwsc_fp2_invariant <- really_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["iwsc_rep"] {{ fp2_invariant iwsc_rep == True }})) [];
k_cx_1_fp_invariant <- really_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["k_cx_1"] {{ fp_invariant k_cx_1 == True }})) [];
k_cy_1_fp_invariant <- really_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["k_cy_1"] {{ fp_invariant k_cy_1 == True }})) [];
let test0 = let t = parse_core "\\ (f:(Vec 2 Integer -> Vec 2 (Vec 6 (Vec 64 Bool)))) (x:(Vec 2 Integer)) -> at 2 (Vec 6 (Vec 64 Bool)) (f x) 0" in rewrite (cryptol_ss ()) ({{\x -> fp_invariant ((t fp2_rep) x) == True }});
my_thm0 <- prove_print w4 test0;
let test1 = let t = parse_core "\\ (f:(Vec 2 Integer -> Vec 2 (Vec 6 (Vec 64 Bool)))) (x:(Vec 2 Integer)) -> at 2 (Vec 6 (Vec 64 Bool)) (f x) 1" in rewrite (cryptol_ss ()) ({{\x -> fp_invariant ((t fp2_rep) x) == True }});
my_thm1 <- prove_print w4 test1;
// It turns out that w4 can discharge the preconditions without those when nothing is left uninterpreted, but this likely wouldn't work for the main goal. Since we can't differentiate we're stuck... or maybe with goal_when?

psi_ov_ <- crucible_llvm_compositional_extract m
  "psi"
  "psi_term"
  (foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides] [])
  true
  psi_spec_
  w4;

let {{
prop_psi k = same_point E' (POINTonE2_abs (psi_term p)) (projectify E' (psi (affinify E' (POINTonE2_abs p))))
  where p = POINTonE2_rep (projectify E' (mult E' k BP'))
}};
prove (quickcheck 2) {{\(k:[4]) -> prop_times_minus_z k}};

