/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import "../spec/G2SubGroupCheck.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/ShortWeierstrassCurve.cry";

// TODO: starting with POINTonE2_times_minus_z. Looks like we need POINTonE2_add_n_dbl

//let POINTonE2_add_n_dbl_spec = do {
  // looks like this does (out+p)2^n?
  // will need sizes 2, 3, 9, 32, and 16
  // uses POINTonE2_add and POINTonE2_double
//};

enable_experimental;

// We first give specs for POINTonE2_times_minus_z and psi, which we only, summarily test.

let {{
  z = -15132376222941642752
  minus_z = 0xd201000000010000
}};

let POINTonE2_times_minus_z_spec = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  //crucible_points_to out_ptr (crucible_term {{ POINTonE2_rep (projectify E' (e2_scalar_mult (-z) (affinify E' (POINTonE2_abs in_)))) }});
  // using mult for testing...
  crucible_points_to out_ptr (crucible_term {{ POINTonE2_rep (projectify E' (mult E' minus_z (affinify E' (POINTonE2_abs in_)))) }});
};

// spec for extraction:
let POINTonE2_times_minus_z_spec_ = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  new_out <- crucible_fresh_var "new_out" POINTonE2_type;
  crucible_points_to out_ptr (crucible_term new_out);
};

POINTonE2_times_minus_z_ov <- admit "POINTonE2_times_minus_z" POINTonE2_times_minus_z_spec;

POINTonE2_times_minus_z_ov_ <- crucible_llvm_compositional_extract m
  "POINTonE2_times_minus_z"
  "POINTonE2_times_minus_z_term"
  (foldr concat [vec_fp2_overrides, fp2_overrides, curve_operations_e2_ovs] [])
  true
  POINTonE2_times_minus_z_spec_
    (do {
      simplify (addsimps POINTonE2_thms fp2_simpset);
      w4_unint_z3 (concat fp2_unints e2_unints);
    });

let {{
prop_times_minus_z k =
  same_point E' (POINTonE2_abs (POINTonE2_times_minus_z_term p)) (projectify E' (mult E' minus_z (affinify E' (POINTonE2_abs p))))
    where p = POINTonE2_rep (projectify E' (mult E' k BP'))
}};
//prove (quickcheck 2) {{\(k:[4]) -> prop_times_minus_z k}};

let psi_spec = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  crucible_points_to out_ptr (crucible_term {{ POINTonE2_rep (projectify E' (psi (affinify E' (POINTonE2_abs in_)))) }});
};

let psi_alias_1_2_spec = do {
  (in_, in_ptr) <- ptr_to_fresh "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [in_ptr, in_ptr];
  crucible_points_to in_ptr (crucible_term {{ POINTonE2_rep (projectify E' (psi (affinify E' (POINTonE2_abs in_)))) }});
};

psi_ov <- admit "psi" psi_spec;
psi_alias_1_2_ov <- admit "psi" psi_alias_1_2_spec;

// spec for extraction:
let psi_spec_ = do {
  out_ptr <- crucible_alloc POINTonE2_type;
  (in_, in_ptr) <- ptr_to_fresh_readonly "in" POINTonE2_type;
  crucible_precond {{ POINTonE2_invariant in_ }};
  crucible_execute_func [out_ptr, in_ptr];
  new_out <- crucible_fresh_var "new_out" POINTonE2_type;
  crucible_points_to out_ptr (crucible_term new_out);
};

// constants used in psi:
let {{
iwsc_rep = [[0x1804000000015554,0x855000053ab00001,0x633cb57c253c276f,0x6e22d1ec31ebb502,0xd3916126f2d14ca2,0x17fbb8571a006596],[0xa1fafffffffe5557,0x995bfff976a3fffe,0x03f41d24d174ceb4,0xf6547998c1995dbd,0x778a468f507a6034,0x020559931f7f8103]]
k_cx : [2]Vec384
k_cx = [zero,[0x890dc9e4867545c3,0x2af322533285a5d5,0x50880866309b7e2c,0xa20d1b8c7e881024,0x14e4f04fe2db9068,0x14e56d3f1564853a]]
k_cx_1 = [0x890dc9e4867545c3,0x2af322533285a5d5,0x50880866309b7e2c,0xa20d1b8c7e881024,0x14e4f04fe2db9068,0x14e56d3f1564853a]
k_cy = [[0x3e2f585da55c9ad1,0x4294213d86c18183,0x382844c88b623732,0x92ad2afd19103e18,0x1d794e4fac7cf0b9,0x0bd592fc7d825ec8],[0x7bcfa7a25aa30fda,0xdc17dec12a927e7c,0x2f088dd86b4ebef1,0xd1ca2087da74d4a7,0x2da2596696cebc1d,0x0e2b7eedbbfd87d2]]
k_cy_1 = [0x7bcfa7a25aa30fda,0xdc17dec12a927e7c,0x2f088dd86b4ebef1,0xd1ca2087da74d4a7,0x2da2596696cebc1d,0x0e2b7eedbbfd87d2]
}};

// some rewrite for terms that come up in the override preconditions:
iwsc_fp2_invariant <- really_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["iwsc_rep"] {{ fp2_invariant iwsc_rep == True }})) [];
k_cx_1_fp_invariant <- really_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["k_cx_1"] {{ fp_invariant k_cx_1 == True }})) [];
k_cy_1_fp_invariant <- really_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["k_cy_1"] {{ fp_invariant k_cy_1 == True }})) [];
let test0 = let t = parse_core "\\ (f:(Vec 2 Integer -> Vec 2 (Vec 6 (Vec 64 Bool)))) (x:(Vec 2 Integer)) -> at 2 (Vec 6 (Vec 64 Bool)) (f x) 0" in rewrite (cryptol_ss ()) ({{\x -> fp_invariant ((t fp2_rep) x) == True }});
my_thm0 <- prove_print w4 test0;
let test1 = let t = parse_core "\\ (f:(Vec 2 Integer -> Vec 2 (Vec 6 (Vec 64 Bool)))) (x:(Vec 2 Integer)) -> at 2 (Vec 6 (Vec 64 Bool)) (f x) 1" in rewrite (cryptol_ss ()) ({{\x -> fp_invariant ((t fp2_rep) x) == True }});
my_thm1 <- prove_print w4 test1;
// It turns out that w4 can discharge the preconditions without those when nothing is left uninterpreted, but this likely wouldn't work for the main goal. Since we can't differentiate we're stuck... or maybe with goal_when?

psi_ov_ <- crucible_llvm_compositional_extract m
  "psi"
  "psi_term"
  (foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides] [])
  true
  psi_spec_
  w4;

let {{
prop_psi k = same_point E' (POINTonE2_abs (psi_term p)) (projectify E' (psi (affinify E' (POINTonE2_abs p))))
  where p = POINTonE2_rep (projectify E' (mult E' k BP'))
}};
//prove (quickcheck 2) {{\(k:[4]) -> prop_times_minus_z k}};

// just making sure:
// prove (quickcheck 3) {{\(k:[3]) -> (is_in_G2_impl' p == is_in_G2' p where p = mult E' k BP')}}

let POINTonE2_in_G2_spec = do {
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_affine_invariant p }};
  crucible_execute_func [p_ptr];
  crucible_return (crucible_term {{ if (is_in_G2_impl' (POINTonE2_affine_abs p)) then (1:Limb) else (0:Limb) }});
};

// spec for extraction:
let POINTonE2_in_G2_spec_ = do {
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE2_affine_type;
  crucible_precond {{ POINTonE2_affine_invariant p }};
  crucible_execute_func [p_ptr];
  ret <- crucible_fresh_var "ret" limb_type;
  crucible_return (crucible_term ret);
};

// this runs out of memory...
//prove (quickcheck 1) {{
  //\(z:[2]) (k:[2]) -> (e2_scalar_mult (toInteger z) P == mult E' z P
    //where P = mult E' k BP')
//}};

POINTonE2_in_G2_ov_ <- crucible_llvm_compositional_extract m
  "POINTonE2_in_G2"
  "POINTonE2_in_G2_term"
  (foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides, curve_operations_e2_ovs] [psi_alias_1_2_ov, psi_ov, POINTonE2_times_minus_z_ov])
  true
  POINTonE2_in_G2_spec_
  (do {
    simplify (addsimps POINTonE2_thms (cryptol_ss ()));
    unfolding ["POINTonE2_rep"];
    simplify fp2_simpset;
    w4;});

// all Valid:
//prove (quickcheck 10) {{ \(k:[5]) -> (POINTonE2_in_G2_term (POINTonE2_affine_rep p) == (1:Limb) where p = mult E' k BP')}};
//prove (quickcheck 2) {{ \(k:[2]) -> (POINTonE2_in_G2_term (POINTonE2_affine_rep p) == (if (is_in_G2_impl' p) then (1:Limb) else (0:Limb)) where p = mult E' k BP')}};
//prove (quickcheck 2) {{ \p -> POINTonE2_in_G2_term p == (if (is_in_G2_impl' (POINTonE2_affine_abs p)) then (1:Limb) else (0:Limb)) }};
// more rules:
// TODO: Invalid, but used as a shortcut for now (the point must satisfy the rep invariant):
thm1 <- admit_cryptol {{ \ p -> (affinify E' (projectify E' p)) == p }}; // TODO: Invalid
thm2 <- admit_cryptol {{ \ p -> (fp2_abs ((POINTonE2_rep p).2)) == p.2 }}; // TODO: Invalid

e2_curve_op_thms_2 <- for
 [ {{ \ p1 p2_aff -> point_dadd_affine Fp_2 p1 p2_aff == projectify E' (add E' (affinify E' p1) p2_aff) }}
 , {{ \ p1 p2 -> point_dadd Fp_2 p1 p2 Fp_2.field_zero True == projectify E' (add E' (affinify E' p1) (affinify E' p2)) }}
 , {{ \ p1 -> point_neg Fp_2 p1 == projectify E' (neg E' (affinify E' p1)) }}
 ]
 admit_cryptol;


// TODO: now deal with the point_zero test
// TODO: only true for points on the curve
is_point_O_thm' <- admit_cryptol (rewrite (cryptol_ss())
  {{ \p -> Fp_2.is_equal((projectify E' p).2, Fp_2.field_zero) == is_point_O E' p }});

// TODO: need to show that the implementation operations do the same as the abstract ops
// TODO: constant for 1

let {{
  one_mont_p = [0x760900000002fffd,0xebf4000bc40c0002,0x5f48985753c758ba,0x77ce585370525745,0x5c071a97a256ec6d,0x15f65ec3fa80e493] // see consts.h
  one_mont_px = [[0x760900000002fffd,0xebf4000bc40c0002,0x5f48985753c758ba,0x77ce585370525745,0x5c071a97a256ec6d,0x15f65ec3fa80e493],[0,0,0,0,0,0]] // see consts.h
}};
prove w4 {{ fp_abs one_mont_p == 1 }}; // Valid
prove w4 {{ fp2_abs [one_mont_p,zero] == [0,1] }}; // Valid

let {{
    if_false_rewrite : {a} (Eq a) => (a,a,a) -> (a,a,a) -> Bit
    if_false_rewrite x y = (if False then x else y) == y
  }};
if_false_1 <- prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["if_false_rewrite"] {{ if_false_rewrite`{[2]Integer} }})) [];

one_abs_thm <- prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["one_mont_px"] {{ \x -> affinify E' (POINTonE2_abs (x.0, x.1, one_mont_px)) == POINTonE2_affine_abs x }})) [];

let {{
  prop p = POINTonE2_in_G2_term p == (if (is_in_G2_impl' (POINTonE2_affine_abs p)) then (1:Limb) else (0:Limb))
}};

// TODO: we cannot leave those uninterpreted because they are higher-order. Is there a better way that this:
let {{
  point_add_fp2 = point_add Fp_2
  point_add_affine_fp2 = point_add_affine Fp_2
  point_dadd_fp2 = point_dadd Fp_2
  point_dadd_affine_fp2 = point_dadd_affine Fp_2
  point_double_fp2 = point_double Fp_2
  point_neg_fp2 = point_neg Fp_2
  add_E' = add E'
  mult_E' = mult E'
  neg_E' = neg E'
  is_point_O_E' = is_point_O E'
  //add'_E' = add' E'
  affinify_E' = affinify E'
  projectify_E' = projectify E'
  is_point_affine_E' = is_point_affine E'
  is_point_projective_E' = is_point_projective E'
  }};

// TODO: for now we only need add_E', mult_E', neg_E', and is_point_O_E'
point_add_fp2_thm <- prove_cryptol {{  \p1 p2 -> point_add Fp_2 p1 p2 == point_add_fp2 p1 p2 }} ["Fp_2"];
point_add_affine_fp2_thm <- prove_cryptol {{  \p1 p2 -> point_add_affine Fp_2 p1 p2 == point_add_affine_fp2 p1 p2 }} ["Fp_2"];
point_dadd_fp2_thm <- prove_cryptol {{  \p1 p2 a4 c -> point_dadd Fp_2 p1 p2 a4 c == point_dadd_fp2 p1 p2 a4 c}} ["Fp_2"];
point_dadd_affine_fp2_thm <- prove_cryptol {{  \p1 p2 -> point_dadd_affine Fp_2 p1 p2 == point_dadd_affine_fp2 p1 p2 }} ["Fp_2"];
point_double_fp2_thm <- prove_cryptol {{  \p1 -> point_double Fp_2 p1 == point_double_fp2 p1 }} ["Fp_2"];
point_neg_fp2_thm <- prove_cryptol {{  \p1 -> point_neg Fp_2 p1 == point_neg_fp2 p1 }} ["Fp_2"];
add_E'_thm <- prove_cryptol {{  \p1 p2 -> add E' p1 p2 == add_E' p1 p2 }} ["E'"];
mult_E'_thm <- prove_cryptol {{  \p1 p2 -> mult E' p1 p2 == mult_E' p1 p2 }} ["E'"];
neg_E'_thm <- prove_cryptol {{  \p1 -> neg E' p1 == neg_E' p1 }} ["E'"];
is_point_O_E'_thm <- prove_cryptol {{  \p1 -> is_point_O E' p1 == is_point_O_E' p1 }} ["E'"];
//add'_E'_thm <- prove_cryptol {{  \p1 p2 -> add' E' p1 p2 == add'_E' p1 p2 }} ["E'"];
affinify_E'_thm <- prove_cryptol {{  \p1 -> affinify E' p1 == affinify_E' p1 }} ["E'"];
projectify_E'_thm <- prove_cryptol {{  \p1 -> projectify E' p1 == projectify_E' p1 }} ["E'"];
is_point_affine_E'_thm <- prove_cryptol {{  \p1 -> is_point_affine E' p1 == is_point_affine_E' p1 }} ["E'"];
is_point_projective_E'_thm <- prove_cryptol {{  \p1 -> is_point_projective E' p1 == is_point_projective_E' p1 }} ["E'"];

let remove_higher_order_function_simpset =
  addsimps [ point_add_fp2_thm, point_dadd_fp2_thm, point_double_fp2_thm, point_neg_fp2_thm
           , point_add_affine_fp2_thm, point_dadd_affine_fp2_thm
           , add_E'_thm, affinify_E'_thm, projectify_E'_thm
           , is_point_affine_E'_thm, is_point_projective_E'_thm
           ] empty_ss;
let remove_higher_order_function_simpset_ =
  addsimps [ add_E'_thm, mult_E'_thm, neg_E'_thm, is_point_O_E'_thm] empty_ss;

prove (do {
    unfolding ["prop","POINTonE2_in_G2_term","is_in_G2_impl'"];
    simplify (addsimps (foldr concat [POINTonE2_thms,e2_curve_op_thms_2] [thm1,thm2,is_point_O_thm',if_false_1, one_abs_thm]) (cryptol_ss ()));
    simplify remove_higher_order_function_simpset_;
    print_goal;
    w4_unint_z3 ["psi", "add_E'", "is_point_O_E'", "mult_E'", "neg_E'"];
  })
  {{prop}};

// We just assumne that the projective curve operations take points on the curve
// to points on the curve.  These are well-known properties of these mathematical functions
is_point_projective_thms <- for
  [ {{ \P Q a4 -> is_point_projective E' (point_dadd Fp_2 P Q a4 True) ==
               if is_point_projective E' P /\ is_point_projective E' Q
               then True
               else apply is_point_projective E' (point_dadd Fp_2 P Q a4 True) }}

  , {{ \P Q -> is_point_projective E' (point_dadd_affine Fp_2 P Q) ==
               if is_point_projective E' P /\ is_point_affine E' Q
               then True
               else apply is_point_projective E' (point_dadd_affine Fp_2 P Q) }}

  , {{ \ P -> is_point_projective E' (point_neg Fp_2 P) ==
              if is_point_projective E' P
              then True
              else apply is_point_projective E' (point_neg Fp_2 P) }}

  , {{ \ P -> is_point_projective E' (point_double Fp_2 P) ==
              if is_point_projective E' P
              then True
              else apply is_point_projective E' (point_double Fp_2 P) }}
  ]
  admit_cryptol;
