/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";

enable_experimental;

let do_prove = false;

include "proof-helpers.saw";
include "blst_error.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";
include "exp.saw";
include "sgn0.saw";
include "deserialize-p1.saw";
include "map_to_g1.saw";

let do_prove = true;

// the enum for aggregate-operations errors
let AGGR_UNDEFINED = {{ zero:[32] }};
let AGGR_MIN_SIG = {{ 1:[32] }};
let AGGR_MIN_PK = {{ 2:[32] }};
let AGGR_SIGN_SET = {{ 16:[32] }};
let AGGR_GT_SET = {{ 32:[32] }};
let AGGR_HASH_OR_ENCODE = {{ 64:[32] }};
let MIN_SIG_OR_PK = {{ AGGR_MIN_SIG || AGGR_MIN_PK }};

let N_MAX = 8; // NOTE: must match N_MAX defined in C code

// blst_aggregate_in_g1
let blst_aggregate_in_g1 = do {

  out_ptr <- llvm_alloc (llvm_struct "struct.POINTonE1");
  (inp, inp_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g1_in" (llvm_struct "struct.POINTonE1"); // implies in != null

  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g1_zwire" (llvm_array 48 (llvm_int 8));
  llvm_precond {{ (zwire@0) && 0x40 == 0 }}; // infinity bit not set
  llvm_precond {{ uncompress_E1_imp zwire != nothing }}; // decompression succeeds (implies commpressed bit is set)
  llvm_precond {{ is_in_g1_impl (POINTonE1_affine_abs p) }}; // subgroup check succeeds

  crucible_execute_func [out_ptr, inp_ptr, zwire_ptr];

  crucible_points_to out_ptr (crucible_term {{ POINTonE1_dadd in (uncompress_E1_OK inp) }});

  crucible_return (crucible_term {{ BLST_SUCCESS }});
};

// TODO: extract term and test
