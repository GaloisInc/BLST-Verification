/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";

enable_experimental;

let do_prove = false;

include "proof-helpers.saw";
include "blst_error.saw";
// include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";
include "exp.saw";
include "sgn0.saw";
include "deserialize-p1.saw";
include "map_to_g1.saw";

let do_prove = true;

// the enum for aggregate-operations errors
// let AGGR_UNDEFINED = {{ zero:[32] }};
// let AGGR_MIN_SIG = {{ 1:[32] }};
// let AGGR_MIN_PK = {{ 2:[32] }};
// let AGGR_SIGN_SET = {{ 16:[32] }};
// let AGGR_GT_SET = {{ 32:[32] }};
// let AGGR_HASH_OR_ENCODE = {{ 64:[32] }};
// let MIN_SIG_OR_PK = {{ AGGR_MIN_SIG || AGGR_MIN_PK }};

// let N_MAX = 8; // NOTE: must match N_MAX defined in C code

// blst_aggregate_in_g1
let blst_aggregate_in_g1_spec = do {
  //
  out_ptr <- llvm_alloc (llvm_struct "struct.POINTonE1");
  (inp, inp_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g1_in" (llvm_struct "struct.POINTonE1"); // implies in != null
  //
  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g1_zwire" (llvm_array 48 (llvm_int 8));
  llvm_precond {{ ~(zwire@0)@1 }}; // infinity bit not set
  llvm_precond {{ (zwire@0)@0 }}; // compressed
  llvm_precond {{ uncompress_E1_imp zwire != nothing }}; // decompression succeeds (this does not check for zero)
  llvm_precond {{ uncompress_E1_x_fp zwire != Fp.field_zero }}; // decompressed value is not zero
  llvm_precond {{ POINTonE1_invariant inp }};
  llvm_precond {{ is_in_g1_impl (uncompress_E1_OK zwire)  }}; // subgroup check succeeds
  //
  llvm_execute_func [out_ptr, inp_ptr, zwire_ptr];
  //
  new_out <- llvm_fresh_var "new_out" (llvm_struct "struct.POINTonE1");
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ (POINTonE1_abs new_out) == point_dadd_affine Fp (POINTonE1_abs inp) (uncompress_E1_OK zwire) }};
  //
  llvm_return (llvm_term {{ (`BLST_SUCCESS):[32] }});
};

let blst_aggregate_in_g1_extract_spec = do {
  //
  out_ptr <- llvm_alloc (llvm_struct "struct.POINTonE1");
  (inp, inp_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g1_in" (llvm_struct "struct.POINTonE1"); // implies in != null
  //
  (zwire, zwire_ptr) <- ptr_to_fresh_readonly "blst_aggregate_in_g1_zwire" (llvm_array 48 (llvm_int 8));
  llvm_precond {{ ~(zwire@0)@1 }}; // infinity bit not set
  llvm_precond {{ (zwire@0)@0 }}; // compressed
  llvm_precond {{ uncompress_E1_imp zwire != nothing }}; // decompression succeeds (implies commpressed bit is set)
  llvm_precond {{ POINTonE1_invariant inp }};
  //
  llvm_execute_func [out_ptr, inp_ptr, zwire_ptr];
  //
  new_out <- llvm_fresh_var "new_out" (llvm_struct "struct.POINTonE1");
  ret <- llvm_fresh_var "ret" (llvm_int 32);
  //
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_return (llvm_term ret);
};

let overrides = foldr concat [vec_overrides,curve_operations_e1_ovs] [POINTonE1_Uncompress_OK_ov,POINTonE1_in_G1_ov];

/* For some reason this does not work if out is not declared initialized
llvm_compositional_extract m
  "blst_aggregate_in_g1"
  "blst_aggregate_in_g1_term"
  overrides
  true
  blst_aggregate_in_g1_extract_spec
  (goal_num_ite 1 // preconditions of the subgroup check
    do {
      let not_point_O = run (
        admit_cryptol {{ \x -> (is_point_O E (uncompress_E1_OK x)) == if uncompress_E1_x_fp x != Fp.field_zero then False else apply is_point_O E (uncompress_E1_OK x) }}
      );
      let on_curve = run (
        admit_cryptol {{ \x -> (is_point_affine E (uncompress_E1_OK x)) == True }}
      );
      simplify (addsimps (concat POINTonE1_thms [not_point_O, on_curve]) empty_ss);
      w4_unint_z3 ["sqrt_fp","uncompress_E1_x_fp","uncompress_E1_x","uncompress_E1_y2","is_square_fp"];
    }
    (goal_num_ite 2
      do { // preconditions of dadd
        simplify (addsimps POINTonE1_thms (cryptol_ss ()));
        simplify remove_higher_order_function_simpset;
        w4_unint_z3 ["sqrt_fp","Fp","uncompress_E1_x_fp","uncompress_E1_x","uncompress_E1_y2","is_square_fp","is_in_g1_impl","uncompress_E1_OK","uncompress_E1_imp","is_point_affine_E","Fp","E"];
      }
      do { // preconditions of Uncompress
        w4_unint_z3 ["sqrt_fp","Fp","uncompress_E1_x_fp","uncompress_E1_x","uncompress_E1_y2","is_square_fp"];
      }));
*/

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
  fp_neg = Fp.neg
}};

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p -> Fp.neg p == fp_neg p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

blst_aggregate_in_g1_ov <- custom_verify
  "blst_aggregate_in_g1"
  overrides
  blst_aggregate_in_g1_spec
  (goal_num_ite 1 // preconditions of the subgroup check
    do {
      let not_point_O = run (
        admit_cryptol {{ \x -> (is_point_O E (uncompress_E1_OK x)) == if uncompress_E1_x_fp x != Fp.field_zero then False else apply is_point_O E (uncompress_E1_OK x) }}
      );
      let on_curve = run (
        admit_cryptol {{ \x -> (is_point_affine E (uncompress_E1_OK x)) == True }}
      );
      simplify (addsimps (concat POINTonE1_thms [not_point_O, on_curve]) empty_ss);
      w4_unint_z3 ["sqrt_fp","uncompress_E1_x_fp","uncompress_E1_x","uncompress_E1_y2","is_square_fp","is_in_g1_impl"];
    }
    do {
      simplify (addsimps POINTonE1_thms empty_ss);
      simplify remove_higher_order_function_simpset;
      w4_unint_z3 ["sqrt_fp","uncompress_E1_x_fp","uncompress_E1_x","uncompress_E1_y2","is_square_fp","is_in_g1_impl","uncompress_E1_OK","is_point_affine_E"];
    });
