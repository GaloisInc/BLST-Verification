/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";

enable_experimental;

let do_prove = false;

include "proof-helpers.saw";
//include "hash_to_field.saw";
include "fp_overrides.saw";
include "fp2_overrides.saw";
include "vect.saw";
//include "x86.saw";
include "curve_operations.saw";
include "curve_operations_e2.saw";
//include "ec_mult.saw";
include "exp.saw";
include "exp2.saw";
include "sgn0.saw";

//let do_prove = true;

import "../spec/Parameters.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE2.cry" (Z A' B' map_to_curve_simple_swu hash_to_field Isogenous_Curve clear_cofactor k1s k2s k3s k4s iso_map hash_to_curve_opt);
import "../spec/BLSFieldExtras.cry";
import "../spec/implementation/CurveOperation.cry";
Aux <- cryptol_load "../spec/HashToCurveE2Aux.cry";
import "../spec/implementation/HashToG2.cry";

// Specs

let blst_hash_to_g2_impl_spec msg_len DST_len aug_len = do {
  p_ptr <- llvm_alloc POINTonE2_type;
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  llvm_execute_func [p_ptr, msg_ptr, llvm_term {{ `msg_len : [64] }}, DST_ptr, llvm_term {{ `DST_len : [64] }}, aug_ptr, llvm_term {{ `aug_len : [64] }}];
  llvm_points_to p_ptr (llvm_term {{ (POINTonE2_rep (hash_to_curve_opt_impl (aug#msg, DST))) }});
};

let map_to_g2_nonnull_spec = do {
  out_ptr <- llvm_alloc POINTonE2_type;
  (u,u_ptr) <- ptr_to_fresh_readonly "u" vec384x_type;
  (v,v_ptr) <- ptr_to_fresh_readonly "v" vec384x_type;
  llvm_precond {{ fp2_invariant u }};
  llvm_precond {{ fp2_invariant v }};
  llvm_execute_func [out_ptr, u_ptr, v_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (map_to_g2_impl [fp2_abs u, fp2_abs v]) }});
};


let map_to_isogenous_E2_impl_spec = do {
  out_ptr <- llvm_alloc POINTonE2_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384x_type;
  llvm_precond {{ fp2_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (map_to_curve_E2_prime_impl (fp2_abs u)) }});
};

let isogeny_map_to_E2_impl_alias_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE2_type;
  llvm_precond {{ POINTonE2_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (isogeny_map_to_E2_impl (POINTonE2_abs out)) }} );
};

let clear_cofactor_E2_impl_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE2_type;
  llvm_precond {{ POINTonE2_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (clear_cofactor_E2_impl (POINTonE2_abs out)) }} );
};

// Assumptions

// TODO: move somewhere else
let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// The optimized version of clear_cofactor given in the IETF spec is correct:
clear_cofactor_with_psi_thm <- custom_prove_cryptol {{ \p -> Aux::clear_cofactor_E2_with_psi p == clear_cofactor p }};

// The SWU map maps to the isogenous curve:
swu_on_curve <- simp_then_admit {{ \u -> is_point_affine Isogenous_Curve (map_to_curve_simple_swu u) == True }};

// point_dadd implements add:
dadd_thm <- admit_cryptol (rewrite (cryptol_ss ()) {{ \ p1 p2 -> affinify Isogenous_Curve (point_dadd Fp_2 p1 p2 A' False) == add Isogenous_Curve (affinify Isogenous_Curve p1) (affinify Isogenous_Curve p2) }});

// the addition of two points on the curve is on the curve:
point_dadd_on_curve <- simp_then_admit {{ \p q -> is_point_projective Isogenous_Curve (point_dadd Fp_2 p q A' False) == if is_point_projective Isogenous_Curve p /\ is_point_projective Isogenous_Curve q then True else apply is_point_projective Isogenous_Curve (point_dadd Fp_2 p q A' False) }};

// If p is a projective point on the isogenous and `affinify p` is point_O, then p's Z coordinate is 0:
on_curve_is_point_O_lemma <- simp_then_admit {{ \p -> is_point_O Isogenous_Curve (affinify Isogenous_Curve p) == if (is_point_projective Isogenous_Curve p /\ ~is_zero Fp_2 p.2) then False else apply is_point_O Isogenous_Curve (affinify Isogenous_Curve p) }};

// The implementation of map_to_curve never returns something of the form (0,0,_) or (_,_,0)
swu_impl_xy_nz <- simp_then_admit {{ \u -> (~((x,y) == (Fp_2.field_zero,Fp_2.field_zero) \/ z == Fp_2.field_zero) where (x,y,z) = map_to_curve_E2_prime_impl u) == True }};

is_point_projective_lemma <- simp_then_admit {{ \p -> is_point_projective Isogenous_Curve p == if is_point_affine Isogenous_Curve (affinify Isogenous_Curve p) /\ ~((p.0, p.1) == (Fp_2.field_zero,Fp_2.field_zero) \/ p.2 == Fp_2.field_zero) then True else apply is_point_projective Isogenous_Curve p }};

// Proofs

let {{
  fp2_mul = Fp_2.mul
  fp2_sq = Fp_2.sq
  fp2_add = Fp_2.add
  fp2_div = Fp_2.div
  fp2_zero = Fp_2.field_zero
  fp2_unit = Fp_2.field_unit
  fp2_is_equal = Fp_2.is_equal
  fp2_neg = Fp_2.neg
}};

readability_rewrites <- for [
  {{ \p q -> Fp_2.mul (p,q) == fp2_mul (p,q) }}
, {{ \p q -> Fp_2.add (p,q) == fp2_add (p,q) }}
, {{ \p -> Fp_2.sq p == fp2_sq p }}
, {{ \p -> Fp_2.neg p == fp2_neg p }}
, {{ \p q -> Fp_2.div (p, q) == fp2_div (p, q) }}
, {{ Fp_2.field_zero == fp2_zero }}
, {{ Fp_2.field_unit == fp2_unit }}
, {{ \x y -> Fp_2.is_equal (x,y) == fp2_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

// aux_rewrites <- for [
    // {{ Aux::A' == A' }}
  // , {{ Aux::Z == Z }}
  // , {{ Aux::B' == B' }}
  // , {{ \x -> Aux::sgn0 x == sgn0 x}}
// ] (\ eq -> prove_cryptol eq []);


// First we verify the C functions against their implementation-level specs

// isogeny_map_to_E2

isogeny_algebra_rules <- for [
    {{ \x y -> Fp_2.mul(x,y) == Fp_2.mul(y,x) }}
  , {{ \x y z -> Fp_2.mul(Fp_2.mul(x,y),z) == Fp_2.mul(x, Fp_2.mul(y,z)) }}
  // , {{ \x y z -> Fp_2.mul(x, Fp_2.mul(y,z)) == Fp_2.mul(Fp_2.mul(x,y),z) }}
  , {{ \x y -> Fp_2.add(x,y) == Fp_2.add(y,x) }}
  , {{ \x y z -> Fp_2.add(Fp_2.add(x,y),z) == Fp_2.add(x, Fp_2.add(y,z)) }}
  // , {{ \x y z -> Fp_2.add(x, Fp_2.add(y,z)) == Fp_2.add(Fp_2.add(x,y),z) }}
] admit_cryptol;

isogeny_restiching_rules <- for [
    {{ \(a:[2]Integer) -> ([x,y] == a where [x,y] = a) }}
  , {{ \(a:[2][6][64]) -> ([x,y] == a where [x,y] = a) }}
  , {{ \(a:[6][64]) -> ([a1,a2,a3,a4,a5,a6] == a where [a1,a2,a3,a4,a5,a6] = a) }}
] (\ eq -> really_custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

isogeny_map_to_E2_impl_alias_ov <- really_custom_verify
  "isogeny_map_to_E2"
  fp2_overrides
  isogeny_map_to_E2_impl_alias_spec
  (goal_num_ite 44 // 44 is the main safety goal
    (do {
      simplify fp2_simpset; // eliminate `abs . rep` etc.
      // simplify (addsimps isogeny_invs empty_ss); // NOTE: unecessary
      goal_eval_unint ["Fp_2","Fp","fp2_rep","fp2_abs","fp2_invariant","HashToCurveE2Aux::k1s","HashToCurveE2Aux::k2s","HashToCurveE2Aux::k3s","HashToCurveE2Aux::k4s"]; // TODO: why do we need to keep the kns opaque?
      simplify (addsimps (concat isogeny_restiching_rules isogeny_algebra_rules) empty_ss);
      w4_unint_z3  ["fp2_rep"]; // TODO: keeping Fp_2 unfolded makes it fail; why?
    })
    (do { // discharge simulation side-conditions:
      unfolding ["POINTonE2_invariant"];
      simplify fp2_simpset;
      w4_unint_z3 ["fp2_rep"];
    })
  );

// Next we prove that the implementation-level spec is equivalent to the abstract spec

// Temporary assumptions:

clear_cofactor_correct <- admit_cryptol {{ \p -> affinify E' (clear_cofactor_E2_impl p) == clear_cofactor (affinify E' p) }};

map_to_E2_prime_correct <- admit_cryptol {{ \u -> affinify Isogenous_Curve (map_to_curve_E2_prime_impl u) == map_to_curve_simple_swu u }};

isogeny_map_to_E2_correct <- admit_cryptol {{ \p -> affinify E' (isogeny_map_to_E2_impl p) == if is_point_projective Isogenous_Curve p then iso_map (affinify Isogenous_Curve p) else affinify E' (apply isogeny_map_to_E2_impl p) }};

// We need to establish that we get a point on Isogenous_Curve:
map_to_curve_E2_prime_on_curve <- really_custom_prove_cryptol {{ \u -> is_point_projective Isogenous_Curve (map_to_curve_E2_prime_impl u) == True }}
do {
  simplify (addsimps [is_point_projective_lemma,swu_impl_xy_nz,map_to_E2_prime_correct,swu_on_curve] empty_ss);
  w4_unint_z3 (concat fp_unints ["map_to_curve_E2_prime_impl"]);
};

let aug_len = 48; // aug_len should be 96 or 48
let msg_len = 32;
let DST_len= 8;

final_thm <- really_custom_prove_cryptol {{ \(msg:[msg_len][8]) (dst:[DST_len][8]) -> affinify E' (hash_to_curve_opt_impl (msg,dst)) == hash_to_curve_opt (msg, dst) }}
  do {
    unfolding ["hash_to_curve_opt_impl","map_to_g2_impl"];
    simplify (addsimps [clear_cofactor_correct, isogeny_map_to_E2_correct,point_dadd_on_curve,map_to_curve_E2_prime_on_curve,dadd_thm,map_to_E2_prime_correct] (cryptol_ss ()));
    unfolding ["/\\"];
    simplify cleanup_simpset;
    // unfolding ["hash_to_curve_opt"];
    print_readably;
    w4_unint_z3 (concat fp_unints ["iso_map","map_to_curve_simple_swu","clear_cofactor","HashToCurveE2::hash_to_field"]);
  };

// Old stuff...

let {{ // this is the "else" term in the definition of iso_map
  iso_map' (x', y') = (x, y) where
      x_powers = [Fp_2.field_unit] # [Fp_2.mul(x', xi) | xi <- x_powers]
      x_num = F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]
      x_den = Fp_2.add (x_powers@2, F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])
      y_num = F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]
      y_den = Fp_2.add (x_powers@3, F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])
      x = Fp_2.div (x_num, x_den)
      y = Fp_2.mul (y', Fp_2.div(y_num, y_den))
}};

let isogeny_map_to_E2_impl_alias_extract_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE2_type;
  llvm_precond {{ POINTonE2_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  new_out <- llvm_fresh_var "new_out" POINTonE2_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

_ <- crucible_llvm_compositional_extract m
  "isogeny_map_to_E2"
  "isogeny_map_to_E2_term"
  fp2_overrides
  true
  isogeny_map_to_E2_impl_alias_extract_spec
  do {
    simplify fp2_simpset;
    w4_unint_z3 ["fp2_rep"];
  };

// First case: Z is zero
isogeny_map_to_E1_impl_thm_z <- custom_prove_cryptol {{ \p -> affinify E' (POINTonE2_abs (isogeny_map_to_E2_term p)) == if is_zero Fp_2 (POINTonE2_abs p).2 then iso_map (affinify Isogenous_Curve (POINTonE2_abs p)) else apply affinify E' (POINTonE2_abs (isogeny_map_to_E2_term p)) }}
assume_unsat;

do {
  let lemma_1 = run (
    simp_then_admit {{ \p -> affinify E (isogeny_map_to_E1_impl p) == if is_zero Fp p.2 then point_O E else apply affinify E (isogeny_map_to_E1_impl p) }} // TODO
  );
  let lemma_2 = run (
    simp_then_admit {{ \p -> iso_map (affinify Isogenous_Curve p) == if is_zero Fp p.2 then point_O E else apply iso_map (affinify Isogenous_Curve p) }} // TODO
  );
  simplify (addsimps [lemma_1, lemma_2] (cryptol_ss ()));
  w4_unint_z3 ["isogeny_map_to_E1_impl","iso_map","Fp"];
};

// okay:
really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (POINTonE2_abs (isogeny_map_to_E2_term (POINTonE2_rep p)) == isogeny_map_to_E2_impl p where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);

// fails on (0,0,_):
really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> ((p.0,p.1) != (zero,zero) ==> iso_map (affinify E' p) == affinify E' (isogeny_map_to_E2_impl p) where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);

// fails:
really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (((p.0,p.1) != (zero,zero) ==> affinify E' (POINTonE2_abs (isogeny_map_to_E2_term (POINTonE2_rep p))) == iso_map (affinify E' p) where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);

iso_map_main_lemma <- really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (iso_map' (affinify_nz (POINTonE2_abs p)) == if ~Fp_2.is_equal((POINTonE2_abs p).2, Fp_2.field_zero) then affinify_nz (POINTonE2_abs (isogeny_map_to_E2_term p)) else apply iso_map' (affinify_nz (POINTonE2_abs p)) where p = POINTonE2_rep ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);
// iso_map_main_lemma <- simp_then_admit {{ \p -> iso_map' (affinify_nz p) == if ~Fp.is_equal(p.2, Fp.field_zero) then affinify_nz (isogeny_map_to_E2_impl p) else apply iso_map' (affinify_nz p) }};

// rewrite rule to get rid of a 12 limbs array that appears in map_to_isogenous_E2_term
// TODO: why does this appear? There's no override using (llvm_array 12 ...)

fix_vec_12 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \(x:t_Fp_2) y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 c -> (
     [[z1, z2, z3, z4, z5, z6], [z7, z8, z9, z10, z11, z12]] == (if c then [[y1, y2, y3, y4, y5, y6], [y7, y8, y9, y10, y11, y12]] else (fp2_rep x)) where
        [a,b] = fp2_rep x
        [a1, a2, a3, a4, a5, a6] = a
        [b1, b2, b3, b4, b5, b6] = b
        z = (if c then [y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12] else [a1, a2, a3, a4, a5, a6, b1, b2, b3, b4, b5, b6])
        [z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12] = z
    )
  }}) w4;

fix_vec_12_2 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \(x:t_Fp_2) -> (
     [[a1, a2, a3, a4, a5, a6], [b1, b2, b3, b4, b5, b6]] == fp2_rep x where
        [a,b] = fp2_rep x
        [a1, a2, a3, a4, a5, a6] = a
        [b1, b2, b3, b4, b5, b6] = b
    )
  }}) w4;

map_to_isogenous_E2_impl_ov <- really_custom_verify
  "map_to_isogenous_E2"
  (concat_all [vec_fp2_overrides, fp2_overrides, [recip_sqrt_fp2_9mod16_ov, sgn0x_pty_mont_384x_ov], sqrt_align_fp2_ovs])
  map_to_isogenous_E2_impl_spec
  (goal_num_ite 36
    assume_unsat // TODO
    (do {
      unfolding ["select"];
      simplify (addsimps [fix_vec_12_2, fix_vec_12] fp2_simpset);
      simplify basic_ss; // NOTE: does not work without this...
      w4_unint_z3 ["Fp_2","Fp"];
    }));

// TODO: is the ZxA' rewrite applying?
constants_rewrites <- for [
    {{ fp2_abs [[zero, zero, zero, zero, zero, zero], [ 0xd4c4fffffcec5869, 0x1da3f3eed25bfd79, 0x7fa833c5136fff67, 0x59261433cd540cbd, 0x48450f5f2b84682c, 0x07e05d00bf959233 ]] == Fp_2.neg A' }} // first is 15331660506401101929
  , {{ fp2_abs [[ 0x87ebfffffff9555c, 0x656fffe5da8ffffa, 0x0fd0749345d33ad2, 0xd951e663066576f4, 0xde291a3d41e980d3, 0x0815664c7dfe040d], [ 0x43f5fffffffcaaae, 0x32b7fff2ed47fffd, 0x07e83a49a2e99d69, 0xeca8f3318332bb7a, 0xef148d1ea0f4c069, 0x040ab3263eff0206]] == Z }}
  , {{ fp2_abs [[ 0x019af5f980a3680c, 0x4ed7da0e66063afa, 0x600354723b5d9972, 0x8b2f958b20d09d72, 0x0474938f02d461db, 0x0dcf8b9e0684ab1c], [ 0x486f252db11dd19c, 0x791ffda2c3d18950, 0x5af6c27debf95eb4, 0x73b1fd8f2a929cde, 0xfc59602a1a90b871, 0x08d7daafa8baddb3]] == sqrt_fp2 (fp2_exp Z 3) }}
  , {{ fp2_abs [[ 0x65018f5c28f598eb, 0xe6020417f022d916, 0xd6327313288369c7, 0x622ded8eb447156f, 0xe52a2aee72c2a01f, 0x089812fb8481ffe4], [ 0x2574eb851eb8619f, 0xdba2e97912925604, 0x67e495a909e7a18e, 0xdf2da23b8145b8f7, 0xcf5d3728310ebf6d, 0x11be446236f4c116]] == Fp_2.div (Fp_2.field_unit, fp2_exp Z 3) }}
  // ZxA'
  , {{ fp2_abs [[ 0xe53a000003135242, 0x01080c0fdef80285, 0xe7889edbe340f6bd, 0x0b51375126310601, 0x02d6985717c744ab, 0x1220b4e979ea5467], [ 0xa989fffff9d8b0d2, 0x3b47e7dda4b7faf3, 0xff50678a26dffece, 0xb24c28679aa8197a, 0x908a1ebe5708d058, 0x0fc0ba017f2b2466]] == Fp_2.mul(Z, A') }}
  // B':
  , {{ fp2_abs [[ 0x22ea00000cf89db2, 0x6ec832df71380aa4, 0x6e1b94403db5a66e, 0x75bf3c53a79473ba, 0x3dd3a569412c0a34, 0x125cdb5e74dc4fd1], [ 0x22ea00000cf89db2, 0x6ec832df71380aa4, 0x6e1b94403db5a66e, 0x75bf3c53a79473ba, 0x3dd3a569412c0a34, 0x125cdb5e74dc4fd1]] == B' }}
  // A':
  , {{ fp2_abs [[zero, zero, zero, zero, zero, zero], [ 0xe53a000003135242, 0x01080c0fdef80285, 0xe7889edbe340f6bd, 0x0b51375126310601, 0x02d6985717c744ab, 0x1220b4e979ea5467]] == A' }}
  // Fp_2.field_unit (BLS12_381_Rx.p2):
  , {{ fp2_abs [
            [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
            , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]
          , [zero, zero, zero, zero, zero, zero] ] // a single zero would introduce Prelude.replicate, which would be annoying
          == Fp_2.field_unit }}
  ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

let map_to_isogenous_E2_impl_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE2_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384x_type;
  llvm_precond {{ fp2_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  new_out <- llvm_fresh_var "new_out" POINTonE2_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

// TODO: write high-level spec. The code does not seem to follow the optimized implementations given in the IETF spec. Instead it seems closer to the simplest, high-level spec in the IETF document.

_ <- crucible_llvm_compositional_extract m
  "map_to_isogenous_E2"
  "map_to_isogenous_E2_term"
  (concat_all [vec_fp2_overrides, fp2_overrides, [recip_sqrt_fp2_9mod16_ov, sgn0x_pty_mont_384x_ov], sqrt_align_fp2_ovs])
  true
  map_to_isogenous_E2_impl_extract_spec
  do {
    unfolding ["select"];
    simplify (addsimps [fix_vec_12_2, fix_vec_12] fp2_simpset);
    simplify basic_ss; // NOTE: does not work without this...
    w4_unint_z3 ["Fp_2","Fp"];
  };

// rewrite fp2_exp to F_expt for tractable computation:
fp2_exp_rewrite <- admit_cryptol {{ \x -> fp2_exp x ((`p^^2-9)/16) == F_expt`{n=758} Fp_2 x `((p^^2-9)/16) }};

_ <- custom_prove_cryptol
  {{ \x -> ((affinify E' (POINTonE2_abs (map_to_isogenous_E2_term y))) == (map_to_curve_simple_swu (fp2_abs y)) where y = fp2_normalize x) }}
do {
  unfolding ["map_to_isogenous_E2_term","POINTonE2_abs","select"];
  simplify (addsimp fp2_exp_rewrite empty_ss);
  simplify fp2_simpset;
  //print_goal_nicely;
  (quickcheck 1);
};
