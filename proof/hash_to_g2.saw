/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";

enable_experimental;

let do_prove = false;

include "proof-helpers.saw";
//include "hash_to_field.saw";
include "fp_overrides.saw";
include "fp2_overrides.saw";
include "vect.saw";
//include "x86.saw";
include "curve_operations.saw";
include "curve_operations_e2.saw";
//include "ec_mult.saw";
include "exp.saw";
include "exp2.saw";
include "sgn0.saw";

//let do_prove = true;

import "../spec/Parameters.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE2.cry" (Z A' B' map_to_curve_simple_swu hash_to_field Curve_E' clear_cofactor k1s k2s k3s k4s iso_map);
import "../spec/BLSFieldExtras.cry";
import "../spec/implementation/CurveOperation.cry";
Aux <- cryptol_load "../spec/HashToCurveE2Aux.cry";
import "../spec/implementation/HashToG2.cry";

// Specs

let blst_hash_to_g2_impl_spec msg_len DST_len aug_len = do {
  p_ptr <- llvm_alloc POINTonE2_type;
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  llvm_execute_func [p_ptr, msg_ptr, llvm_term {{ `msg_len : [64] }}, DST_ptr, llvm_term {{ `DST_len : [64] }}, aug_ptr, llvm_term {{ `aug_len : [64] }}];
  llvm_points_to p_ptr (llvm_term {{ (POINTonE2_rep (hash_to_curve_opt_impl (aug#msg, DST))) }});
};

let map_to_isogenous_E2_impl_spec = do {
  out_ptr <- llvm_alloc POINTonE2_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384x_type;
  llvm_precond {{ fp2_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (map_to_curve_E2_prime_impl (fp2_abs u)) }});
};

let isogeny_map_to_E2_impl_alias_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE2_type;
  llvm_precond {{ POINTonE2_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (isogeny_map_to_E2_impl (POINTonE2_abs out)) }} );
};

let map_to_g1_nonnull_spec = do {
  out_ptr <- llvm_alloc POINTonE2_type;
  (u,u_ptr) <- ptr_to_fresh_readonly "u" vec384x_type;
  (v,v_ptr) <- ptr_to_fresh_readonly "v" vec384x_type;
  llvm_precond {{ fp2_invariant u }};
  llvm_precond {{ fp2_invariant v }};
  llvm_execute_func [out_ptr, u_ptr, v_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE2_rep (map_to_g2_impl [fp2_abs u, fp2_abs v]) }});
};

// Assumptions

// TODO: move somewhere else
let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// The optimized version of clear_cofactor given in the IETF spec is correct:
clear_cofactor_with_psi_thm <- custom_prove_cryptol {{ \p -> Aux::clear_cofactor_E2_with_psi p == clear_cofactor p }};

// The SWU map maps to the isogenous curve:
swu_on_curve <- simp_then_admit {{ \u -> is_point_affine Curve_E' (map_to_curve_simple_swu u) == True }};

// the addition of two points on the curve is on the curve:
point_dadd_on_curve <- simp_then_admit {{ \p q -> is_point_projective Curve_E' (point_dadd Fp_2 p q A' False) == if is_point_projective Curve_E' p /\ is_point_projective Curve_E' q then True else apply is_point_projective Curve_E' (point_dadd Fp_2 p q A' False) }};

// If p is a projective point on the isogenous and `affinify p` is point_O, then p's Z coordinate is 0:
on_curve_is_point_O_lemma <- simp_then_admit {{ \p -> is_point_O Curve_E' (affinify Curve_E' p) == if (is_point_projective Curve_E' p /\ ~is_zero Fp_2 p.2) then False else apply is_point_O Curve_E' (affinify Curve_E' p) }};

// The implementation of map_to_curve never returns something of the form (0,0,_) or (_,_,0)
swu_impl_xy_nz <- simp_then_admit {{ \u -> (~((x,y) == (Fp_2.field_zero,Fp_2.field_zero) \/ z == Fp_2.field_zero) where (x,y,z) = map_to_curve_E2_prime_impl u) == True }};

let {{
  affinify_nz (x, y, z) = (Fp_2.mul(lambda2, x), Fp_2.mul(lambda3, y)) where
      lambda = Fp_2.div (Fp_2.field_unit, z)
      lambda2 = Fp_2.sq lambda
      lambda3 = Fp_2.mul(lambda, lambda2)
}};

// This holds because Fp_2.div(x,0) == 0
affinify_lemma <- simp_then_admit {{ \p -> affinify E' p == affinify_nz p }};
affinify_lemma' <- simp_then_admit {{ \p -> affinify Curve_E' p == affinify_nz p }};
// affinify_lemma <- really_custom_prove_cryptol {{ \ (x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (affinify E' p == affinify_nz p where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);
// affinify_lemma <- really_custom_prove_cryptol {{ affinify E' p == affinify_nz p where p = (zero,zero,zero) }} (quickcheck 1);

// Proofs

let {{
  fp2_mul = Fp_2.mul
  fp2_sq = Fp_2.sq
  fp2_add = Fp_2.add
  fp2_div = Fp_2.div
  fp2_zero = Fp_2.field_zero
  fp2_unit = Fp_2.field_unit
  fp2_is_equal = Fp_2.is_equal
  fp2_neg = Fp_2.neg
}};

readability_rewrites <- for [
  {{ \p q -> Fp_2.mul (p,q) == fp2_mul (p,q) }}
, {{ \p q -> Fp_2.add (p,q) == fp2_add (p,q) }}
, {{ \p -> Fp_2.sq p == fp2_sq p }}
, {{ \p -> Fp_2.neg p == fp2_neg p }}
, {{ \p q -> Fp_2.div (p, q) == fp2_div (p, q) }}
, {{ Fp_2.field_zero == fp2_zero }}
, {{ Fp_2.field_unit == fp2_unit }}
, {{ \x y -> Fp_2.is_equal (x,y) == fp2_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

// isogeny_map_to_E2

isogeny_const_rewrites <- for [
    {{ fp2_abs [[ 0x47f671c71ce05e62, 0x06dd57071206393e, 0x7c80cd2af3fd71a2, 0x048103ea9e6cd062, 0xc54516acc8d037f6, 0x13808f550920ea41], [ 0x47f671c71ce05e62, 0x06dd57071206393e, 0x7c80cd2af3fd71a2, 0x048103ea9e6cd062, 0xc54516acc8d037f6, 0x13808f550920ea41]] == Aux::k1s@0 }}
  , {{ fp2_abs [ [zero,zero,zero,zero,zero,zero], [ 0x5fe55555554c71d0, 0x873fffdd236aaaa3, 0x6a6b4619b26ef918, 0x21c2888408874945, 0x2836cda7028cabc5, 0x0ac73310a7fd5abd ]] == Aux::k1s@1 }}
  , {{ fp2_abs [[ 0x0a0c5555555971c3, 0xdb0c00101f9eaaae, 0xb1fb2f941d797997, 0xd3960742ef416e1c, 0xb70040e2c20556f4, 0x149d7861e581393b], [ 0xaff2aaaaaaa638e8, 0x439fffee91b55551, 0xb535a30cd9377c8c, 0x90e144420443a4a2, 0x941b66d3814655e2, 0x0563998853fead5e ]] == Aux::k1s@2 }}
  , {{ fp2_abs [[ 0x40aac71c71c725ed, 0x190955557a84e38e, 0xd817050a8f41abc3, 0xd86485d4c87f6fb1, 0x696eb479f885d059, 0x198e1a74328002d2 ], [zero,zero,zero,zero,zero,zero]] == Aux::k1s@3 }}
  , {{ fp2_abs [[zero,zero,zero,zero,zero,zero], [ 0x1f3affffff13ab97, 0xf25bfc611da3ff3e, 0xca3757cb3819b208, 0x3e6427366f8cec18, 0x03977bc86095b089, 0x04f69db13f39a952 ]] == Aux::k2s@0 }}
  , {{ fp2_abs [[ 0x447600000027552e, 0xdcb8009a43480020, 0x6f7ee9ce4a6e8b59, 0xb10330b7c0a95bc6, 0x6140b1fcfb1e54b7, 0x0381be097f0bb4e1 ], [ 0x7588ffffffd8557d, 0x41f3ff646e0bffdf, 0xf7b1e8d2ac426aca, 0xb3741acd32dbb6f8, 0xe9daf5b9482d581f, 0x167f53e0ba7431b8 ]] == Aux::k2s@1 }}
  , {{ fp2_abs [[ 0x96d8f684bdfc77be, 0xb530e4f43b66d0e2, 0x184a88ff379652fd, 0x57cb23ecfae804e1, 0x0fd2e39eada3eba9, 0x08c8055e31c5d5c3 ], [ 0x96d8f684bdfc77be, 0xb530e4f43b66d0e2, 0x184a88ff379652fd, 0x57cb23ecfae804e1, 0x0fd2e39eada3eba9, 0x08c8055e31c5d5c3 ]] == Aux::k3s@0}}
  , {{ fp2_abs [[zero,zero,zero,zero,zero,zero], [ 0xbf0a71c71c91b406, 0x4d6d55d28b7638fd, 0x9d82f98e5f205aee, 0xa27aa27b1d1a18d5, 0x02c3b2b2d2938e86, 0x0c7d13420b09807f ]] == Aux::k3s@1 }}
  , {{ fp2_abs [[ 0xd7f9555555531c74, 0x21cffff748daaaa8, 0x5a9ad1866c9bbe46, 0x4870a2210221d251, 0x4a0db369c0a32af1, 0x02b1ccc429ff56af ], [ 0xe205aaaaaaac8e37, 0xfcdc000768795556, 0x0c96011a8a1537dd, 0x1c06a963f163406e, 0x010df44c82a881e6, 0x174f45260f808feb ]]  == Aux::k3s@2 }}
  , {{ fp2_abs [[ 0xa470bda12f67f35c, 0xc0fe38e23327b425, 0xc9d3d0f2c6f0678d, 0x1c55c9935b5a982e, 0x27f6c0e2f0746764, 0x117c5e6e28aa9054 ], [zero,zero,zero,zero,zero,zero]]  == Aux::k3s@3 }}
  , {{ fp2_abs [[ 0x0162fffffa765adf, 0x8f7bea480083fb75, 0x561b3c2259e93611, 0x11e19fc1a9c875d5, 0xca713efc00367660, 0x03c6a03d41da1151 ], [ 0x0162fffffa765adf, 0x8f7bea480083fb75, 0x561b3c2259e93611, 0x11e19fc1a9c875d5, 0xca713efc00367660, 0x03c6a03d41da1151 ]] == Aux::k4s@0 }}
  , {{ fp2_abs [[zero,zero,zero,zero,zero,zero], [ 0x5db0fffffd3b02c5, 0xd713f52358ebfdba, 0x5ea60761a84d161a, 0xbb2c75a34ea6c44a, 0x0ac6735921c1119b, 0x0ee3d913bdacfbf6 ]] == Aux::k4s@1 }}
  , {{ fp2_abs [[ 0x66b10000003affc5, 0xcb1400e764ec0030, 0xa73e5eb56fa5d106, 0x8984c913a0fe09a9, 0x11e10afb78ad7f13, 0x05429d0e3e918f52 ], [ 0x534dffffffc4aae6, 0x5397ff174c67ffcf, 0xbff273eb870b251d, 0xdaf2827152870915, 0x393a9cbaca9e2dc3, 0x14be74dbfaee5748 ]] == Aux::k4s@2 }}
] (\ eq -> really_custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

isogeny_invs <- for [
    {{ fp2_invariant [[ 0x47f671c71ce05e62, 0x06dd57071206393e, 0x7c80cd2af3fd71a2, 0x048103ea9e6cd062, 0xc54516acc8d037f6, 0x13808f550920ea41], [ 0x47f671c71ce05e62, 0x06dd57071206393e, 0x7c80cd2af3fd71a2, 0x048103ea9e6cd062, 0xc54516acc8d037f6, 0x13808f550920ea41]] == True }}
  , {{ fp2_invariant [ [zero,zero,zero,zero,zero,zero], [ 0x5fe55555554c71d0, 0x873fffdd236aaaa3, 0x6a6b4619b26ef918, 0x21c2888408874945, 0x2836cda7028cabc5, 0x0ac73310a7fd5abd ]] == True }}
  , {{ fp2_invariant [[ 0x0a0c5555555971c3, 0xdb0c00101f9eaaae, 0xb1fb2f941d797997, 0xd3960742ef416e1c, 0xb70040e2c20556f4, 0x149d7861e581393b], [ 0xaff2aaaaaaa638e8, 0x439fffee91b55551, 0xb535a30cd9377c8c, 0x90e144420443a4a2, 0x941b66d3814655e2, 0x0563998853fead5e ]] == True }}
  , {{ fp2_invariant [[ 0x40aac71c71c725ed, 0x190955557a84e38e, 0xd817050a8f41abc3, 0xd86485d4c87f6fb1, 0x696eb479f885d059, 0x198e1a74328002d2 ], [zero,zero,zero,zero,zero,zero]] == True }}
  , {{ fp2_invariant [[zero,zero,zero,zero,zero,zero], [ 0x1f3affffff13ab97, 0xf25bfc611da3ff3e, 0xca3757cb3819b208, 0x3e6427366f8cec18, 0x03977bc86095b089, 0x04f69db13f39a952 ]] == True }}
  , {{ fp2_invariant [[ 0x447600000027552e, 0xdcb8009a43480020, 0x6f7ee9ce4a6e8b59, 0xb10330b7c0a95bc6, 0x6140b1fcfb1e54b7, 0x0381be097f0bb4e1 ], [ 0x7588ffffffd8557d, 0x41f3ff646e0bffdf, 0xf7b1e8d2ac426aca, 0xb3741acd32dbb6f8, 0xe9daf5b9482d581f, 0x167f53e0ba7431b8 ]] == True }}
  , {{ fp2_invariant [[ 0x96d8f684bdfc77be, 0xb530e4f43b66d0e2, 0x184a88ff379652fd, 0x57cb23ecfae804e1, 0x0fd2e39eada3eba9, 0x08c8055e31c5d5c3 ], [ 0x96d8f684bdfc77be, 0xb530e4f43b66d0e2, 0x184a88ff379652fd, 0x57cb23ecfae804e1, 0x0fd2e39eada3eba9, 0x08c8055e31c5d5c3 ]] == True }}
  , {{ fp2_invariant [[zero,zero,zero,zero,zero,zero], [ 0xbf0a71c71c91b406, 0x4d6d55d28b7638fd, 0x9d82f98e5f205aee, 0xa27aa27b1d1a18d5, 0x02c3b2b2d2938e86, 0x0c7d13420b09807f ]] == True }}
  , {{ fp2_invariant [[ 0xd7f9555555531c74, 0x21cffff748daaaa8, 0x5a9ad1866c9bbe46, 0x4870a2210221d251, 0x4a0db369c0a32af1, 0x02b1ccc429ff56af ], [ 0xe205aaaaaaac8e37, 0xfcdc000768795556, 0x0c96011a8a1537dd, 0x1c06a963f163406e, 0x010df44c82a881e6, 0x174f45260f808feb ]]  == True }}
  , {{ fp2_invariant [[ 0xa470bda12f67f35c, 0xc0fe38e23327b425, 0xc9d3d0f2c6f0678d, 0x1c55c9935b5a982e, 0x27f6c0e2f0746764, 0x117c5e6e28aa9054 ], [zero,zero,zero,zero,zero,zero]]  == True }}
  , {{ fp2_invariant [[ 0x0162fffffa765adf, 0x8f7bea480083fb75, 0x561b3c2259e93611, 0x11e19fc1a9c875d5, 0xca713efc00367660, 0x03c6a03d41da1151 ], [ 0x0162fffffa765adf, 0x8f7bea480083fb75, 0x561b3c2259e93611, 0x11e19fc1a9c875d5, 0xca713efc00367660, 0x03c6a03d41da1151 ]] == True }}
  , {{ fp2_invariant [[zero,zero,zero,zero,zero,zero], [ 0x5db0fffffd3b02c5, 0xd713f52358ebfdba, 0x5ea60761a84d161a, 0xbb2c75a34ea6c44a, 0x0ac6735921c1119b, 0x0ee3d913bdacfbf6 ]] == True }}
  , {{ fp2_invariant [[ 0x66b10000003affc5, 0xcb1400e764ec0030, 0xa73e5eb56fa5d106, 0x8984c913a0fe09a9, 0x11e10afb78ad7f13, 0x05429d0e3e918f52 ], [ 0x534dffffffc4aae6, 0x5397ff174c67ffcf, 0xbff273eb870b251d, 0xdaf2827152870915, 0x393a9cbaca9e2dc3, 0x14be74dbfaee5748 ]] == True }}
] (\ eq -> really_custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

// vim macro:
// vip:s/{/[/g|'<,'>s/}/]/g|'<,'>s/TO_LIMB_T(//g|'<,'>s/),/,/g|'<,'>s/)//g\<CR>vipJ\<CR>

isogeny_algebra_rules <- for [
    {{ \x y -> Fp_2.mul(x,y) == Fp_2.mul(y,x) }}
  , {{ \x y z -> Fp_2.mul(Fp_2.mul(x,y),z) == Fp_2.mul(x, Fp_2.mul(y,z)) }}
  // , {{ \x y z -> Fp_2.mul(x, Fp_2.mul(y,z)) == Fp_2.mul(Fp_2.mul(x,y),z) }}
  , {{ \x y -> Fp_2.add(x,y) == Fp_2.add(y,x) }}
  , {{ \x y z -> Fp_2.add(Fp_2.add(x,y),z) == Fp_2.add(x, Fp_2.add(y,z)) }}
  // , {{ \x y z -> Fp_2.add(x, Fp_2.add(y,z)) == Fp_2.add(Fp_2.add(x,y),z) }}
] admit_cryptol;

isogeny_restiching_rules <- for [
    {{ \(a:[2]Integer) -> ([x,y] == a where [x,y] = a) }}
  , {{ \(a:[2][6][64]) -> ([x,y] == a where [x,y] = a) }}
  , {{ \(a:[6][64]) -> ([a1,a2,a3,a4,a5,a6] == a where [a1,a2,a3,a4,a5,a6] = a) }}
// TODO: how to rewrite equalities involving bvEq? This does not work as it produces ecEq terms
  // , {{ \(a:[6][64]) (b:[6][64]) p -> ((p /\ a1 == b1 /\ a2 == b2 /\ a3 == b3 /\ a4 == b4 /\ a5 == b5 /\ a6 == b6) == (p /\ (a == b)) where [a1,a2,a3,a4,a5,a6] = a; [b1,b2,b3,b4,b5,b6] = b) }}
] (\ eq -> really_custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

// NOTE: this is going nowhere...
let test_simpset = add_cryptol_defs ["ecAtBack","reverse","map","take","drop","append","seq_cong1","gen"] empty_ss;

isogeny_map_to_E2_impl_alias_ov <- really_custom_verify // TODO
  "isogeny_map_to_E2"
  fp2_overrides
  isogeny_map_to_E2_impl_alias_spec
  (goal_num_ite 44 // 44 is the main safety goal
    (do {
      simplify fp2_simpset; // eliminate `abs . rep` etc.
      simplify (addsimps isogeny_invs empty_ss); // NOTE: unecessary
      goal_eval_unint ["Fp_2","Fp","fp2_rep","fp2_abs","fp2_invariant","HashToCurveE2Aux::k1s","HashToCurveE2Aux::k2s","HashToCurveE2Aux::k3s","HashToCurveE2Aux::k4s"]; // TODO: why do we need to keep the kns opaque?
      simplify (addsimps (concat isogeny_restiching_rules isogeny_algebra_rules) empty_ss);
      print_readably;
      w4_unint_z3  ["fp2_rep","Fp_2"]; // TODO: keeping Fp_2 unfolded makes it fail; why?
    })
    (do { // discharge simulation side-conditions:
      unfolding ["POINTonE2_invariant"];
      simplify (addsimps isogeny_invs fp2_simpset);
      w4_unint_z3 ["fp2_rep"];
    })
  );

let {{ // this is the "else" term in the definition of iso_map
  iso_map' (x', y') = (x, y) where
      x_powers = [Fp_2.field_unit] # [Fp_2.mul(x', xi) | xi <- x_powers]
      x_num = F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k1s | xi <- x_powers]
      x_den = Fp_2.add (x_powers@2, F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k2s | xi <- x_powers])
      y_num = F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k3s | xi <- x_powers]
      y_den = Fp_2.add (x_powers@3, F_sum Fp_2 [Fp_2.mul(ki, xi) | ki <- Aux::k4s | xi <- x_powers])
      x = Fp_2.div (x_num, x_den)
      y = Fp_2.mul (y', Fp_2.div(y_num, y_den))
}};

let isogeny_map_to_E2_impl_alias_extract_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE2_type;
  llvm_precond {{ POINTonE2_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  new_out <- llvm_fresh_var "new_out" POINTonE2_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

_ <- crucible_llvm_compositional_extract m
  "isogeny_map_to_E2"
  "isogeny_map_to_E2_term"
  fp2_overrides
  true
  isogeny_map_to_E2_impl_alias_extract_spec
  do {
    simplify fp2_simpset;
    w4_unint_z3 ["fp2_rep"];
  };

// okay:
really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (POINTonE2_abs (isogeny_map_to_E2_term (POINTonE2_rep p)) == isogeny_map_to_E2_impl p where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);

// fails on (0,0,_):
really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> ((p.0,p.1) != (zero,zero) ==> iso_map (affinify E' p) == affinify E' (isogeny_map_to_E2_impl p) where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);

// fails:
really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (((p.0,p.1) != (zero,zero) ==> affinify E' (POINTonE2_abs (isogeny_map_to_E2_term (POINTonE2_rep p))) == iso_map (affinify E' p) where p = ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);

iso_map_main_lemma <- really_custom_prove_cryptol {{ \(x1:[2]) (x2:[2]) (y1:[2]) (y2:[2]) (z1:[2]) (z2:[2]) -> (iso_map' (affinify_nz (POINTonE2_abs p)) == if ~Fp_2.is_equal((POINTonE2_abs p).2, Fp_2.field_zero) then affinify_nz (POINTonE2_abs (isogeny_map_to_E2_term p)) else apply iso_map' (affinify_nz (POINTonE2_abs p)) where p = POINTonE2_rep ([toInteger x1,toInteger x2],[toInteger y1, toInteger y2],[toInteger z1, toInteger z2])) }} (quickcheck 64);
// iso_map_main_lemma <- simp_then_admit {{ \p -> iso_map' (affinify_nz p) == if ~Fp.is_equal(p.2, Fp.field_zero) then affinify_nz (isogeny_map_to_E2_impl p) else apply iso_map' (affinify_nz p) }};

// rewrite rule to get rid of a 12 limbs array that appears in map_to_isogenous_E2_term
// TODO: why does this appear? There's no override using (llvm_array 12 ...)

fix_vec_12 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \(x:t_Fp_2) y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 c -> (
     [[z1, z2, z3, z4, z5, z6], [z7, z8, z9, z10, z11, z12]] == (if c then [[y1, y2, y3, y4, y5, y6], [y7, y8, y9, y10, y11, y12]] else (fp2_rep x)) where
        [a,b] = fp2_rep x
        [a1, a2, a3, a4, a5, a6] = a
        [b1, b2, b3, b4, b5, b6] = b
        z = (if c then [y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12] else [a1, a2, a3, a4, a5, a6, b1, b2, b3, b4, b5, b6])
        [z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12] = z
    )
  }}) w4;

fix_vec_12_2 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \(x:t_Fp_2) -> (
     [[a1, a2, a3, a4, a5, a6], [b1, b2, b3, b4, b5, b6]] == fp2_rep x where
        [a,b] = fp2_rep x
        [a1, a2, a3, a4, a5, a6] = a
        [b1, b2, b3, b4, b5, b6] = b
    )
  }}) w4;

map_to_isogenous_E2_impl_ov <- really_custom_verify
  "map_to_isogenous_E2"
  (concat_all [vec_fp2_overrides, fp2_overrides, [recip_sqrt_fp2_9mod16_ov, sgn0x_pty_mont_384x_ov], sqrt_align_fp2_ovs])
  map_to_isogenous_E2_impl_spec
  (goal_num_ite 36
    assume_unsat // TODO
    (do {
      unfolding ["select"];
      simplify (addsimps [fix_vec_12_2, fix_vec_12] fp2_simpset);
      simplify basic_ss; // NOTE: does not work without this...
      w4_unint_z3 ["Fp_2","Fp"];
    }));

// TODO: is the ZxA' rewrite applying?
constants_rewrites <- for [
    {{ fp2_abs [[zero, zero, zero, zero, zero, zero], [ 0xd4c4fffffcec5869, 0x1da3f3eed25bfd79, 0x7fa833c5136fff67, 0x59261433cd540cbd, 0x48450f5f2b84682c, 0x07e05d00bf959233 ]] == Fp_2.neg A' }} // first is 15331660506401101929
  , {{ fp2_abs [[ 0x87ebfffffff9555c, 0x656fffe5da8ffffa, 0x0fd0749345d33ad2, 0xd951e663066576f4, 0xde291a3d41e980d3, 0x0815664c7dfe040d], [ 0x43f5fffffffcaaae, 0x32b7fff2ed47fffd, 0x07e83a49a2e99d69, 0xeca8f3318332bb7a, 0xef148d1ea0f4c069, 0x040ab3263eff0206]] == Z }}
  , {{ fp2_abs [[ 0x019af5f980a3680c, 0x4ed7da0e66063afa, 0x600354723b5d9972, 0x8b2f958b20d09d72, 0x0474938f02d461db, 0x0dcf8b9e0684ab1c], [ 0x486f252db11dd19c, 0x791ffda2c3d18950, 0x5af6c27debf95eb4, 0x73b1fd8f2a929cde, 0xfc59602a1a90b871, 0x08d7daafa8baddb3]] == sqrt_fp2 (fp2_exp Z 3) }}
  , {{ fp2_abs [[ 0x65018f5c28f598eb, 0xe6020417f022d916, 0xd6327313288369c7, 0x622ded8eb447156f, 0xe52a2aee72c2a01f, 0x089812fb8481ffe4], [ 0x2574eb851eb8619f, 0xdba2e97912925604, 0x67e495a909e7a18e, 0xdf2da23b8145b8f7, 0xcf5d3728310ebf6d, 0x11be446236f4c116]] == Fp_2.div (Fp_2.field_unit, fp2_exp Z 3) }}
  // ZxA'
  , {{ fp2_abs [[ 0xe53a000003135242, 0x01080c0fdef80285, 0xe7889edbe340f6bd, 0x0b51375126310601, 0x02d6985717c744ab, 0x1220b4e979ea5467], [ 0xa989fffff9d8b0d2, 0x3b47e7dda4b7faf3, 0xff50678a26dffece, 0xb24c28679aa8197a, 0x908a1ebe5708d058, 0x0fc0ba017f2b2466]] == Fp_2.mul(Z, A') }}
  // B':
  , {{ fp2_abs [[ 0x22ea00000cf89db2, 0x6ec832df71380aa4, 0x6e1b94403db5a66e, 0x75bf3c53a79473ba, 0x3dd3a569412c0a34, 0x125cdb5e74dc4fd1], [ 0x22ea00000cf89db2, 0x6ec832df71380aa4, 0x6e1b94403db5a66e, 0x75bf3c53a79473ba, 0x3dd3a569412c0a34, 0x125cdb5e74dc4fd1]] == B' }}
  // A':
  , {{ fp2_abs [[zero, zero, zero, zero, zero, zero], [ 0xe53a000003135242, 0x01080c0fdef80285, 0xe7889edbe340f6bd, 0x0b51375126310601, 0x02d6985717c744ab, 0x1220b4e979ea5467]] == A' }}
  // Fp_2.field_unit (BLS12_381_Rx.p2):
  , {{ fp2_abs [
            [ 0x760900000002fffd, 0xebf4000bc40c0002, 0x5f48985753c758ba
            , 0x77ce585370525745, 0x5c071a97a256ec6d, 0x15f65ec3fa80e493]
          , [zero, zero, zero, zero, zero, zero] ] // a single zero would introduce Prelude.replicate, which would be annoying
          == Fp_2.field_unit }}
  ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

let map_to_isogenous_E2_impl_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE2_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384x_type;
  llvm_precond {{ fp2_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  new_out <- llvm_fresh_var "new_out" POINTonE2_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

// TODO: write high-level spec. The code does not seem to follow the optimized implementations given in the IETF spec. Instead it seems closer to the simplest, high-level spec in the IETF document.

_ <- crucible_llvm_compositional_extract m
  "map_to_isogenous_E2"
  "map_to_isogenous_E2_term"
  (concat_all [vec_fp2_overrides, fp2_overrides, [recip_sqrt_fp2_9mod16_ov, sgn0x_pty_mont_384x_ov], sqrt_align_fp2_ovs])
  true
  map_to_isogenous_E2_impl_extract_spec
  do {
    unfolding ["select"];
    simplify (addsimps [fix_vec_12_2, fix_vec_12] fp2_simpset);
    simplify basic_ss; // NOTE: does not work without this...
    w4_unint_z3 ["Fp_2","Fp"];
  };

// rewrite fp2_exp to F_expt for tractable computation:
fp2_exp_rewrite <- admit_cryptol {{ \x -> fp2_exp x ((`p^^2-9)/16) == F_expt`{n=758} Fp_2 x `((p^^2-9)/16) }};

_ <- custom_prove_cryptol
  {{ \x -> ((affinify E' (POINTonE2_abs (map_to_isogenous_E2_term y))) == (map_to_curve_simple_swu (fp2_abs y)) where y = fp2_normalize x) }}
do {
  unfolding ["map_to_isogenous_E2_term","POINTonE2_abs","select"];
  simplify (addsimp fp2_exp_rewrite empty_ss);
  simplify fp2_simpset;
  //print_goal_nicely;
  (quickcheck 1);
};
