/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

enable_experimental;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";
include "exp.saw";

import "../spec/Parameters.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE1_standalone.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";

let do_prove = true;

let blst_hash_to_g1_impl_spec msg_len DST_len aug_len = do {
  p_ptr <- llvm_alloc POINTonE1_type;
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  llvm_execute_func [p_ptr, msg_ptr, llvm_term {{ `msg_len : [64] }}, DST_ptr, llvm_term {{ `DST_len : [64] }}, aug_ptr, llvm_term {{ `aug_len : [64] }}];
  llvm_points_to p_ptr (llvm_term {{ (POINTonE1_rep (hash_to_curve_opt_impl (aug#msg, DST))) }});
};

let map_to_g1_impl_nonnull_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u,u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  (v,v_ptr) <- ptr_to_fresh_readonly "v" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_precond {{ fp_invariant v }};
  llvm_execute_func [out_ptr, u_ptr, v_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_g1_impl [fp_abs u, fp_abs v]) }});
};

let isogeny_map_to_E1_impl_alias_spec = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant out }};
  llvm_execute_func [out_ptr, out_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (isogeny_map_to_E1_impl (POINTonE1_abs out)) }} );
};

let map_to_isogenous_E1_impl_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_curve_simple_swu_impl (fp_abs u)) }});
};

let map_to_g1_nonnull_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u,u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  (v,v_ptr) <- ptr_to_fresh_readonly "v" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_precond {{ fp_invariant v }};
  llvm_execute_func [out_ptr, u_ptr, v_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (map_to_g1_impl [fp_abs u, fp_abs v]) }});
};

// other overrides:

let dbl_n_add_spec n = do {
  (out, out_ptr) <- ptr_to_fresh "out" POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant out /\ POINTonE1_invariant p }};
  llvm_execute_func [out_ptr, llvm_term {{`n:[64]}}, p_ptr];
  llvm_points_to out_ptr (llvm_term {{ POINTonE1_rep (dbl_n_add (POINTonE1_abs out) `n (POINTonE1_abs p)) }});
};

// the code calls this assembly function:
let sgn0x_pty_mont_384_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  p_ptr <- alloc_init_readonly vec384_type (llvm_term {{ vec384_rep (from_Fp `p) }});
  llvm_execute_func [a_ptr, p_ptr, llvm_term {{ 0x89f3fffcfffcfffd }}];
  llvm_return (llvm_term {{ zext`{m=64} [2*(fp_abs a)>`p, (from_Fp (fp_abs a))!0] }});
};

// we also need this:
let recip_sqrt_fp_3mod4_spec = do {
    out_ptr <- crucible_alloc vec384_type;
    (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384_type;
    crucible_precond {{ fp_invariant inp }};
    crucible_execute_func [out_ptr, inp_ptr];
    crucible_points_to out_ptr (crucible_term {{fp_rep (Fp.div (Fp.field_unit, sqrt_fp (fp_abs inp))) }});
    };

sgn0x_pty_mont_384_ov <- admit "sgn0x_pty_mont_384" sgn0x_pty_mont_384_spec;
recip_sqrt_fp_3mod4_ov <- admit "recip_sqrt_fp_3mod4" recip_sqrt_fp_3mod4_spec; // TODO: prove (see exp.saw)

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
  fp_neg = Fp.neg
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p -> Fp.neg p == fp_neg p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

// Assumptions:

let {{
  affinify_nz (x, y, z) = (Fp.mul(lambda2, x), Fp.mul(lambda3, y)) where
      lambda = Fp.div (Fp.field_unit, z)
      lambda2 = Fp.sq lambda
      lambda3 = Fp.mul(lambda, lambda2)
}};

// This holds because Fp.div(x,0) == 0
affinify_lemma <- simp_then_admit {{ \p -> affinify E p == affinify_nz p }};
affinify_lemma' <- simp_then_admit {{ \p -> affinify Curve_E' p == affinify_nz p }};

on_curve_is_point_O_lemma <- simp_then_admit {{ \p -> is_point_O Curve_E' (affinify Curve_E' p) == if (is_point_projective Curve_E' p /\ ~is_zero Fp p.2) then False else apply is_point_O Curve_E' (affinify Curve_E' p) }};

// This is an algebraic fact (TODO: duplicate from exp.saw):
recip_sqrt_fp_algebra_thm <- simp_then_admit {{ \x -> Fp.div (Fp.field_unit, sqrt_fp x) == fp_exp x ((`p-3)/4) }};

// We assume that the optimized implementation of the SWU map given in the IETF spec is correct:
swu_3mod4_correct <- admit_cryptol
  {{ \u -> ((Fp.div(xn,xd), Fp.div(yn,yd)) where (xn, xd, yn, yd) = map_to_curve_simple_swu_3mod4 u)
        == map_to_curve_simple_swu u
  }};

swu_3mod4_impl_on_curve <- simp_then_admit {{ \u -> is_point_projective Curve_E' (map_to_curve_simple_swu_3mod4_impl u) == True }};
swu_impl_on_curve <- simp_then_admit {{ \u -> is_point_projective Curve_E' (map_to_curve_simple_swu_impl u) == True }};

// point_dadd implements add:
dadd_thm <- admit_cryptol (rewrite (cryptol_ss ()) {{ \ p1 p2 -> affinify Curve_E' (point_dadd Fp p1 p2 A' False) == add Curve_E' (affinify Curve_E' p1) (affinify Curve_E' p2) }});

// the addition of two points on the curve is on the curve:
point_dadd_on_curve <- simp_then_admit {{ \p q -> is_point_projective Curve_E' (point_dadd Fp p q A' False) == if is_point_projective Curve_E' p /\ is_point_projective Curve_E' q then True else apply is_point_projective Curve_E' (point_dadd Fp p q A' False) }};

// adding a point to its double can be done with POINTonE1_add (cheaper than dadd) because the double of a point is never equal to the point unless the point is point_O:
add_double_lemma <- admit_cryptol {{ \p -> affinify E (point_add Fp (point_double Fp p) p) == add E (affinify E (point_double Fp p)) (affinify E p) }};

// We will need to prove that some expression involving field Fp operations are
// equivalent.  To do so, we will try to rewrite them to a normal form with the
// following rules. The problem is that we cannot use commutativity or
// associativity, which would make the rewriter loop....

zero_unit_rewrites <- for [ // TODO: here we are cheating: this is true only if we use the (Z p) type
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.mul (Fp.field_zero, p) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_unit) == Fp.field_unit }}
  , {{ \p -> Fp.div (Fp.field_zero, p) == Fp.field_zero }}
] simp_then_admit;

// NOTE: those rules should be sound since we have `Fp.div (x,0) == 0`
push_div_out_rewrites <- for [
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.div (Fp.div (z, x), y) == Fp.div (z, Fp.mul (x,y)) }}
] simp_then_admit;

sum_of_prods_rewrites <- for [
  {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
] simp_then_admit;

unsquare_rewrite <- simp_then_admit {{ \a -> Fp.sq a == Fp.mul (a,a) }};

left_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z) }};

// this one is not included in algebra_simpset below:
right_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (Fp.mul (x, y),z) == Fp.mul (x, Fp.mul (y,z)) }};

simp_div_rewrites <- for [
    {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
  , {{ \x y z -> Fp.div (Fp.mul (y,x), Fp.mul(z,x)) == Fp.div (y,z) }}
  , {{ \x y z -> Fp.div (Fp.mul (x,y), Fp.mul(x,z)) == Fp.div (y,z) }}
] simp_then_admit;

let algebra_simpset = addsimps (concat_all [zero_unit_rewrites, [unsquare_rewrite], [left_fold_mul], sum_of_prods_rewrites, push_div_out_rewrites, simp_div_rewrites]) empty_ss;

// Proofs

// map_to_isogenous_E1

// Rewrite rules for the constants appearing in the C code:
constants_rewrites <- for [
      {{ fp_abs [ 4878930887265312543 , 14750521259635781058 , 8371497156570714123 , 15793066378700994603 , 16433423527091015560 , 32548497384448767 ] == sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) }}
    , {{ fp_abs [ 9830232086645309404 , 1112389714365644829 , 8603885298299447491 , 11361495444721768256 , 5788602283869803809 , 543934104870762216 ] == Z }}
    , {{ [ 9180392817347875192 , 12752300768841235045 , 5424152106454515062 , 3349150446948955809 , 1614784533401171638 , 42236840757897548 ] == fp_rep (Fp.mul (Z, A')) }}
    ,  {{ fp_abs [ 9987108143941419098 , 10981380979105458492 , 12597673232421864513 , 4365728511027233858 , 2514197008840889506 , 336850944957925653 ] == Fp.neg(A') }}
    , {{ fp_abs [ 3415322872136444497 , 9675504606121301699 , 13284745414851768802 , 2873609449387478652 , 2897906769629812789 , 1536947672689614213 ] == A' }}
    , {{ fp_abs [ 18129637713272545760 , 11144507692959411567 , 10108153527111632324 , 9745270364868568433 , 14587922135379007624 , 469008097655535723 ] == B' }}
    , {{ fp_abs [ 8505329371266088957 , 17002214543764226050 , 6865905132761471162 , 8632934651105793861 , 6631298214892334189 , 1582556514881692819 ] == Fp.field_unit }}
  ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

map_to_isogenous_E1_impl_ov <- custom_verify
  "map_to_isogenous_E1"
  (concat_all [fp_overrides, vec_overrides, [recip_sqrt_fp_3mod4_ov , sgn0x_pty_mont_384_ov]])
  map_to_isogenous_E1_impl_spec
  (do {
    goal_num_ite 31
      do { // main safety goal:
        // the only difference between spec and code is the use of `vec_select` and `vec_is_equal`
        unfolding ["map_to_curve_simple_swu_impl", "select", "POINTonE1_rep"];
        simplify (addsimps constants_rewrites fp_simpset);
        let local_rewrites = run (
          for [
                {{ \x y -> Fp.is_equal (x, y) == (x == y) }}
              , {{ Fp.field_zero == 0 }}
          ] (\ eq -> custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4)
        );
        simplify (addsimps local_rewrites empty_ss);
        w4_unint_z3 (concat ["Fp"] ["sqrt_fp","sqrt","fp_rep"]);
      }
      do { // simulation side-conditions
        unfolding ["select"];
        simplify fp_simpset;
        w4;
      };
  });

// Now it remains to prove that the map_to_isogenous_E1 implementation spec is equivalent to the IETF spec

// We need to rewrite `e2`, which is computed differently in the C code compared to the specification
// The implementation seems to test whether tv4=gx1(gxd^3) is square by testing (tv4/sqrt(tv4))^2=tv4
// The spec tests whether gx1=(((1/sqrt(tv4))gx1gxd)^2)gxd=gx1
// The equivalence holds only if gxd is not 0, which holds because gxd=xd^3 where xd not 0 by construction

let {{
  e2_eqn = \gx1 xd -> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul (gx1, gxd))), gxd), gx1)
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq gxd, Fp.mul (gx1, gxd))
    gxd = Fp.mul (xd', Fp.sq xd') // xd^3
    xd' = (if e1 then Fp.mul(Z,A') else xd) // non-zero
    e1 = Fp.is_equal(xd, Fp.field_zero))
}};

e2_lemma <- simp_then_admit (unfold_term ["e2_eqn"] {{ e2_eqn }});

swu_impl_equiv_3mod4_impl <- custom_prove_cryptol {{ \u -> map_to_curve_simple_swu_impl u == map_to_curve_simple_swu_3mod4_impl u }}
  do {
    unfolding ["map_to_curve_simple_swu_impl", "map_to_curve_simple_swu_3mod4_impl", "map_to_curve_simple_swu_3mod4"];
    simplify (cryptol_ss ());
    simplify (addsimp e2_lemma empty_ss);
    simplify (addsimp recip_sqrt_fp_algebra_thm empty_ss);
    w4_unint_z3 (concat ["Fp"] ["sqrt","fp_exp"]);
  };

swu_impl_nz_thm <- custom_prove_cryptol {{ \u -> (Fp.is_equal(z, Fp.field_zero) == False where (_,_,z) = (map_to_curve_simple_swu_3mod4_impl u)) }} w4;

swu_3mod4_abs_thm <- custom_prove_cryptol {{ \u -> affinify Curve_E' (map_to_curve_simple_swu_3mod4_impl u) ==
  ((Fp.div(xn,xd), Fp.div(yn,yd)) where (xn, xd, yn, yd) = map_to_curve_simple_swu_3mod4 u) }}
  do {
    unfolding ["affinify","Curve_E'","is_zero"];
    simplify (addsimp swu_impl_nz_thm basic_ss);
    let rewrites = run (
      for [
          {{ \xn xd ->  Fp.mul (Fp.sq (Fp.div (Fp.field_unit, xd)), Fp.mul (xn,xd)) == Fp.div(xn,xd) }}
        , {{ \y -> Fp.div(y, Fp.field_unit) == y }}
        , {{ \xd y -> Fp.mul (Fp.mul (Fp.div (Fp.field_unit,xd), Fp.sq (Fp.div (Fp.field_unit,xd))), Fp.mul(y, Fp.mul(xd, Fp.sq xd))) == y }}
      ] simp_then_admit // TODO prove 1 and 3
    );
    unfolding ["map_to_curve_simple_swu_3mod4","map_to_curve_simple_swu_3mod4_impl"];
    simplify (addsimps rewrites (cryptol_ss ()));
    w4_unint_z3 ["Fp","fp_exp"];
  };

// putting it all together:
map_to_isogenous_E1_thm <- custom_prove_cryptol {{ \u -> affinify Curve_E' (map_to_curve_simple_swu_impl u) == map_to_curve_simple_swu u }}
  do {
    simplify (addsimps [swu_impl_equiv_3mod4_impl, swu_3mod4_abs_thm, swu_3mod4_correct] empty_ss);
    w4;
  };

// isogeny_map_to_E1

isogeny_map_to_E1_impl_alias_ov <- custom_verify
  "isogeny_map_to_E1"
  fp_overrides
  isogeny_map_to_E1_impl_alias_spec
  (goal_num_ite 176 // 176 is the main safety goal
    (do {
      simplify fp_simpset; // eliminate `abs . rep` etc.
      w4_unint_z3 ["fp_rep"];
    })
    (do { // discharge simulation side-conditions:
      unfolding ["POINTonE1_invariant"];
      simplify fp_simpset;
      w4_unint_z3 ["Fp"];
    })
  );

// First case: Z is zero
isogeny_map_to_E1_impl_thm_z <- custom_prove_cryptol {{ \p -> affinify E (isogeny_map_to_E1_impl p) == if is_zero Fp p.2 then iso_map (affinify Curve_E' p) else apply affinify E (isogeny_map_to_E1_impl p) }}
do {
  let lemma_1 = run ( // TODO; might be hard to prove
    simp_then_admit {{ \p -> affinify E (isogeny_map_to_E1_impl p) == if is_zero Fp p.2 then point_O E else apply affinify E (isogeny_map_to_E1_impl p) }}
  );
  let lemma_2 = run ( // TODO; should be easy to prove but unfolding the right things only is a pain
    simp_then_admit {{ \p -> iso_map (affinify Curve_E' p) == if is_zero Fp p.2 then point_O E else apply iso_map (affinify Curve_E' p) }}
  );
  simplify (addsimps [lemma_1, lemma_2] (cryptol_ss ()));
  w4_unint_z3 ["isogeny_map_to_E1_impl","iso_map","Fp"];
};

// Second case: Z is not zero
let {{
  iso_map_nz (x', y') = (x, y) where
    x_powers = [Fp.field_unit] # [Fp.mul(x', xi) | xi <- x_powers]
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (x_num, x_den)
    y = Fp.mul (y', Fp.div(y_num, y_den))
}};

// We now prove (roughly): iso_map_nz (affinify_nz p) == affinify_nz isogeny_map_to_E1_impl (x, y, z)

let {{
  powers x = ps where
    ps = [Fp.field_unit] # [Fp.mul(x, pi) | pi <- ps]
  zz11 z = (powers (Fp.sq z))@11
  zz15 z = (powers (Fp.sq z))@15
}};

// First, in iso_map_nz, we multiply x_num and x_den by zz11, and y_num and y_den by zz15
let {{
  iso_map_nz_2 (x', y', z') = (x, y) where
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
    (X, Y) = affinify_nz (x', y', z')
}};

rewrite_1 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map_nz (affinify_nz p)  == iso_map_nz_2 p }})
  (do {
    unfolding ["iso_map_nz_2"];
    simplify (addsimps (concat_all [zero_unit_rewrites, simp_div_rewrites]) empty_ss);
    w4_unint_z3 fp_unints;
  });

// now we use the fact that Y = y'/z'^3
let {{
  iso_map_nz_3 (x', y', z') = (x, y) where
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')))
    (X, Y) = affinify_nz (x', y', z')
}};

aux_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \y_num y_den x' y' z' -> (Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z'))) == Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')))
  where (X,Y) = affinify_nz (x', y', z'))
}})
 (do {
    unfolding ["affinify_nz","Curve_E'","apply","is_point_O","same_point_affine","is_zero"];
    simplify algebra_simpset;
    w4_unint_z3 fp_unints;
 });

rewrite_2 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map_nz_2 p == iso_map_nz_3 p }}) (do { unfolding ["iso_map_nz_2"]; simplify (addsimp aux_rewrite empty_ss); w4_unint_z3 fp_unints; });

// now we rewrite x_num, x_den, y_num, and y_den independently:

// Rewrite rule for x_num

let {{
  x_num_times_zz11 x' z' = Fp.mul (x_num, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- (powers X)]
  // here we don't want any divisions:
  x_num_times_zz11_nodiv x' z' = x_num where
    x'_powers = take`{front=12}(powers x')
    zz'_powers = take`{front=12}(powers zz')
    zz' = Fp.sq z'
    x_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k1s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_x_num_times_zz11 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_num_times_zz11_nodiv x z == x_num_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","x_num_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// Now let's prove that the nodiv term is equivalent to the implementation term. Since there are no divisions left, Z3 is able to handle the proof obligations (or is it rewriting in What4?)

let {{
  x_num_times_zz11_impl x' z' = xn where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k1s]) x' where // k0 to k11
      kzzs = map_fp_times_Zz`{n=11} k1s zzs // k0 to k10
}};

x_num_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_num_times_zz11_impl"] {{ \x z -> x_num_times_zz11_impl x z == x_num_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// rewrite rule for x_den

let {{
  x_den_times_zz11 x' z' = Fp.mul (x_den, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_den = Fp.add ((powers X)@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- (powers X)])
  // here we don't want any divisions:
  x_den_times_zz11_nodiv x' z' = x_den where
    x'_powers = take`{front=11}(powers x')
    zz'_powers = tail (take`{front=12}(powers zz'))
    zz' = Fp.sq z'
    x_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k2s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_x_den_times_zz11 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_den_times_zz11_nodiv x z == x_den_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k2s","x_den_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  x_den_times_zz11_impl x' z' = xd where
    zzs = Zz_powers z'
    xd = Fp.mul (xs, last zzs)
    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) x'
    xkzz9 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=10} k2s zzs
}};

x_den_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_den_times_zz11_impl"] {{ \x z -> x_den_times_zz11_impl x z == x_den_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// rewrite rule for y_num

let {{
  y_num_times_zz15 x' y' z' = Fp.mul (y', Fp.mul (y_num, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- (powers X)]
  // here we don't want any divisions:
  y_num_times_zz15_nodiv x' y' z' = Fp.mul (y_num, y') where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k3s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_y_num_times_zz15 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x y z -> y_num_times_zz15_nodiv x y z == y_num_times_zz15 x y z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","y_num_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

let {{
  y_num_times_zz15_impl x' y' z' = Fp.mul (xn, y') where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k3s]) x' where
      kzzs = map_fp_times_Zz`{n=15} k3s zzs
}};

y_num_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_num_times_zz15_impl"] {{ \x y z -> y_num_times_zz15_impl x y z == y_num_times_zz15_nodiv x y z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k3s"]);
    w4;
  });

// rewrite rule for y_den

let {{
  y_den_times_zz15 x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_den = Fp.add ((powers X)@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- (powers X)])
  // here we don't want any divisions:
  y_den_times_zz15_nodiv x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  y_den) where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k4s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_y_den_times_zz15 <- custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> y_den_times_zz15_nodiv x z == y_den_times_zz15 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k4s","y_den_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  y_den_times_zz15_impl x' z' = Fp.mul (Fp.mul (xs, z'), last zzs) where
    zzs = Zz_powers z'
    xs = map_fp ((take`{front=14}kzzs)#[ykzz14]) x'
    ykzz14 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=15} k4s zzs
}};

y_den_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_den_times_zz15_impl"] {{ \x z -> y_den_times_zz15_impl x z == y_den_times_zz15_nodiv x z }}))
  (do {
    unfolding ["y_den_times_zz15_nodiv"];
    goal_eval_unint (concat fp_unints ["k4s"]);
    w4;
  });

to_jacobian_rewrite <- custom_prove_cryptol (rewrite (cryptol_ss ())
  {{
    \xn xd yn yd -> affinify_nz (to_jacobian xn xd yn yd) == (Fp.div (xn, xd), Fp.div(yn, yd))
  }})
  (do {
    unfolding ["to_jacobian", "affinify_nz", "E"];
    simplify algebra_simpset;
    w4_unint_z3 fp_unints;
  });

// finally:
iso_map_main_lemma <- custom_prove_cryptol {{ \p -> iso_map_nz (affinify_nz p) == affinify_nz (isogeny_map_to_E1_impl p) }}
  do {
    simplify (addsimps [rewrite_1, rewrite_2] empty_ss); // rewrite iso_map_nz to iso_map_nz_3
    unfolding ["isogeny_map_to_E1_impl"];
    simplify (addsimps [x_num_rewrite, elim_div_rewrite_x_num_times_zz11, x_den_rewrite, elim_div_rewrite_x_den_times_zz11, y_num_rewrite, elim_div_rewrite_y_num_times_zz15, y_den_rewrite, elim_div_rewrite_y_den_times_zz15, to_jacobian_rewrite] (cryptol_ss ()));
    w4_unint_z3 ["Fp"];
  };

isogeny_map_to_E1_impl_thm_nz <- custom_prove_cryptol {{ \p -> affinify E (isogeny_map_to_E1_impl p) == if (is_point_projective Curve_E' p /\ ~is_zero Fp p.2) then iso_map (affinify Curve_E' p) else apply affinify E (isogeny_map_to_E1_impl p) }}
do {
  let lemma_1 = run (
    custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map p == if is_point_O Curve_E' p then point_O E else iso_map_nz p }}) (w4_unint_z3 ["Fp"])
  );
  simplify (addsimps [lemma_1, on_curve_is_point_O_lemma] empty_ss); // get rid of ite term in `iso_map`
  unfolding ["apply"]; // NOTE: otherwise the next rewrite does not apply to both sides
  let lemma_2 = run (
    custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> affinify E (isogeny_map_to_E1_impl p) == affinify_nz (isogeny_map_to_E1_impl p) }})
    do {
      simplify (addsimp affinify_lemma empty_ss);
      (w4_unint_z3 ["Fp"]);
    }
  );
  simplify (addsimp lemma_2 empty_ss);
  simplify (addsimps [affinify_lemma',iso_map_main_lemma] empty_ss);
  w4_unint_z3 ["Fp"];
};

// Now we tackle `clear_cofactor`

let dbl_n_add_ns = [2,3,9,32,16];

// Here we unfold the recursion in dbl_n_add by hand; we could also have used `goal_eval` to do it for us.
dbl_n_add_unfold_thms <- for [
      {{ \p q -> dbl_n_add p 2 q == point_dadd Fp (point_double Fp (point_double Fp p)) q Fp.field_zero True }}
    , {{ \p q -> dbl_n_add p 3 q == point_dadd Fp (point_double Fp (point_double Fp (point_double Fp p))) q Fp.field_zero True }}
    , {{ \p q -> dbl_n_add p 9 q == point_dadd Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp p))))))))) q Fp.field_zero True }}
    , {{ \p q -> dbl_n_add p 32 q == point_dadd Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp p)))))))))))))))))))))))))))))))) q Fp.field_zero True }}
    , {{ \p q -> dbl_n_add p 16 q == point_dadd Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp (point_double Fp p)))))))))))))))) q Fp.field_zero True }}
  ] simp_then_admit;

let prove_dbl_lemma n = custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p q -> affinify E (dbl_n_add p `n q) == add E (e1_scalar_mult (2^^(`n)) (affinify E p)) (affinify E q) }})
  (do {
    simplify (addsimps (foldr concat [e1_scalar_mult_alg_thms, e1_curve_op_thms, dbl_n_add_unfold_thms] []) (cryptol_ss ()));
    w4_unint_z3 ["Fp","e1_scalar_mult"];
  });

dbl_lemmas <- for dbl_n_add_ns prove_dbl_lemma;

// rewrite mult to e1_scalar_mult because the rewrite rules in ec_mult.saw use e1_scalar_mult:
scalar_mult_lemma <-admit_cryptol (rewrite (cryptol_ss ()) {{ \p -> mult E h_eff p == e1_scalar_mult (to_Fp h_eff) p }});

// now let's prove the multiplication-by-doubling code is correct

mult_by_doubling_thm <- custom_prove_cryptol {{ \p -> affinify E (clear_cofactor_impl p) == clear_cofactor (affinify E p) }}
  (do {
    unfolding ["clear_cofactor_impl","clear_cofactor"];
    simplify (addsimps (concat_all [e1_curve_op_thms, e1_scalar_mult_alg_thms, dbl_lemmas, [scalar_mult_lemma, add_double_lemma]]) (cryptol_ss ()));
    w4_unint_z3 ["E","e1_scalar_mult"];
  });

// now we prove that the C code is equivalent to the _impl specs

let verify_dbl_n_add n = custom_verify "POINTonE1_dbl_n_add" curve_operations_e1_ovs (dbl_n_add_spec n)
  (do {
    simplify (addsimps POINTonE1_thms (cryptol_ss ()));
    goal_num_ite 3
      (do {
        unfolding ["dbl_n_add"];
        simplify remove_higher_order_function_simpset;
        w4_unint_z3 (foldr concat [fp_unints, ec_mult_unints] ["point_double_fp","point_add_fp","POINTonE1_rep","Fp"]);
      })
      z3;
  });

dbl_n_add_ovs <- for dbl_n_add_ns verify_dbl_n_add;

let overrides = foldr concat [curve_operations_e1_ovs, dbl_n_add_ovs] [map_to_isogenous_E1_impl_ov, isogeny_map_to_E1_impl_alias_ov];

map_to_g1_nonnull_ov <- custom_verify "map_to_g1" overrides map_to_g1_nonnull_spec
  (do {
    simplify (addsimps POINTonE1_thms (cryptol_ss ()));
    goal_num_ite 11
      (do { // the main safety goal
        print_goal;
        unfolding ["map_to_g1_impl","clear_cofactor_impl"];
        simplify remove_higher_order_function_simpset;
        w4_unint_z3 ["point_double_fp","point_add_fp","point_dadd_fp","isogeny_map_to_E1_impl","dbl_n_add","map_to_curve_simple_swu_impl"];
      })
      do {
        unfolding ["POINTonE1_invariant"];
        simplify fp_simpset;
        goal_num_ite 2
          (w4_unint_z3 ["Fp","map_to_curve_simple_swu_impl","isogeny_map_to_E1_impl"])
          (w4_unint_z3 (concat ["map_to_curve_simple_swu_impl","isogeny_map_to_E1_impl"] fp_unints));
      };
    });

let aug_len = 48; // aug_len should be 96 or 48
let msg_len = 32;
let DST_len= 8;
let hash_to_field_nelems = [2]; // the values of nelems for which we prove hash_to_field
// TODO:
let do_prove = false;
hash_to_field_ovs <- for hash_to_field_nelems (verify_hash_to_field_for aug_len msg_len DST_len);
let do_prove = true;

// let's get rid of map:
let map_size_2_term = parse_core "\\(f : Integer -> Vec 6 (Vec 64 Bool)) -> \\(y : Vec 2 Integer) -> map Integer (Vec 6 (Vec 64 Bool)) f 2 y";
let map_size_2_eq_term = beta_reduce_term {{ \x -> map_size_2_term (\(y : Integer) -> fp_rep y) x == [fp_rep (x@0), fp_rep (x@1)]}};
map_size_2_thm <- prove_cryptol map_size_2_eq_term [];

hash_to_g1_ov <- custom_verify
  "blst_hash_to_g1"
  (concat [map_to_g1_nonnull_ov] hash_to_field_ovs)
  (blst_hash_to_g1_impl_spec msg_len DST_len aug_len)
  (do {
    unfolding ["hash_to_curve_opt_impl","map"];
    simplify (cryptol_ss ()); // rewrite Cryptol map to SAW-core map
    simplify (addsimps [map_size_2_thm] empty_ss); // get rid of map
    simplify (addsimps fp_rep_thms empty_ss);// simplify (abs . rep)
    w4_unint_z3 ["map_to_g1_impl","hash_to_field"];
  });

// Finally, we put all the pieces together to prove that the C code is equivalent to the high-level spec

final_thm <- custom_prove_cryptol {{ \(msg:[msg_len][8]) (dst:[DST_len][8]) -> affinify E (hash_to_curve_opt_impl (msg,dst)) == hash_to_curve_opt (msg, dst) }}
  do {
    unfolding ["hash_to_curve_opt_impl","map_to_g1_impl"];
    simplify (addsimps [mult_by_doubling_thm, isogeny_map_to_E1_impl_thm_z] (cryptol_ss ()));
    unfolding ["apply"];
    simplify (addsimps [isogeny_map_to_E1_impl_thm_nz,swu_impl_on_curve,point_dadd_on_curve] (cryptol_ss ()));
    simplify (addsimps [dadd_thm,map_to_isogenous_E1_thm] (cryptol_ss ()));
    print_readably;
    w4_unint_z3 (concat fp_unints ["iso_map","map_to_curve_simple_swu","clear_cofactor","hash_to_field"]);
  };
