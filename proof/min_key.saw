/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// TODO: Rename this file

BMPKS <- cryptol_load "../spec/BLSMinimalPublicKeySize.cry";

/*
let do_prove = true;
include "proof-helpers.saw";
*/

let {{
  pubkey_to_point_is_affine_min_key: [48][8] -> Bool
  pubkey_to_point_is_affine_min_key pk =
  // TODO: I had to manually unfold pubkey_to_point here.  Could that cause
  // problems in the proof??
    maybe_cases (uncompress_E1 pk)
      False
      (\y -> is_point_affine E y)
}};

let demo_SkToPk_B_spec = do {
  let n_bytes = 32;
  let bits = 255;
  out_ptr <- llvm_alloc (llvm_array 48 (llvm_int 8));
  scalar_ptr <- crucible_alloc_readonly_aligned 8 (llvm_array n_bytes (llvm_int 8));
  scalar <- crucible_fresh_var "scalar" (llvm_array n_bytes (llvm_int 8));
  crucible_points_to scalar_ptr (crucible_term scalar);
  // extra precondition from POINTonE2_mult_w5
  crucible_precond {{ e1_order BP > scalar_value`{bits,n_bytes} scalar + shift }};
  llvm_precond {{ scalar != zero }};
  llvm_execute_func [out_ptr, scalar_ptr];
  llvm_points_to out_ptr (llvm_term {{ (split`{each=8} (BMPKS::sk_to_pk (drop_join_reverse scalar))) }});
};

affine_E_inv_thm <- test_cryptol (rewrite (cryptol_ss())
  {{ \P1 P2 ->
     (and_core (same_point_affine E (affinify E (POINTonE1_abs P1)) P2)
               (and_core (POINTonE1_invariant P1)
                         (and_core (not_core (is_bad_O_form_E P1))
                                   (is_point_projective E (POINTonE1_abs P1))))) ==
     (same_point_affine E (affinify E (POINTonE1_abs P1)) P2 /\
      ~(is_bad_O_form_E P1) /\
      // TODO: Might need that P1/P2 are not point_O (see
      // hash_to_g2.saw:118).  Can hash to curve even return point_O?
      is_point_affine E P2) }});

BP_is_point_affine_thm <- prove_cryptol
  {{ is_point_affine E BP == True }} [];

e1_scalar_mult_not_bad_O_min_pk_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \P sk -> (same_point_affine
                E
                (affinify E (POINTonE1_abs P))
                (e1_scalar_mult (scalar_value`{255,32} sk) BP)) ==
              ((apply same_point_affine
                      E
                      (affinify E (POINTonE1_abs P))
                      (e1_scalar_mult (scalar_value`{255,32} sk) BP)) &&
                ~(is_bad_O_form_E P)) }});

test_thm_correct_min_pk <- custom_prove_cryptol (rewrite (cryptol_ss())
  {{ \P sk -> (same_point_affine
                E
                (affinify E (POINTonE1_abs P))
                (e1_scalar_mult (scalar_value`{255,32} sk) BP)) ==
              ((apply same_point_affine
                      E
                      (affinify E (POINTonE1_abs P))
                      (e1_scalar_mult (scalar_value`{255,32} sk) BP)) &&
               POINTonE1_invariant P &&
               ~(is_bad_O_form_E P) &&
               is_point_projective E (POINTonE1_abs P)) }})
  do {
    rw_with_1 e1_scalar_mult_not_bad_O_min_pk_thm;
    unfolding ["apply"];
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify (addsimps [ affine_E_inv_thm
                       , affine_inv_affine_rep_e1_thm
                       , e1_scalar_mult_on_curve_thm
                       , BP_is_point_affine_thm ] empty_ss);
    simplify basic_ss;
    simplify (addsimp same_point_affine_E_thm empty_ss);
    print_goal;
    w4_unint_z3 (concat [ "e1_scalar_mult"
                        , "is_bad_O_form_E"
                        , "scalar_value"
                        , "same_point_affine_E" ]
                        e1_unints);
  };

mult_scalar_mult_E_thm <- admit_cryptol
  {{ \b P -> mult E b P == e1_scalar_mult (toInt b) P }};

  // TODO: This feels provable
affinify_affine_E1_thm <- test_cryptol
  {{ \P -> serialize_E1 (fp_abs P.0, fp_abs P.1) ==
           if (fp_abs P.2) ==  Fp.field_unit
           then serialize_E1 (affinify E (POINTonE1_abs P))
           else apply serialize_E1 (fp_abs P.0, fp_abs P.1) }};

if_elim_48_thms <- for at_48_cores
 (\x -> prove_cryptol (rewrite (cryptol_ss())
    {{ \b1 b2 b3 (x1 : [48][8]) (x2 : [48][8]) ->
          (if (and_core (and_core b1 b2) b3)
           then x (if b2 then x1 else x2)
           else (x x1)) == (x x1) }}) []);


demo_SkToPk_B_ov <- custom_verify "demo_SkToPk_B"
  [blst_sk_to_pk_in_g1_ov, blst_p1_compress_projective_ov, blst_p1_compress_affine_ov]
  demo_SkToPk_B_spec
  do {
    unfolding [ "BMPKS::sk_to_pk"
              , "BLSMinimalPublicKeySize::module parameter point_to_pubkey"
              , "BLSMinimalPublicKeySize::module parameter other_curve"
              , "BLSMinimalPublicKeySize::module parameter P"
              , "BLSMinimalPublicKeySize::other_curve"
              , "BLSMinimalPublicKeySize::P"
              , "BLSMinimalPublicKeySize::point_to_pubkey" ];
    simplify (cryptol_ss());
    simplify (addsimp eq_to_same_point_affine_E_thm empty_ss);
    simplify (addsimps [test_thm_correct_min_pk] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    unfolding ["apply"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with_1 O_O_unit_implies_bad_O_form_E;
    unfolding ["apply"];
    // END precond proof
    simplify (addsimps (concat split_join_thms
                               [mult_scalar_mult_E_thm,
                                affinify_affine_E1_thm,
                                fold_scalar_value_thm,
                                serialize_e1_eq_thm])
                       empty_ss);
    simplify (addsimps split_join_thms empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify (addsimps if_elim_48_thms empty_ss);
    simplify (addsimps [unrip_thm_48, serialize_e1_eq_thm] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    unfolding ["apply"];
    rw_with remove_ho_rules;
    simplify (addsimp same_point_affine_E_thm empty_ss);
    print_goal;
    w4_unint_z3 (concat [ "e1_order"
                        , "is_point_projective_E"
                        , "is_bad_O_form_E"
                        , "scalar_value"
                        , "POINTonE2_abs"
                        , "serialize_E1"
                        , "fp_abs"
                        , "e1_scalar_mult"
                        , "same_point_affine_E"
                        , "POINTonE1_invariant" ]
                        e1_unints);
  };

let demo_KeyValidate_B_spec = do {
  (inp, in_ptr) <- ptr_to_fresh_readonly "POINTonE1_Uncompress_in" compressed_E1_rep_type;
  crucible_precond {{ uncompress_E1_imp inp != nothing }};
  // TODO: Maybe drop this precond vv
  crucible_precond {{ ~((inp@0)@1) }};
  llvm_precond {{ pubkey_to_point_is_affine_min_key inp }};
  // TODO: Maybe drop this precond vv
  crucible_precond {{ uncompress_E1_x_fp inp != Fp.field_zero }};
  // TODO: Explain (the library disagrees with spec on treating point_O as on
  // the curve?)
  let uncompressed_inp = {{ uncompress_E1_OK inp }};
  llvm_precond {{ ~(((uncompressed_inp.0) == Fp.field_zero) /\
                    ((uncompressed_inp.1) == Fp.field_zero)) }};
  llvm_execute_func [ in_ptr ];
  // TODO: Postcond
  llvm_return (llvm_term {{ bool_to_limb (BMPKS::KeyValidate (join inp)) }});
};

// TODO: Is this proved somewhere?
uncompress_E1_uncompress_E1_OK_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \x -> uncompress_E1 x ==
           if uncompress_E1_imp x != nothing
           then (True, uncompress_E1_OK x)
           else apply uncompress_E1 x }});

just_e1_thm <- prove_cryptol (rewrite (cryptol_ss()) {{ \(x : AffinePoint t_Fp) -> just x == (True, x) }}) [];

fold_normalize_affine_fp_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> (Fp.normalize P.0, Fp.normalize P.1) ==
           normalize_affine_point Fp P }}) [];

hoist_pair_fp_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \b (x : t_Fp) (y : t_Fp) -> (x, if b then y else x) ==
                                  if b then (x, y) else (x, x) }}) [];

normalize_point_O_E_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ normalize_affine_point Fp (point_O E) == point_O E }}) [];

is_in_g1_impl_min_key_thm <- admit_cryptol
  (rewrite (cryptol_ss())
  {{ \P -> BMPKS::reexport_pubkey_subgroup_check P ==
           if is_point_affine_E P
           then is_in_g1_impl P
           else apply BMPKS::reexport_pubkey_subgroup_check P }});

hoist_POINTonE1_affine_invariant <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c p1 p2 -> POINTonE1_affine_invariant (if c then p1 else p2) ==
                   if c then POINTonE1_affine_invariant p1 else POINTonE1_affine_invariant p2 }})
  ["POINTonE1_affine_invariant"];

inteq_core <- parse_core "intEq";

fold_is_point_O_E_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \x y -> ((inteq_core x Fp.field_zero) /\ (inteq_core y Fp.field_zero)) ==
           is_point_O E (x, y) }}) [];

demo_KeyValidate_B_ov <- custom_verify "demo_KeyValidate_B"
  [ POINTonE1_Uncompress_OK_ov //blst_p1_uncompress_OK_ov
  , POINTonE1_affine_on_curve_ov
  , vec_is_zero_2fp_ov
  , blst_p1_affine_in_g1_ov ]
  demo_KeyValidate_B_spec
  do {
    unfolding [ "BMPKS::KeyValidate"
              , "maybe_cases"
              , "BLSMinimalPublicKeySize::module parameter pubkey_to_point"
              , "BLSMinimalPublicKeySize::module parameter other_curve"
              , "bool_to_limb"
              , "POINTonE1_affine_rep"
              , "pubkey_to_point_is_affine_min_key"
              , "POINTonE1_affine_abs"
              , "BLSMinimalPublicKeySize::other_curve"
              , "BLSMinimalPublicKeySize::pubkey_to_point" ];
    simplify (addsimp is_point_affine_E_thm empty_ss);
    simplify (addsimps [ uncompress_E1_OK_on_curve] empty_ss);
    simplify basic_ss;
    simplify (addsimp is_point_O_E_affine_rev_thm empty_ss);
    simplify (cryptol_ss());
    simplify (addsimps core_rewrites empty_ss);
    simplify (addsimp fp_abs_ite_thm empty_ss);
    simplify fp_simpset;
    simplify (addsimp is_in_g1_impl_min_key_thm empty_ss);
    simplify basic_ss;
    simplify (addsimp is_point_O_E_thm empty_ss);
    simplify (basic_ss);
    simplify (addsimps [ hoist_POINTonE1_affine_rep
                       , affine_inv_affine_rep_e1_thm
                       , hoist_POINTonE1_affine_invariant ] empty_ss);
    simplify (basic_ss);
    simplify (cryptol_ss());
    simplify (addsimps core_rewrites empty_ss);
    simplify (addsimps split_join_thms empty_ss);
    simplify (addsimps [ uncompress_E1_uncompress_E1_OK_thm ] empty_ss);
    goal_num_ite 4
      (do {
        simplify (addsimp just_e1_thm empty_ss);
        simplify (basic_ss);
        simplify (cryptol_ss());
        simplify (addsimps [ fold_normalize_affine_fp_thm
                           , hoist_pair_fp_thm
                           , fold_is_point_O_E_thm
                           , normalize_point_O_E_thm
                           , normalize_uncompress_E1_OK_thm
                           , zero_lt_one_thm
                           , hoist_normalize_affine_fp_thm ] empty_ss);
        unfolding [ "POINTonE1_affine_invariant"
                  , "apply"
                  , "uncompress_E1_imp" ];
        rw_with fp_rep_thms;
        simplify (basic_ss);
        simplify (cryptol_ss());
        rw_with remove_ho_rules;
        (print_goal);
        w4_unint_z3 (concat [ "is_in_g1_impl"
                            , "uncompress_E1_OK"
                            , "is_point_affine_E"
                            , "BMPKS::reexport_pubkey_subgroup_check"
                            , "is_point_O_E"
                            , "is_point_affine_E"
                            , "uncompress_E1"
                            , "POINTonE1_affine_invariant"
                            , "fp_rep"
                            , "uncompress_E1_imp"]
                            BasicVerify_A_unints);
      })
      (do { 
        simplify remove_higher_order_function_simpset;
        unfolding [ "POINTonE1_affine_invariant"
                  , "uncompress_E1_imp" ];
        rw_with fp_rep_thms;
        (print_goal);
        w4_unint_z3 [ "is_in_g1_impl"
                    , "Fp"
                    , "uncompress_E1_OK"
                    , "is_point_affine_E"
                    , "BMPKS::reexport_pubkey_subgroup_check"
                    , "is_point_O_E"
                    , "is_point_affine_E"
                    , "uncompress_E1"
                    , "uncompress_E1_imp"];
        });
  };

let demo_BasicSign_B_spec = do {
  //let DST = {{ "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" }};
  global_alloc_init "demo_DST_B" {{ DST }};
  let msg_len = 32;
  out_ptr <- llvm_alloc (llvm_array 96 (llvm_int 8));
  // SK must be aligned
  SK_ptr <- llvm_alloc_readonly_aligned 8 pow256_type;
  SK <- llvm_fresh_var "SK" pow256_type;
  llvm_points_to SK_ptr (llvm_term SK);
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  // TODO: This precond was the only way I could think of to be able to talk
  // about the relationship between SK and the result of blst_hash_to_g2.  Is
  // there maybe a theorem that would work better?
  llvm_precond {{ e2_order (affinify E' (hash_to_curve_E2_opt_impl (msg,DST))) >
                  scalar_value`{255,32} SK + shift }};
  // TODO: Do I need this precond VV ?
  llvm_precond {{ SK != zero }};
  llvm_execute_func [ out_ptr
                    , SK_ptr
                    , msg_ptr
                    , llvm_term {{ `msg_len : [64] }} ];
  // TODO: Endianness?  (Both for return, and for args to CoreSign)
  // TODO: Postcond
  /*
  llvm_points_to
    out_ptr
    (llvm_term
      {{ split`{each=8} (BMPKS::CoreSign (drop_join_reverse`{255, 32} SK,
                                          msg)) }});
                                          */
};

// TODO: Prove
test_thm_correct'_min_pk <- admit_cryptol (rewrite (cryptol_ss())
  {{ \P sk (x:([32][8],[43][8])) ->
                (same_point_affine
                  E'
                  (affinify E' (POINTonE2_abs P))
                  (e2_scalar_mult (scalar_value`{255,32} sk)
                                  (affinify E' (hash_to_curve_E2_opt_impl x)))) ==
                ((apply same_point_affine
                        E'
                        (affinify E' (POINTonE2_abs P))
                        (e2_scalar_mult (scalar_value`{255,32} sk)
                                        (affinify E' (hash_to_curve_E2_opt_impl x)))) &&
                  POINTonE2_invariant P &&
                  ~(is_bad_O_form_E' P) &&
                  is_point_projective E' (POINTonE2_abs P)) }});

demo_BasicSign_B_ov <- really_custom_verify "demo_BasicSign_B"
  [ hash_to_g2_impl_ov
  , POINTonE2_mult_w5_sk_ov
  , blst_p2_compress_affine_ov
  , blst_p2_compress_projective_ov ]
  demo_BasicSign_B_spec
  do {
    simplify (addsimp eq_to_same_point_affine_E'_thm (cryptol_ss()));
    rw_with POINTonE2_base_thms;
    simplify (addsimps POINTonE2_thms (cryptol_ss()));
    simplify (addsimp eliminate_normalized_args_affinify_thm empty_ss);
    simplify basic_ss;
    simplify (addsimps [test_thm_correct'_min_pk] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with_1 O_O_unit_implies_bad_O_form_E';
    unfolding ["apply", "BLSMinimalPublicKeySize::DST", "is_bad_O_form_E'"];
    simplify basic_ss;
    simplify (cryptol_ss());
    // BEGIN final goal proof
    simplify (addsimps remove_ho_rules empty_ss);
    simplify (addsimps [same_point_affine_E'_thm] empty_ss);
    (print_goal);
    w4_unint_z3 (concat [ "e2_order"
                        , "e2_scalar_mult"
                        , "fp2_abs"
                        , "Fp_2"
                        , "is_point_projective_E'"
                        , "hash_to_curve_E2_opt_impl"
                        , "scalar_value"
                        , "same_point_affine_E'" ]
                        ec_mult_unints );
  };
