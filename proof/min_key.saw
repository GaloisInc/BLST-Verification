/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// TODO: Rename this file

BMPKS <- cryptol_load "../spec/BLSMinimalPublicKeySize.cry";

/*
let do_prove = true;
include "proof-helpers.saw";
*/

let {{
  pubkey_to_point_is_affine_min_key: [48][8] -> Bool
  pubkey_to_point_is_affine_min_key pk =
  // TODO: I had to manually unfold pubkey_to_point here.  Could that cause
  // problems in the proof??
    maybe_cases (uncompress_E1 pk)
      False
      (\y -> is_point_affine E y)
  signature_to_point_is_affine_min_key: [96][8] -> Bool
  signature_to_point_is_affine_min_key sig =
    // TODO: I manually unfolded signature_to_point here.  Could that cause
    // problems?
    maybe_cases (deserialize_E2 sig)
      False
      (\y -> is_point_affine E' y)
}};

let demo_SkToPk_B_spec = do {
  let n_bytes = 32;
  let bits = 255;
  out_ptr <- llvm_alloc (llvm_array 48 (llvm_int 8));
  scalar_ptr <- crucible_alloc_readonly_aligned 8 (llvm_array n_bytes (llvm_int 8));
  scalar <- crucible_fresh_var "scalar" (llvm_array n_bytes (llvm_int 8));
  crucible_points_to scalar_ptr (crucible_term scalar);
  // extra precondition from POINTonE2_mult_w5
  crucible_precond {{ e1_order BP > scalar_value`{bits,n_bytes} scalar + shift }};
  llvm_precond {{ scalar != zero }};
  llvm_execute_func [out_ptr, scalar_ptr];
  llvm_points_to out_ptr (llvm_term {{ (split`{each=8} (BMPKS::sk_to_pk (drop_join_reverse scalar))) }});
};

affine_E_inv_thm <- test_cryptol (rewrite (cryptol_ss())
  {{ \P1 P2 ->
     (and_core (same_point_affine E (affinify E (POINTonE1_abs P1)) P2)
               (and_core (POINTonE1_invariant P1)
                         (and_core (not_core (is_bad_O_form_E P1))
                                   (is_point_projective E (POINTonE1_abs P1))))) ==
     (same_point_affine E (affinify E (POINTonE1_abs P1)) P2 /\
      ~(is_bad_O_form_E P1) /\
      // TODO: Might need that P1/P2 are not point_O (see
      // hash_to_g2.saw:118).  Can hash to curve even return point_O?
      is_point_affine E P2) }});

BP_is_point_affine_thm <- prove_cryptol
  {{ is_point_affine E BP == True }} [];

e1_scalar_mult_not_bad_O_min_pk_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \P sk -> (same_point_affine
                E
                (affinify E (POINTonE1_abs P))
                (e1_scalar_mult (scalar_value`{255,32} sk) BP)) ==
              ((apply same_point_affine
                      E
                      (affinify E (POINTonE1_abs P))
                      (e1_scalar_mult (scalar_value`{255,32} sk) BP)) &&
                ~(is_bad_O_form_E P)) }});

test_thm_correct_min_pk <- custom_prove_cryptol (rewrite (cryptol_ss())
  {{ \P sk -> (same_point_affine
                E
                (affinify E (POINTonE1_abs P))
                (e1_scalar_mult (scalar_value`{255,32} sk) BP)) ==
              ((apply same_point_affine
                      E
                      (affinify E (POINTonE1_abs P))
                      (e1_scalar_mult (scalar_value`{255,32} sk) BP)) &&
               POINTonE1_invariant P &&
               ~(is_bad_O_form_E P) &&
               is_point_projective E (POINTonE1_abs P)) }})
  do {
    rw_with_1 e1_scalar_mult_not_bad_O_min_pk_thm;
    unfolding ["apply"];
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify (addsimps [ affine_E_inv_thm
                       , affine_inv_affine_rep_e1_thm
                       , e1_scalar_mult_on_curve_thm
                       , BP_is_point_affine_thm ] empty_ss);
    simplify basic_ss;
    simplify (addsimp same_point_affine_E_thm empty_ss);
    print_goal;
    w4_unint_z3 (concat [ "e1_scalar_mult"
                        , "is_bad_O_form_E"
                        , "scalar_value"
                        , "same_point_affine_E" ]
                        e1_unints);
  };

mult_scalar_mult_E_thm <- admit_cryptol
  {{ \b P -> mult E b P == e1_scalar_mult (toInt b) P }};

  // TODO: This feels provable
affinify_affine_E1_thm <- test_cryptol
  {{ \P -> serialize_E1 (fp_abs P.0, fp_abs P.1) ==
           if (fp_abs P.2) ==  Fp.field_unit
           then serialize_E1 (affinify E (POINTonE1_abs P))
           else apply serialize_E1 (fp_abs P.0, fp_abs P.1) }};

if_elim_48_thms <- for at_48_cores
 (\x -> prove_cryptol (rewrite (cryptol_ss())
    {{ \b1 b2 b3 (x1 : [48][8]) (x2 : [48][8]) ->
          (if (and_core (and_core b1 b2) b3)
           then x (if b2 then x1 else x2)
           else (x x1)) == (x x1) }}) []);


demo_SkToPk_B_ov <- custom_verify "demo_SkToPk_B"
  [blst_sk_to_pk_in_g1_ov, blst_p1_compress_projective_ov, blst_p1_compress_affine_ov]
  demo_SkToPk_B_spec
  do {
    unfolding [ "BMPKS::sk_to_pk"
              , "BLSMinimalPublicKeySize::module parameter point_to_pubkey"
              , "BLSMinimalPublicKeySize::module parameter other_curve"
              , "BLSMinimalPublicKeySize::module parameter P"
              , "BLSMinimalPublicKeySize::other_curve"
              , "BLSMinimalPublicKeySize::P"
              , "BLSMinimalPublicKeySize::point_to_pubkey" ];
    simplify (cryptol_ss());
    simplify (addsimp eq_to_same_point_affine_E_thm empty_ss);
    simplify (addsimps [test_thm_correct_min_pk] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    unfolding ["apply"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with_1 O_O_unit_implies_bad_O_form_E;
    unfolding ["apply"];
    // END precond proof
    simplify (addsimps (concat split_join_thms
                               [mult_scalar_mult_E_thm,
                                affinify_affine_E1_thm,
                                fold_scalar_value_thm,
                                serialize_e1_eq_thm])
                       empty_ss);
    simplify (addsimps split_join_thms empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify (addsimps if_elim_48_thms empty_ss);
    simplify (addsimps [unrip_thm_48, serialize_e1_eq_thm] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    unfolding ["apply"];
    rw_with remove_ho_rules;
    simplify (addsimp same_point_affine_E_thm empty_ss);
    print_goal;
    w4_unint_z3 (concat [ "e1_order"
                        , "is_point_projective_E"
                        , "is_bad_O_form_E"
                        , "scalar_value"
                        , "POINTonE2_abs"
                        , "serialize_E1"
                        , "fp_abs"
                        , "e1_scalar_mult"
                        , "same_point_affine_E"
                        , "POINTonE1_invariant" ]
                        e1_unints);
  };

let {{
  verify_B_pk_precond: [48][8] -> Bool
  verify_B_pk_precond pk = (uncompress_E1_imp pk != nothing) /\
                           (~((pk@0)@1)) /\
                           pubkey_to_point_is_affine_min_key pk /\
                           (uncompress_E1_x_fp pk != Fp.field_zero) /\
                           ~(((uncompressed_pk.0) == Fp.field_zero) /\
                             ((uncompressed_pk.1) == Fp.field_zero))
    where uncompressed_pk = uncompress_E1_OK pk
}};

let demo_KeyValidate_B_spec = do {
  (inp, in_ptr) <- ptr_to_fresh_readonly "POINTonE1_Uncompress_in" compressed_E1_rep_type;
  crucible_precond {{ verify_B_pk_precond inp }};
  llvm_execute_func [ in_ptr ];
  // TODO: Postcond
  llvm_return (llvm_term {{ bool_to_limb (BMPKS::KeyValidate (join inp)) }});
};

// TODO: Is this proved somewhere?
uncompress_E1_uncompress_E1_OK_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \x -> uncompress_E1 x ==
           if uncompress_E1_imp x != nothing
           then (True, uncompress_E1_OK x)
           else apply uncompress_E1 x }});

just_e1_thm <- prove_cryptol (rewrite (cryptol_ss()) {{ \(x : AffinePoint t_Fp) -> just x == (True, x) }}) [];

fold_normalize_affine_fp_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> (Fp.normalize P.0, Fp.normalize P.1) ==
           normalize_affine_point Fp P }}) [];

hoist_pair_fp_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \b (x : t_Fp) (y : t_Fp) -> (x, if b then y else x) ==
                                  if b then (x, y) else (x, x) }}) [];

normalize_point_O_E_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ normalize_affine_point Fp (point_O E) == point_O E }}) [];

is_in_g1_impl_min_key_thm <- admit_cryptol
  (rewrite (cryptol_ss())
  {{ \P -> BMPKS::reexport_pubkey_subgroup_check P ==
           if is_point_affine_E P
           then is_in_g1_impl P
           else apply BMPKS::reexport_pubkey_subgroup_check P }});

// We assume that pubkey_subgroup_check is equivalent to is_in_g2_impl for
// points on the curve.  This assumption is proved in Bowe "Faster Subgroup
// Checks for BLS12-381".
is_in_g2_impl_min_key_thm <- admit_cryptol
  (rewrite (cryptol_ss())
  {{ \P -> BMPKS::reexport_signature_subgroup_check P ==
           if is_point_affine E' P
           then is_in_g2_impl P
           else apply BMPKS::reexport_signature_subgroup_check P }});


hoist_POINTonE1_affine_invariant <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c p1 p2 -> POINTonE1_affine_invariant (if c then p1 else p2) ==
                   if c then POINTonE1_affine_invariant p1 else POINTonE1_affine_invariant p2 }})
  ["POINTonE1_affine_invariant"];

inteq_core <- parse_core "intEq";

fold_is_point_O_E_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \x y -> ((inteq_core x Fp.field_zero) /\ (inteq_core y Fp.field_zero)) ==
           is_point_O E (x, y) }}) [];

demo_KeyValidate_B_ov <- custom_verify "demo_KeyValidate_B"
  [ POINTonE1_Uncompress_OK_ov //blst_p1_uncompress_OK_ov
  , POINTonE1_affine_on_curve_ov
  , vec_is_zero_2fp_ov
  , blst_p1_affine_in_g1_ov ]
  demo_KeyValidate_B_spec
  do {
    unfolding [ "BMPKS::KeyValidate"
              , "maybe_cases"
              , "BLSMinimalPublicKeySize::module parameter pubkey_to_point"
              , "BLSMinimalPublicKeySize::module parameter other_curve"
              , "bool_to_limb"
              , "POINTonE1_affine_rep"
              , "pubkey_to_point_is_affine_min_key"
              , "POINTonE1_affine_abs"
              , "verify_B_pk_precond"
              , "BLSMinimalPublicKeySize::other_curve"
              , "BLSMinimalPublicKeySize::pubkey_to_point" ];
    simplify (addsimp is_point_affine_E_thm empty_ss);
    simplify (addsimps [ uncompress_E1_OK_on_curve] empty_ss);
    simplify basic_ss;
    simplify (addsimp is_point_O_E_affine_rev_thm empty_ss);
    simplify (cryptol_ss());
    simplify (addsimps core_rewrites empty_ss);
    simplify (addsimp fp_abs_ite_thm empty_ss);
    simplify fp_simpset;
    simplify (addsimp is_in_g1_impl_min_key_thm empty_ss);
    simplify basic_ss;
    simplify (addsimp is_point_O_E_thm empty_ss);
    simplify (basic_ss);
    simplify (addsimps [ hoist_POINTonE1_affine_rep
                       , affine_inv_affine_rep_e1_thm
                       , hoist_POINTonE1_affine_invariant ] empty_ss);
    simplify (basic_ss);
    simplify (cryptol_ss());
    simplify (addsimps core_rewrites empty_ss);
    simplify (addsimps split_join_thms empty_ss);
    simplify (addsimps [ uncompress_E1_uncompress_E1_OK_thm ] empty_ss);
    goal_num_ite 4
      (do {
        simplify (addsimp just_e1_thm empty_ss);
        simplify (basic_ss);
        simplify (cryptol_ss());
        simplify (addsimps [ fold_normalize_affine_fp_thm
                           , hoist_pair_fp_thm
                           , fold_is_point_O_E_thm
                           , normalize_point_O_E_thm
                           , normalize_uncompress_E1_OK_thm
                           , zero_lt_one_thm
                           , hoist_normalize_affine_fp_thm ] empty_ss);
        unfolding [ "POINTonE1_affine_invariant"
                  , "apply"
                  , "uncompress_E1_imp" ];
        rw_with fp_rep_thms;
        simplify (basic_ss);
        simplify (cryptol_ss());
        rw_with remove_ho_rules;
        (print_goal);
        w4_unint_z3 (concat [ "is_in_g1_impl"
                            , "uncompress_E1_OK"
                            , "is_point_affine_E"
                            , "BMPKS::reexport_pubkey_subgroup_check"
                            , "is_point_O_E"
                            , "is_point_affine_E"
                            , "uncompress_E1"
                            , "POINTonE1_affine_invariant"
                            , "fp_rep"
                            , "uncompress_E1_imp"]
                            BasicVerify_A_unints);
      })
      (do { 
        simplify remove_higher_order_function_simpset;
        unfolding [ "POINTonE1_affine_invariant"
                  , "uncompress_E1_imp" ];
        rw_with fp_rep_thms;
        (print_goal);
        w4_unint_z3 [ "is_in_g1_impl"
                    , "Fp"
                    , "uncompress_E1_OK"
                    , "is_point_affine_E"
                    , "BMPKS::reexport_pubkey_subgroup_check"
                    , "is_point_O_E"
                    , "is_point_affine_E"
                    , "uncompress_E1"
                    , "uncompress_E1_imp"];
        });
  };

let demo_BasicSign_B_spec = do {
  //let DST = {{ "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" }};
  global_alloc_init "demo_DST_B" {{ BMPKS::reexport_DST }};
  let msg_len = 32;
  out_ptr <- llvm_alloc (llvm_array 96 (llvm_int 8));
  // SK must be aligned
  SK_ptr <- llvm_alloc_readonly_aligned 8 pow256_type;
  SK <- llvm_fresh_var "SK" pow256_type;
  llvm_points_to SK_ptr (llvm_term SK);
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  // TODO: This precond was the only way I could think of to be able to talk
  // about the relationship between SK and the result of blst_hash_to_g2.  Is
  // there maybe a theorem that would work better?
  llvm_precond {{ e2_order (affinify E' (hash_to_curve_E2_opt_impl (msg,BMPKS::reexport_DST))) >
                  scalar_value`{255,32} SK + shift }};
  // TODO: Do I need this precond VV ?
  llvm_precond {{ SK != zero }};
  llvm_execute_func [ out_ptr
                    , SK_ptr
                    , msg_ptr
                    , llvm_term {{ `msg_len : [64] }} ];
  // TODO: Endianness?  (Both for return, and for args to CoreSign)
  // TODO: Postcond
  llvm_points_to
    out_ptr
    (llvm_term
      {{ split`{each=8} (BMPKS::CoreSign (drop_join_reverse`{255, 32} SK,
                                          msg)) }});
};

affine_inv_min_key_thm <- test_cryptol
  {{ \P1 P2 ->
     (and_core (same_point_affine E' (affinify E' (POINTonE2_abs P1)) P2)
               (and_core (POINTonE2_invariant P1)
                         (and_core (not_core (is_bad_O_form_E' P1))
                                   (is_point_projective E' (POINTonE2_abs P1))))) ==
               (same_point_affine E' (affinify E' (POINTonE2_abs P1)) P2 /\
                ~(is_bad_O_form_E' P1) /\
                is_point_affine E' P2) }};

// TODO: Under what conditions is this true?  Should probably be done over IETF
// spec version rather than _impl version.  Also, see note on
// hash_to_g2.saw:118 to see why this is with is_point_affine rather than
// is_point_projective (it might not be easy to transform goal to
// is_point_projective)
hash_to_g2_on_curve_thm <- admit_cryptol
  {{ \x -> is_point_affine E' (affinify E' (hash_to_curve_E2_opt_impl x)) == True }};

e2_scalar_mult_not_bad_O_min_key_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \P sk (x:([32][8],[43][8])) ->
                (same_point_affine
                  E'
                  (affinify E' (POINTonE2_abs P))
                  (e2_scalar_mult (scalar_value`{255,32} sk)
                                  (affinify E' (hash_to_curve_E2_opt_impl x)))) ==
                ((apply same_point_affine
                        E'
                        (affinify E' (POINTonE2_abs P))
                        (e2_scalar_mult (scalar_value`{255,32} sk)
                                        (affinify E' (hash_to_curve_E2_opt_impl x)))) &&
                  ~(is_bad_O_form_E' P)) }});

test_thm_correct'_min_pk <- custom_prove_cryptol (rewrite (cryptol_ss())
  {{ \P sk (x:([32][8],[43][8])) ->
                (same_point_affine
                  E'
                  (affinify E' (POINTonE2_abs P))
                  (e2_scalar_mult (scalar_value`{255,32} sk)
                                  (affinify E' (hash_to_curve_E2_opt_impl x)))) ==
                ((apply same_point_affine
                        E'
                        (affinify E' (POINTonE2_abs P))
                        (e2_scalar_mult (scalar_value`{255,32} sk)
                                        (affinify E' (hash_to_curve_E2_opt_impl x)))) &&
                  POINTonE2_invariant P &&
                  ~(is_bad_O_form_E' P) &&
                  is_point_projective E' (POINTonE2_abs P)) }})
  do {
    rw_with_1 e2_scalar_mult_not_bad_O_min_key_thm;
    unfolding ["apply"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with POINTonE2_base_thms;
    simplify (addsimps [ affine_inv_min_key_thm
                       , e2_scalar_mult_on_curve_thm
                       , hash_to_g2_on_curve_thm
                       , affine_inv_affine_rep_e2_thm ]
                       empty_ss);
    simplify basic_ss;
    rw_with remove_ho_rules;
    rw_with_1 same_point_affine_E'_thm;
    rw_with_1 and_true_thm;
    print_goal;
    w4_unint_z3 (concat [ "same_point_affine_E'"
                        , "hash_to_curve_E2_opt_impl"
                        , "scalar_value"
                        , "is_bad_O_form_E'" ]
                        []);
  };

let vecEq96 = parse_core "vecEq 96 (Vec 8 Bool) (bvEq 8)";

hoist_if_vecEq96_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \b v1 v2 v3 -> (vecEq96 (if b then v1 else v2) v3) ==
                    (if b then (vecEq96 v1 v3) else (vecEq96 v2 v3)) }}) [];

// TODO: Prove (e1 version already proved)
serialize_e2_affine_thm <-  admit_cryptol (rewrite (cryptol_ss())
  {{ \P -> serialize_E2 (fp2_abs P.0, fp2_abs P.1) ==
           if (POINTonE2_invariant P) /\ (fp2_abs (P.2) == Fp_2.field_unit)
           then serialize_E2 (affinify E' (POINTonE2_abs P))
           else apply serialize_E2 (fp2_abs P.0, fp2_abs P.1) }});

mult_e2_scalar_mult_thm <- admit_cryptol
  {{ \b P -> mult E' b P == e2_scalar_mult (toInt b) P }};

hash_to_curve_e2_arg_expand_thm <- prove_cryptol
  {{ \(x:([32][8],[43][8])) ->
       hash_to_curve_E2_opt_impl x ==
       apply hash_to_curve_E2_opt_impl (([]:[0][8])#x.0, x.1) }} ["hash_to_curve_E2_opt_impl"];

hash_to_curve_e2_impl_thm <- custom_prove_cryptol
  {{ \(x:([32][8],[43][8])) -> HE2::hash_to_curve_opt x == affinify E' (hash_to_curve_E2_opt_impl x) }}
  do {
    simplify (addsimp hash_to_curve_e2_arg_expand_thm empty_ss);
    unfolding ["apply"];
    simplify (addsimp hash_to_curve_E2_opt_impl_equiv_ov empty_ss);
    simplify basic_ss;
    (print_goal);
    w4_unint_z3 ["HashToCurveE2::hash_to_curve_opt"];
  };


demo_BasicSign_B_ov <- custom_verify "demo_BasicSign_B"
  [ hash_to_g2_impl_ov
  , POINTonE2_mult_w5_sk_ov
  , blst_p2_compress_affine_ov
  , blst_p2_compress_projective_ov ]
  demo_BasicSign_B_spec
  do {
    simplify (addsimp eq_to_same_point_affine_E'_thm (cryptol_ss()));
    rw_with POINTonE2_base_thms;
    simplify (addsimps POINTonE2_thms (cryptol_ss()));
    simplify (addsimp eliminate_normalized_args_affinify_thm empty_ss);
    simplify basic_ss;
    simplify (addsimps [test_thm_correct'_min_pk] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with_1 O_O_unit_implies_bad_O_form_E';
    unfolding ["apply", "BLSMinimalPublicKeySize::reexport_DST", "BLSMinimalPublicKeySize::DST", "is_bad_O_form_E'"];
    simplify basic_ss;
    simplify (cryptol_ss());
    // BEGIN final goal proof
    unfolding [ "BMPKS::CoreSign"
              , "BLSMinimalPublicKeySize::module parameter point_to_signature"
              , "BLSMinimalPublicKeySize::module parameter main_curve"
              , "BLSMinimalPublicKeySize::main_curve"
              , "BLSMinimalPublicKeySize::module parameter hash_to_point"
              , "BLSMinimalPublicKeySize::hash_to_point"
              , "BLSMinimalPublicKeySize::point_to_signature"
              , "BLSMinimalPublicKeySize::reexport_DST"
              , "BLSMinimalPublicKeySize::DST" ];
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify (addsimps (concat split_join_thms
                               [ hash_to_curve_e2_impl_thm
                               , fold_scalar_value_thm
                               , serialize_e2_eq_thm
                               , mult_e2_scalar_mult_thm ])
                       empty_ss);
    simplify basic_ss;
    simplify (addsimps [hoist_unrip_96_thm] empty_ss);
    simplify (addsimps [hoist_if_vecEq96_thm] empty_ss);
    simplify (addsimps [serialize_e2_affine_thm] empty_ss);
    simplify (addsimps [serialize_e2_eq_thm] empty_ss);
    simplify (addsimps [hoist_if_vecEq96_thm] empty_ss);
    simplify (addsimps [serialize_e2_eq_thm] empty_ss);
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify (addsimps remove_ho_rules empty_ss);
    simplify (addsimps [same_point_affine_E'_thm] empty_ss);
    (print_goal);
    w4_unint_z3 (concat [ "e2_order"
                        , "e2_scalar_mult"
                        , "fp2_abs"
                        , "Fp_2"
                        , "is_point_projective_E'"
                        , "hash_to_curve_E2_opt_impl"
                        , "scalar_value"
                        , "same_point_affine_E'" ]
                        [] );
  };

let verify_B_sig_preconds sig = do {
  crucible_precond {{ uncompress_E2_imp sig != nothing }};
  // TODO: Maybe drop this precond vv
  crucible_precond {{ ~((sig@0)@1) }};
  llvm_precond {{ ~(is_point_O E' (uncompress_E2_OK sig)) }};
  llvm_precond {{ signature_to_point_is_affine_min_key sig }};
};

let demo_BasicVerify_B_spec = do {
  global_alloc_init "demo_DST_B" {{ BMPKS::reexport_DST }};
  (sig, sig_ptr) <- ptr_to_fresh_readonly "sig" compressed_E2_rep_type;
  (pk, pk_ptr) <- ptr_to_fresh_readonly "pk" compressed_E1_rep_type;
  let message_len = 32;
  (message, message_ptr) <-
      ptr_to_fresh_readonly "message" (llvm_array message_len (llvm_int 8));
  verify_B_sig_preconds sig;
  llvm_precond {{ verify_B_pk_precond pk }};
  // preconditions
  llvm_execute_func [ sig_ptr
                    , pk_ptr
                    , message_ptr
                    , llvm_term {{ `message_len : [64] }} ];
  llvm_return (llvm_term
      {{ bool_to_limb (BMPKS::CoreVerify (join pk) message (join sig)) }});
};

// TODO: Prove
// TODO: Try new is_point_O assumption based on CoreVerify precondition instead
is_point_O_E_KeyValidate_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \pk -> is_point_O E (uncompress_E1_OK pk) ==
            if BMPKS::KeyValidate (join pk) 
            then False
            else apply is_point_O E (uncompress_E1_OK pk) }});

hoist_is_point_O_E_thm <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c p1 p2 -> is_point_O E (if c then p1 else p2) ==
                   if c then is_point_O E p1 else is_point_O E p2 }}) [];

fold_POINTonE1_affine_abs_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> ((fp_abs P.0), (fp_abs P.1)) == POINTonE1_affine_abs P }}) [];

hoist_POINTonE1_affine_abs_thm <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c p1 p2 -> POINTonE1_affine_abs (if c then p1 else p2) ==
                   if c then POINTonE1_affine_abs p1 else POINTonE1_affine_abs p2 }})
  ["POINTonE1_affine_abs"];

is_point_O_E'_affine_rev_point_thm <- prove_cryptol
  {{ \P -> (Fp_2.is_equal (P.0, Fp_2.field_zero) /\
            Fp_2.is_equal (P.1, Fp_2.field_zero)) ==
           is_point_O E' P }} [];

let {{
  core_verify_pk_in_g1 pk sig msg dst = Fp_12.is_equal(c1, c2) where
      c1 = bls_ate_pairing pk (HE2::hash_to_curve_opt (msg, dst))
      c2 = bls_ate_pairing BP sig
}};

// This assumption is justified by Note 1 in proof/pairing.saw
core_verify_pk_in_g1_impl_thm <- admit_cryptol {{ \pk sig msg dst -> core_verify_pk_in_g1_impl pk sig msg dst [] == core_verify_pk_in_g1 pk sig msg dst }};

blst_core_verify_pk_in_g1_ov <-  admit
  "blst_core_verify_pk_in_g1"
  (blst_core_verify_pk_in_g1_null_aug_spec 32 43);

// TODO: If proofs using this unints break it's because I changed it for
// aggregate verify B.
let BasicVerify_B_unints = (concat [
  "HashToCurveE2::hash_to_curve_opt"
, "BLSMinimalPublicKeySize::KeyValidate"
, "POINTonE1_affine_abs"
, "POINTonE1_affine_invariant"
, "POINTonE1_affine_rep"
, "POINTonE2_affine_abs"
, "POINTonE2_affine_invariant"
, "POINTonE2_affine_rep"
, "bls_ate_pairing"
, "deserialize_E2"
, "fp_invariant"
, "fp_rep"
//, "fp2_abs"
, "is_in_g1_impl"
, "is_in_g2_impl"
, "is_point_affine_E"
, "is_point_affine_E'"
, "is_square_fp"
, "is_square_fp2"
, "nothing"
, "pubkey_subgroup_check"
, "pubkey_to_point_is_affine_min_key"
, "sign_F_p"
, "sign_F_p_2"
, "BLSMinimalPublicKeySize::reexport_signature_subgroup_check"
, "signature_to_point_is_affine_min_key"
, "sqrt_fp"
, "sqrt_fp2"
, "uncompress_E1"
, "uncompress_E1_OK"
, "uncompress_E1_imp"
, "uncompress_E1_x"
, "uncompress_E1_x_fp"
, "uncompress_E1_y2"
, "uncompress_E2_OK"
, "uncompress_E2_imp"
, "uncompress_E2_x"
, "uncompress_E2_x_fp"
, "uncompress_E2_y2"
] []); //(concat ec_mult_unints e2_unints));

demo_BasicVerify_B_ov <- custom_verify "demo_BasicVerify_B"
  [ POINTonE1_Uncompress_OK_ov // blst_p1_uncompress_OK_ov
  , POINTonE2_affine_on_curve_ov
  , vec_is_zero_2fp_ov
  , blst_p1_affine_in_g1_ov
  , blst_p2_uncompress_OK_ov
  , POINTonE1_affine_on_curve_ov
  , vec_is_zero_2fp2_ov
  , blst_p2_affine_in_g2_ov
  , demo_KeyValidate_B_ov
  , blst_core_verify_pk_in_g1_ov ]
  demo_BasicVerify_B_spec
  do {
    (goal_num_ite 7
      (do {
        // Postcondition proof
        unfolding [ "BMPKS::CoreVerify"
                  , "BLSMinimalPublicKeySize::module parameter signature_to_point"
                  , "signature_to_point_is_affine_min_key"
                  , "maybe_cases"
                  //, "POINTonE1_affine_rep"
                  , "BLSMinimalPublicKeySize::signature_to_point"
                  //, "POINTonE1_affine_abs"
                  //, "POINTonE2_affine_abs"
                  , "BLSMinimalPublicKeySize::module parameter pubkey_to_point"
                  , "BLSMinimalPublicKeySize::pubkey_to_point"
                  , "blst_core_verify_pk_in_g1_error_precond"];
        rw_with_1 core_verify_pk_in_g1_impl_thm;
        unfolding [ "core_verify_pk_in_g1"
                  , "BLSMinimalPublicKeySize::module parameter pairing"
                  , "BLSMinimalPublicKeySize::pairing"
                  , "BLSMinimalPublicKeySize::module parameter hash_to_point"
                  , "BLSMinimalPublicKeySize::hash_to_point"
                  , "BLSMinimalPublicKeySize::DST"
                  , "BLSMinimalPublicKeySize::module parameter P"
                  , "BLSMinimalPublicKeySize::P" ];
        rw_with split_join_thms;
        rw_with [ deserialize_E2_uncompress_E2_OK_thm
                , POINTonE2_affine_abs_rep_thm
                , is_in_g2_impl_min_key_thm];
        unfolding ["apply"];
        simplify basic_ss;
        simplify (cryptol_ss());
        simplify fp2_simpset;
        simplify (addsimps core_rewrites empty_ss);
        //rw_with_1 squash_at_0_thm;
        rw_with [ fold_normalize_affine_fp2_thm
                , intLe_sym_thm
                , normalize_uncompress_E2_OK_thm ];
        simplify basic_ss;
        simplify (cryptol_ss());
        unfolding ["POINTonE2_affine_rep"];
        rw_with fp2_rep_thms;
        rw_with [ normalize_uncompress_E2_OK_thm
                , intLe_sym_thm
                , zero_lt_one_thm
                , is_point_O_E'_affine_rev_point_thm
                , uncompress_E1_OK_on_curve ];
        simplify basic_ss;
        simplify (cryptol_ss());
        rw_with_1 is_point_O_E'_affine_rev_point_thm;
        rw_with [ fold_normalize_affine_fp2_thm
                , uncompress_E1_uncompress_E1_OK_thm
                , is_point_O_E'_affine_rev_thm
                , deserialize_E2_uncompress_E2_OK_thm
                , normalize_uncompress_E2_OK_thm ];
        rw_with [ POINTonE1_affine_abs_rep_thm
                , hoist_normalize_affine_fp_thm
                , hoist_normalize_affine_fp2_thm
                , normalize_uncompress_E2_OK_thm
                , normalize_uncompress_E1_OK_thm ];
        rw_with remove_ho_rules;
        print_readably;
        //print_goal;
        w4_unint_z3 BasicVerify_B_unints;
      })
      (do {
        // Precondition proof(s)
        unfolding [ "POINTonE2_affine_abs"
                  , "uncompress_E1_imp"
                  , "POINTonE1_affine_abs"
                  , "blst_core_verify_pk_in_g1_error_precond"
                  , "verify_B_pk_precond"
                  ];
        simplify basic_ss;
        simplify (cryptol_ss());
        simplify basic_ss;
        rw_with [ hoist_POINTonE1_affine_rep
                , hoist_POINTonE1_affine_invariant
                , hoist_POINTonE2_affine_rep
                , hoist_POINTonE2_affine_invariant
                , affine_inv_affine_rep_e2_thm
                , zero_lt_one_thm
                , intLe_sym_thm
                , affine_inv_affine_rep_e1_thm ];
        rw_with structural_rewrites;
        simplify basic_ss;
        rw_with [ fold_POINTonE1_affine_invariant
                , fold_POINTonE2_affine_invariant
                , hoist_POINTonE1_affine_invariant
                , hoist_POINTonE2_affine_invariant
                , affine_inv_affine_rep_e2_thm
                , fold_POINTonE1_affine_abs_thm
                , hoist_POINTonE1_affine_abs_thm
                , hoist_is_point_O_E_thm
                , POINTonE1_affine_abs_rep_thm
                , is_point_O_E_KeyValidate_thm
                , normalize_uncompress_E1_OK_thm
                , affine_inv_affine_rep_e1_thm ];
        //rw_with_1 is_point_O_affine_rev_thm;
        simplify basic_ss;
        simplify (cryptol_ss());
        rw_with remove_ho_rules;
        // END Precondition proofs
        print_goal;
        w4_unint_z3 BasicVerify_B_unints;
      }));
  };
