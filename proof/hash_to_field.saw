/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

///////////////////////////////////////////////////////////////////////////////
// Imports
///////////////////////////////////////////////////////////////////////////////

include "helpers.saw";
include "list_utils.saw";
include "types.saw";
m <- llvm_load_module "../build/llvm/libblst.a.bc";

let do_prove = true;
include "proof-helpers.saw";
include "sha_overrides.saw";

///////////////////////////////////////////////////////////////////////////////
// Specifications
///////////////////////////////////////////////////////////////////////////////

import "../spec/ExpandMessage.cry";

let expand_message_spec len_in_bytes aug_len msg_len DST_len = do {
  bytes_ptr <- crucible_alloc_aligned 8 (llvm_array len_in_bytes (llvm_int 8));
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  crucible_execute_func [bytes_ptr, crucible_term {{ `len_in_bytes : [64] }}, aug_ptr, crucible_term {{ `aug_len : [64] }}, msg_ptr, crucible_term {{ `msg_len : [64] }}, DST_ptr, crucible_term {{ `DST_len : [64] }}];
  crucible_points_to bytes_ptr (crucible_term {{ expand_message_xmd`{len_in_bytes=len_in_bytes} (aug # msg) DST }});
};

import "../spec/hash_to_field_impl.cry";

let hash_to_field_spec nelems aug_len msg_len DST_len = do {
  elems_ptr <- crucible_alloc (llvm_array nelems vec384_type);
  (aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (DST, DST_ptr) <- ptr_to_fresh_readonly "DST" (llvm_array DST_len (llvm_int 8));
  crucible_execute_func [elems_ptr, crucible_term {{ `nelems : [64] }}, aug_ptr, crucible_term {{ `aug_len : [64] }}, msg_ptr, crucible_term {{ `msg_len : [64] }}, DST_ptr, crucible_term {{ `DST_len : [64] }}];
  crucible_points_to elems_ptr (crucible_term {{ hash_to_field_rep`{nelems=nelems} (aug#msg) DST }});
};

let redc_mont_384_spec = do {
  ret_ptr <- crucible_alloc vec384_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec768_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384_type;
  crucible_precond {{ b == vec_rep bv_p }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr, crucible_term {{bv_p0}}];
  crucible_points_to ret_ptr (crucible_term {{ redc_rep a }});
};

let mul_mont_384_alias_spec = do {
  (ret, ret_ptr) <- ptr_to_fresh "ret" vec384_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  crucible_precond {{ b == RRR_rep }}; // TODO remove, just a check
  (p, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  crucible_precond {{ p == vec_rep bv_p }};
  crucible_execute_func [ret_ptr, ret_ptr, b_ptr, p_ptr, crucible_term {{bv_p0}}];
  crucible_points_to ret_ptr (crucible_term {{ mul_mont_rep ret b }});
};

let limbs_from_be_bytes_spec nlimbs = do {
  let nbytes = eval_size {| nlimbs*8 |};
  ret_p <- crucible_alloc (llvm_array nlimbs limb_type);
  (inx, in_ptr) <- ptr_to_fresh_readonly "limbs_from_be_bytes_in" (llvm_array nbytes (llvm_int 8)); // "in" is a keyword
  crucible_execute_func [ret_p, in_ptr, crucible_term {{`nbytes:[64]}}];
  crucible_points_to ret_p (crucible_term {{limbs_from_be_bytes_rep`{nlimbs} inx}});
  };


///////////////////////////////////////////////////////////////////////////////
// Proofs
///////////////////////////////////////////////////////////////////////////////

// we assume that assembly functions are correct:
mul_mont_384_ov <- crucible_llvm_unsafe_assume_spec m "mulx_mont_384" mul_mont_384_alias_spec;
redc_mont_384_ov <- crucible_llvm_unsafe_assume_spec m "redcx_mont_384" redc_mont_384_spec;

// we verify limbs_from_be_bytes (not strictly needed):
limbs_from_be_bytes_ov <- verify "limbs_from_be_bytes" [] (limbs_from_be_bytes_spec 8);

let verify_hash_to_field_for aug_len msg_len DST_len nelems = do {
  let L = 64; // sizeof(vec384) + 128/8 = 48 + 16
  let len_in_bytes = eval_size {| L*nelems |};
  block_data_order_ovs <- make_block_data_order_ovs [aug_len, msg_len, eval_size {| (33+DST_len+1+9)+63 |}]; // last size is b_i_blocks from hash_to_field.c
  expand_message_ov <- custom_verify "expand_message_xmd" (concat bcopy_ovs (concat block_data_order_ovs [blst_sha256_emit_ov, blst_sha256_hcopy_ov])) (expand_message_spec len_in_bytes aug_len msg_len DST_len) abc; // z3 takes forever, so we use abc
  let overrides = [expand_message_ov, limbs_from_be_bytes_ov, redc_mont_384_ov, mul_mont_384_ov]; // NOTE: limbs_from_be_bytes is not needed but doesn't hurt
  let unints = ["redc_rep", "mul_mont_rep", "expand_message_xmd"];
  r <- verify_unint "hash_to_field" overrides unints (hash_to_field_spec nelems aug_len msg_len DST_len);
  return r;
};

let aug_len = 48; // aug_len should be 96 or 48
let msg_len = 32;
let DST_len= 8;
let hash_to_field_nelems = [1,2,4]; // the values of nelems for which we prove hash_to_field

// We prove that hash_to_field satisfies its low-level spec (hash_to_field_rep):
hash_to_field_ovs <- for hash_to_field_nelems (verify_hash_to_field_for aug_len msg_len DST_len);

import "../spec/HashToCurveE1.cry";
import "../spec/Parameters.cry";

// hash_to_field_rep computes the Montgomery representation of what hash_to_field computes. This is the refinement property:
let refinement count msg_len dst_len = {{
  \(msg:[msg_len][8]) (dst:[dst_len][8]) ->
    [Fp.mul(x, bv_R) | x <- (hash_to_field`{count=count} msg dst)] ==
    [vec384_abs x | x <- (hash_to_field_rep`{nelems=count} msg dst)]
}};

//prove_print (quickcheck 10) (refinement 1 32 8); // this has to compute hash_to_field and is slow

// to prove the refinement we need a lemma that we will assume is true:
let slice = parse_core "\\(x : Vec 512 Bool) -> slice Bool 128 384 0 x";
let lemma = {{
  // NOTE: in hash_to_field.c, elem has 768 bits, but only the first 512 are non-zero
  \(x:[512]) -> Fp.mul(slice (x % `p), bv_R)
    == mul_mont_p_bv (redc_p_bv (zext x)) (vec384_abs RRR_rep)
}};
assumed_lemma_simplified <-
  prove_print (do { assume_unsat;}) // too hard for the solvers that bitblast (needs some algebra)
  (rewrite (cryptol_ss ()) lemma);

// Now we can prove the refinement property:
let prove_refinement msg_len dst_len count =
  prove_print (do {
      unfolding ["hash_to_field", "hash_to_field_rep", "mul_mont_rep", "redc_rep", "limbs_from_be_bytes_rep"];
      unfolding ["module parameter base_to_F", "base_to_F"]; // goal_eval_unint fails without this...
      goal_eval_unint ["expand_message", "redc_p_bv", "mul_mont_p_bv", "Fp", "bv_R", "RRR_rep"]; // put goal in a form in which the lemma can be applied
      simplify (addsimp assumed_lemma_simplified (empty_ss)); // apply the lemma
      w4_unint_z3 ["expand_message_xmd"];
      })
      (refinement count msg_len dst_len);

print "proving refinement:";
for hash_to_field_nelems (prove_refinement msg_len DST_len);
