/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

/* NOTE: used in pairing.c:
  mul_by_xy00z0_fp12 [Done],
  sqr_fp12 [Done],
  conjugate_fp12, [Done]
  mul_fp12, [Done]
  cyclotomic_sqr_fp12, [Done, except for some subroutines]
  frobenius_map_fp12 [Done]
  inverse_fp12
*/

import "../spec/Parameters.cry";
import "../spec/ExtensionField.cry";
import "../spec/Frobenius.cry";
import "../spec/implementation/Field.cry";
import "../spec/implementation/Fp12.cry";

let vec384fp4_type = llvm_array 2 vec384x_type; // only used in this file

///////////////////////////////////////////////////////////////////////////////
// Specifications
///////////////////////////////////////////////////////////////////////////////



let sqr_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.sq (fp12_abs a)) }});
};

let sqr_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.sq (fp12_abs a)) }});
};

let mul_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_precond {{ fp12_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs b)) }});
};

let mul_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_precond {{ fp12_invariant b }};
  crucible_execute_func [ret_ptr, ret_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs b)) }});
};

let conjugate_fp12_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [a_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp12_rep (fp12_conjugate (fp12_abs a)) }});
};


let frobenius_map_fp12_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term
    (if eval_bool {{`n == 0x1}}
     then {{ fp12_rep (fp12_frobenius (fp12_abs a)) }}
     else if eval_bool {{ `n == 0x2 }}
     then {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_abs a))) }}
     else {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_frobenius (fp12_abs a)))) }} ));
};

let frobenius_map_fp12_alias_spec n = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term
    (if eval_bool {{`n == 0x1}}
     then {{ fp12_rep (fp12_frobenius (fp12_abs a)) }}
     else if eval_bool {{ `n == 0x2 }}
     then {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_abs a))) }}
     else {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_frobenius (fp12_abs a)))) }} ));
};


// The cyclotomic square returns the square of its input PROVIDED that input is in the
// "cyclotomic subgroup" -- that is, its, `p^4-p^2+1` power is 1.
let cyclotomic_sqr_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (cyclotomic_sqr_fp12 (fp12_abs a)) }});
};

let cyclotomic_sqr_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (cyclotomic_sqr_fp12 (fp12_abs a)) }});
};


let mul_by_xy00z0_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  (xyz, xyz_ptr) <- ptr_to_fresh_readonly "xyz" vec384fp6_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_precond {{ fp6_invariant xyz }};
  crucible_execute_func [ret_ptr, a_ptr, xyz_ptr];
  crucible_points_to ret_ptr (crucible_term
    {{ fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs (xy00z0_expander xyz))) }});
  };

let mul_by_xy00z0_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "a" vec384fp12_type;
  (xyz, xyz_ptr) <- ptr_to_fresh_readonly "xyz" vec384fp6_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_precond {{ fp6_invariant xyz }};
  crucible_execute_func [ret_ptr, ret_ptr, xyz_ptr];
  crucible_points_to ret_ptr (crucible_term
    {{ fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs (xy00z0_expander xyz))) }});
  };

// not done

let inverse_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term
   {{ fp12_rep (Fp_12.div (Fp_12.field_unit, fp12_abs a)) }});
};


// non-top-level specifications

let mul_by_1_plus_i_mod_384x_spec = do {
  ret_ptr <- crucible_alloc vec384x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  // (p, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_global "BLS12_381_P"];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs a)) }});
};

let mul_by_1_plus_i_mod_384x_alias_ret_a_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384x_type;
  // (p, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_global "BLS12_381_P"];
  new_ret <- crucible_fresh_var "new_ret" vec384x_type;
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs a)) }});
};

let frobenius_map_fp2_spec n = do {
  ret_ptr <- crucible_alloc vec384x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (nest fp2_frobenius (fp2_abs a) `n) }} );
};

let frobenius_map_fp2_alias_spec n = do {
  (a, ret_ptr) <- ptr_to_fresh "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (nest fp2_frobenius (fp2_abs a) `n) }} );
};

let frobenius_map_fp6_spec n = do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (nest fp6_frobenius (fp6_abs a) `n) }} );
};

let frobenius_map_fp6_alias_spec n = do {
  (a, ret_ptr) <- ptr_to_fresh "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (nest fp6_frobenius (fp6_abs a) `n) }} );
};

let sqr_fp4_spec = do {
  ret_ptr <- crucible_alloc vec384fp4_type;
  (a0, a0_ptr) <- ptr_to_fresh_readonly "a0" vec384x_type;
  (a1, a1_ptr) <- ptr_to_fresh_readonly "a1" vec384x_type;
  crucible_precond {{ fp2_invariant a0 }};
  crucible_precond {{ fp2_invariant a1 }};
  crucible_execute_func [ret_ptr, a0_ptr, a1_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp4_rep (Fp_4.sq (fp4_abs [a0, a1])) }});
};

let mul_by_u_plus_1_fp2_spec = do {
  ret_ptr <- crucible_alloc vec384x_type;
  (a,a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs a)) }});
};

let mul_by_u_plus_1_fp2_alias_spec = do {
  (ret,ret_ptr) <- ptr_to_fresh "ret" vec384x_type;
  crucible_precond {{ fp2_invariant ret }};
  crucible_execute_func [ret_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs ret)) }});
};

let {{
  mul_by_u_plus_1_fp2x2: t_Fp_2x2 -> t_Fp_2x2
  mul_by_u_plus_1_fp2x2 [x, y] = [add_mod_384x384 y x, sub_mod_384x384 y x]
  }};

// When we expand Fp_6x2.mul we get u_plus_1 on the right.
mul_by_u_plus_1_fp2x2_equiv_thm  <-
  prove_cryptol {{ \x ->  Fp_2x2.mul (x, u_plus_1x2) == mul_by_u_plus_1_fp2x2 x }} [];

let mul_by_u_plus_1_fp2x2_spec = do {
  ret_ptr <- crucible_alloc vec768x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec768x_type;
  crucible_precond {{ fp2x2_invariant a }} ;
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.mul (fp2x2_abs a, u_plus_1x2)) }} );
  };

// ... Fp2x2 operations

let add_fp2x2_spec a_aliased b_aliased = do {
  (ret, ret_ptr) <- if either a_aliased b_aliased
                    then ptr_to_fresh "ret" vec768x_type
                    else do { ptr <- crucible_alloc vec768x_type;
                              return ({{zero: [2]Vec768}}, ptr);
                            };
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768x_type;
  (b, b_ptr) <- if b_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "b" vec768x_type;
  crucible_precond {{ fp2x2_invariant a }};
  crucible_precond {{ fp2x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.add (fp2x2_abs a, fp2x2_abs b)) }});
};

let sub_fp2x2_spec a_aliased b_aliased = do {
  (ret, ret_ptr) <- if either a_aliased b_aliased
                    then ptr_to_fresh "ret" vec768x_type
                    else do { ptr <- crucible_alloc vec768x_type;
                              return ({{zero: [2]Vec768}}, ptr);
                            };
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768x_type;
  (b, b_ptr) <- if b_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "b" vec768x_type;
  crucible_precond {{ fp2x2_invariant a }};
  crucible_precond {{ fp2x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.sub (fp2x2_abs a, fp2x2_abs b)) }});
};

let mul_fp2x2_spec = do {
  ret_ptr <- crucible_alloc vec768x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
  crucible_precond {{ fp2_invariant a }}; // a is smallish
  crucible_precond {{ fp2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.mul (abs_384x a, abs_384x b)) }});
};

let sqr_fp2x2_spec = do {
  ret_ptr <- crucible_alloc vec768x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }}; // a is smallish
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.mul (abs_384x a, abs_384x a)) }});
};

// ... Fp6x2 operations

let sub_fp6x2_spec a_aliased = do {
  (ret, ret_ptr) <- if a_aliased
                    then ptr_to_fresh "a" vec768fp6_type
                    else do { r <- crucible_alloc vec768fp6_type;
                              return ( {{ zero: [3][2]Vec768 }}, r ); } ; // TODO fix Cryptol type?
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec768fp6_type;
  crucible_precond {{ fp6x2_invariant a }};
  crucible_precond {{ fp6x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (Fp_6x2.sub (fp6x2_abs a, fp6x2_abs b)) }});
};


// "nom" variants do not apply the Montgomery decode.

let {{
  fp2_abs_nom [x, y] = [abs_384 y, abs_384 x]
  fp6_abs_nom [x,y,z] = [fp2_abs_nom z, fp2_abs_nom y, fp2_abs_nom x]

  fp2_rep_nom [x, y] = [rep_384 y, rep_384 x]
  fp6_rep_nom [x,y,z] = [fp2_rep_nom z, fp2_rep_nom y, fp2_rep_nom x]
  }};

let {{ fp12_abs_nom [x,y] =[fp6_abs_nom y, fp6_abs_nom x] }};
let {{ fp12_rep_nom [x, y] = [fp6_rep_nom y, fp6_rep_nom x] }};

let mul_fp6x2_spec = do {
  ret_ptr <- crucible_alloc vec768fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp6_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (fp6x2_mul (fp6_abs_nom a) (fp6_abs_nom b)) }});
};

let redc_fp6x2_spec = do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec768fp6_type;
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep_nom (redc_mont_fp6 (fp6x2_abs a)) }});
  };

let mul_fp6_spec a_aliased = do {
  (ret, ret_ptr) <- if a_aliased
                    then ptr_to_fresh "a" vec384fp6_type
                    else do { r <- crucible_alloc vec384fp6_type;
                              return ( {{ zero: [3][2]Vec384 }}, r ); } ; // TODO fix Cryptol type?
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp6_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (Fp_6.mul (fp6_abs a, fp6_abs b)) }});
};

add_fp6_spec <- do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp6_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (Fp_6.add (fp6_abs a, fp6_abs b)) }});
  };

add_fp6_aliased_1_3_spec <- do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, ret_ptr) <- ptr_to_fresh "b" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp6_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (Fp_6.add (fp6_abs a, fp6_abs b)) }});
  };

sub_fp6_spec <- do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp6_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (Fp_6.sub (fp6_abs a, fp6_abs b)) }});
  };

// ... two subroutines for mul-by_xy00z0

let mul_by_0y0_fp6x2_spec = do {
  ret_ptr <- crucible_alloc vec768fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (mul_by_0y0_fp6x2 (fp6_abs_nom a) (fp2_abs_nom b)) }});
};

// mul_by_xy0_fp6x2 is peculiar in one way: we get a Fp_6 input, but
// only read two of the three elements in it.  Some calls do not
// initialize that third element.  so in this spec we do not insist on
// the whole 3-element array being initialized; just the part we use.

let mul_by_xy0_fp6x2_spec = do {
  ret_ptr <- crucible_alloc vec768fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  x <- crucible_fresh_var "x" vec384x_type;
  y <- crucible_fresh_var "y" vec384x_type;
  xy0_ptr <- crucible_alloc_readonly (llvm_array 2 vec384x_type);
  crucible_points_to (crucible_elem xy0_ptr 0) (crucible_term x);
  crucible_points_to (crucible_elem xy0_ptr 1) (crucible_term y);
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp2_invariant x }};
  crucible_precond {{ fp2_invariant y }};
  crucible_execute_func [ret_ptr, a_ptr, xy0_ptr];
  crucible_points_to ret_ptr (crucible_term
    {{ fp6x2_rep (mul_by_xy0_fp6x2 (fp6_abs_nom a) (fp2_abs_nom y) (fp2_abs_nom x)) }});
};

// .. inversion
let eucl_inverse_fp_spec = do {
  ret_ptr <- crucible_alloc vec384_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  crucible_precond {{ fp_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term
   {{ fp_rep (Fp.div (Fp.field_unit, fp_abs a)) }});
};

let inverse_fp2_spec = do {
  ret_ptr <- crucible_alloc vec384x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term
   {{ fp2_rep (inverse_fp2_imp (fp2_abs a)) }});
};

let inverse_fp6_spec = do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term
   {{ fp6_rep (inverse_fp6_imp (fp6_abs a)) }});
};

let sqr_fp6_spec = do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (Fp_6.sq (fp6_abs a)) }});
};

let neg_fp6_alias_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [a_ptr, a_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp6_rep (Fp_6.neg (fp6_abs a)) }});
};


///////////////////////////////////////////////////////////////////////////////
// Proofs
///////////////////////////////////////////////////////////////////////////////

fp6_alg_thms <- for
  [ {{ \ x y z -> Fp_6.mul (Fp_6.mul (x, y), z) == Fp_6.mul (x, Fp_6.mul (y, z)) }} // mul associates
  , {{ \x -> Fp_6.mul (x, Fp_6.field_zero) == Fp_6.field_zero }} // x*0 = 0
  , {{ \x -> Fp_6.mul (Fp_6.field_zero, x) == Fp_6.field_zero }} // 0*x = 0
  , {{ \x -> Fp_6.mul (x, Fp_6.field_unit) == Fp_6.normalize x }} // x*1 = x ish
  // , {{ \x -> Fp_6.mul (x, Fp_6.field_unit) == x }} // x*1 = x TODO: OK in the `Z p` model
  , {{ \x -> Fp_6.mul (Fp_6.field_unit, x) == Fp_6.normalize x }} // 1*x = x ish
  // , {{ \x -> Fp_6.mul (Fp_6.field_unit, x) == x }} // 1*x = x TODO

  , {{ \x -> Fp_6.sq x == Fp_6.mul (x,x) }} // eliminate squaring.  Not always a good idea

  , {{ \ x y z -> Fp_6.add (Fp_6.add (x, y), z) == Fp_6.add (x, Fp_6.add (y, z)) }} // add associates
  , {{ \x -> Fp_6.add (x, Fp_6.field_zero) == Fp_6.normalize x }} // x+0 = x ish
  , {{ \x -> Fp_6.add (Fp_6.field_zero, x) == Fp_6.normalize x }}//  0+x = x ish

  , {{ \ x y -> Fp_6.sub (x, y) == Fp_6.add (x, Fp_6.neg y) }} // eliminate sub in favour of neg

  , {{ \ x -> Fp_6.neg (Fp_6.neg x) == Fp_6.normalize x }} // double negative
  , {{ \ x y -> Fp_6.neg (Fp_6.add (x, y)) == Fp_6.add (Fp_6.neg x, Fp_6.neg y) }} // push neg inside a sum
  , {{ Fp_6.neg Fp_6.field_zero == Fp_6.field_zero }} // -0 = 0

  // rules to eliminate normalization in a argument position
  , {{ \ x -> Fp_6.neg (Fp_6.normalize x) == Fp_6.neg x }}
  , {{ \ x y -> Fp_6.add (Fp_6.normalize x, y) == Fp_6.add (x, y) }}
  , {{ \ x y -> Fp_6.add (x, Fp_6.normalize y) == Fp_6.add (x, y) }}
  , {{ \ x y -> Fp_6.mul (Fp_6.normalize x, y) == Fp_6.mul (x, y) }}
  , {{ \ x y -> Fp_6.mul (x, Fp_6.normalize y) == Fp_6.mul (x, y) }}
  ] (\ t -> prove_cryptol t []);


nest_fp2_thms <- for
  [ {{ \ f (x:t_Fp_2) -> nest f x 1 == f x }}
  , {{ \ f (x:t_Fp_2) -> nest f x 2 == f (f x) }}
  , {{ \ f (x:t_Fp_2) -> nest f x 3 == f (f (f x)) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);

nest_fp6_thms <- for
  [ {{ \ f (x:t_Fp_6) -> nest f x 1 == f x }}
  , {{ \ f (x:t_Fp_6) -> nest f x 2 == f (f x) }}
  , {{ \ f (x:t_Fp_6) -> nest f x 3 == f (f (f x)) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);

// borrowed from exp2.saw:
fp2_invariant_alt_thm <-
  prove_cryptol
  {{ \x -> fp2_invariant x == (fp_invariant (x@0) /\ fp_invariant (x@1)) }}
  ["fp_invariant"];

fp2_invariant_alt_seq_thm <-
  prove_cryptol
  {{ \x y -> fp2_invariant [x,y] == (fp_invariant x /\ fp_invariant y) }}
  ["fp_invariant"];

// Assembler function overrides
mul_by_1_plus_i_mod_384x_ov <- admit "mul_by_1_plus_i_mod_384x" mul_by_1_plus_i_mod_384x_spec;
mul_by_1_plus_i_mod_384x_alias_ret_a_ov <- admit "mul_by_1_plus_i_mod_384x" mul_by_1_plus_i_mod_384x_alias_ret_a_spec;

mul_by_u_plus_1_fp2x2_ov <- custom_verify "mul_by_u_plus_1_fp2x2"
  all_384x384_ovs
  mul_by_u_plus_1_fp2x2_spec
  do {
   rw_with_1 mul_by_u_plus_1_fp2x2_equiv_thm;
   unfolding ["mul_by_u_plus_1_fp2x2", "fp2x2_rep", "fp2x2_abs"];
   simplify (cryptol_ss());
   w4_unint_z3 all_384x384_unints; };

mul_382x_equiv_thm <- prove_cryptol {{ \ x y  -> Fp_2x2.mul (x,y) == mul_382x x y }} [];

mul_fp2x2_ov <- custom_verify "mul_fp2x2"
  all_384x384_ovs
  mul_fp2x2_spec
  do {
   rw_with_1 mul_382x_equiv_thm; // eliminate Fp_2x2.mul
   w4_unint_z3 ["mul_382x", "fp2x2_rep", "abs_384x"];
   };

sqr_fp2x2_ov <- custom_verify "sqr_fp2x2"
  all_384x384_ovs
  sqr_fp2x2_spec
  do {
   rw_with_1 mul_382x_equiv_thm; // eliminate Fp_2x2.mul
   w4_unint_z3 ["mul_382x", "fp2x2_rep", "abs_384x"];
   };

sub_fp6x2_ov <- custom_verify "sub_fp6x2"
  all_384x384_ovs
  (sub_fp6x2_spec false) // not aliased
  z3;

sub_fp6x2_alias_ov <- custom_verify "sub_fp6x2"
  all_384x384_ovs
  (sub_fp6x2_spec true) // (ret, a)
  z3;

// abs and rep theorems for fp2x2 are a bit complicated.
// bv_384_thms <- bv_int_axioms 384;
bv768_thms <- bv_int_axioms 768;

// ... first fpx2
vec768_abs_rep_thm <- prove_cryptol {{ \x -> vec768_abs (vec768_rep x) == x }} [];
vec768_rep_abs_thm <- prove_cryptol {{ \x -> vec768_rep (vec768_abs x) == x }} [];

fpx2_inv_rep_lemma <- custom_prove_cryptol
  {{ \ x -> fpx2_invariant (fpx2_rep x) == Fpx2.is_val (x % 2^^768) }}
  do { unfolding ["fpx2_invariant", "fpx2_rep", "Fpx2", "prime_field_integer"];
       simplify (addsimp vec768_abs_rep_thm empty_ss);
       simplify (addsimps bv768_thms empty_ss);
       z3; };

fpx2_inv_rep_lemma2 <- custom_prove_cryptol
  {{ \ x -> fpx2_invariant (fpx2_rep x) ==
       if Fpx2.is_val x then True else apply fpx2_invariant (fpx2_rep x) }}
  do { unfolding ["apply"]; rw_with_1 fpx2_inv_rep_lemma; z3; };

fpx2_val_thms <- for
  [ {{ Fpx2.add }}, {{ Fpx2.sub }}, {{Fpx2.mul}} ]
  ( \ f -> prove_cryptol {{ \ x y -> Fpx2.is_val (f (x,y)) == True }} [] );

// see vec_384x384_thms
fpx2_abs_rep_lemma <- custom_prove_cryptol
  {{ \x -> fpx2_abs (fpx2_rep x) == x % 2^^768}}
  do { unfolding ["fpx2_abs", "fpx2_rep"];
       simplify (addsimp vec768_abs_rep_thm (addsimps bv768_thms empty_ss));
       z3; };

// TODO: see vec_384x384_thms - but here we can prove it.
fpx2_abs_rep_thm <- custom_prove_cryptol
    {{ \x -> fpx2_abs (fpx2_rep x) == if Fpx2.is_val x then x else x % 2^^768 }}
    do { rw_with_1 fpx2_abs_rep_lemma; z3; };

// see vec_384x384_thms
fpx2_rep_abs_thm <- custom_prove_cryptol {{ \x -> fpx2_rep (fpx2_abs x) == x }}
  do { unfolding ["fpx2_abs", "fpx2_rep"];
       simplify (addsimp vec768_rep_abs_thm (addsimps bv768_thms empty_ss));
       z3; };

let fpx2_thms = concat_all [[fpx2_inv_rep_lemma2], fpx2_val_thms, [fpx2_abs_rep_thm, fpx2_rep_abs_thm]];

// ... then fp2x2

fp2x2_inv_rep_lemma2 <- custom_prove_cryptol
  {{ \ x -> fp2x2_invariant (fp2x2_rep x) ==
       if Fp_2x2.is_val x then True else apply fp2x2_invariant (fp2x2_rep x) }}
  do { unfolding ["apply", "fp2x2_invariant", "fp2x2_rep"];
       rw_with_1 fpx2_inv_rep_lemma2;
       w4_unint_z3 ["fpx2_invariant", "fpx2_rep", "Fpx2"]; };

fp2x2_val_thms <- for
  [ {{ Fp_2x2.add }}, {{ Fp_2x2.sub }}, {{Fp_2x2.mul}} ]
  ( \ f -> prove_cryptol {{ \ x y -> Fp_2x2.is_val (f (x,y)) == True }} []);

fp2x2_ite_thms <- for
  [ {{ fp2x2_invariant }}, {{ fp2x2_rep }}, {{ fp2x2_abs }} ]
  (\t -> hoist t ["fp2x2_invariant", "fp2x2_rep", "fp2x2_abs"]) ;

fpx2_inv_at_thms <- for [0,1]
  (\ i -> prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> fpx2_invariant (x @ (`i:[1])) ==
          if fp2x2_invariant x then True else apply fpx2_invariant (x @ (`i:[1])) }}) []);

fp2x_inv_list_thm <- prove_cryptol
  {{ \ x y -> fp2x2_invariant [x, y] == (fpx2_invariant x /\ fpx2_invariant y) }} [];

fp2x2_abs_rep_thm <- custom_prove_cryptol
    {{ \x -> fp2x2_abs (fp2x2_rep x) == if Fp_2x2.is_val x then x else apply fp2x2_abs (fp2x2_rep x) }}
    do { unfolding ["apply", "fp2x2_abs", "fp2x2_rep", "Fp_2x2", "extension_field"];
         rw_with_1 fpx2_abs_rep_thm; z3; };


Fpx2_val_at_thms <- for [0,1]
  (\ i -> prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> Fpx2.is_val (x @ (`i:[1])) ==
          if Fp_2x2.is_val x then True else apply Fpx2.is_val (x @ (`i:[1]))}}) []);

let fp2x2_thms = concat_all [fp2x2_val_thms, fp2x2_ite_thms, Fpx2_val_at_thms
                            , [fp2x2_inv_rep_lemma2,fp2x_inv_list_thm, fp2x2_abs_rep_thm] ];

add_fp2x2_ovs <- for possible_aliases
  (\ (ar, br) -> custom_verify "add_fp2x2" all_384x384_ovs (add_fp2x2_spec ar br) z3);

sub_fp2x2_ovs <- for possible_aliases
  (\ (ar, br) -> custom_verify "sub_fp2x2" all_384x384_ovs (sub_fp2x2_spec ar br) z3);

// and fp6x2

reabstracted_add_thm <- test_cryptol
  {{ \ x y -> abs_384x (fp2_rep (Fp_2.add (fp2_abs x, fp2_abs y))) == Fp_2.add (fp2_abs_nom x, fp2_abs_nom y) }};

// TODO: do not use fp2_abs_nom, it is redundant
fp2_abs_nom_thm <- prove_cryptol {{ \x -> fp2_abs_nom x == abs_384x x }} [];

mul_fp6x2_ov <- custom_verify "mul_fp6x2"
  (concat_all [[mul_fp2x2_ov, sqr_fp2x2_ov, mul_by_u_plus_1_fp2x2_ov], add_fp2x2_ovs, sub_fp2x2_ovs, fp2_overrides])
  mul_fp6x2_spec
  do {
   unfolding ["fp6_invariant", "fp6x2_rep", "fp6_abs_nom", "fp6x2_mul", "fp6x2_tmp"];
   simplify fp2_simpset;
   rw_with (concat_all [fpx2_thms, fp2x2_thms, [reabstracted_add_thm, fp2_abs_nom_thm]]);
   z3;
   };

// ...now the payoff, using redc_mont_384 to get back into Fp6

let {{ redc_mont_fp2 [x, y] = [redc_mont_384 x, redc_mont_384 y] }};
let {{ redc_mont_fp6 [x, y, z] = [redc_mont_fp2 x, redc_mont_fp2 y, redc_mont_fp2 z] }};
let {{ redc_mont_fp12 [x, y] = [redc_mont_fp6 x, redc_mont_fp6 y] }};

let {{ toM: Integer -> Integer
       toM x = (x*2^^384) % `p
       toM_2 [x, y] = [toM x, toM y]
       toM_6 [x,y,z] = [toM_2 x, toM_2 y, toM_2 z]
       }};

let {{ toM_12 [x, y] = [toM_6 x, toM_6 y] }};

redc_Fp_add_thm <- prove_cryptol {{ \x y -> redc_mont_384 (Fp.add (x,y)) == Fp.add (redc_mont_384 x, redc_mont_384 y) }} [] ;
redc_Fp_sub_thm <- prove_cryptol {{ \x y -> redc_mont_384 (Fp.sub (x,y)) == Fp.sub (redc_mont_384 x, redc_mont_384 y) }} [] ;

redc_Fpx2_add_thm <- prove_cryptol {{ \x y -> redc_mont_384 (Fpx2.add (x,y)) == Fp.add (redc_mont_384 x, redc_mont_384 y) }} [] ;
redc_Fpx2_sub_thm <- prove_cryptol {{ \x y -> redc_mont_384 (Fpx2.sub (x,y)) == Fp.sub (redc_mont_384 x, redc_mont_384 y) }} [] ;
redc_Fpx2_zero_thm <- prove_cryptol {{ redc_mont_384 Fpx2.field_zero == Fp.field_zero }} [] ;

toM_Fp_add_thm <- prove_cryptol {{ \x y -> toM (Fp.add (x,y)) == Fp.add (toM x, toM y) }} [] ;
toM_Fp_sub_thm <- prove_cryptol {{ \x y -> toM (Fp.sub (x,y)) == Fp.sub (toM x, toM y) }} [] ;
toM_Fp_zero_thm <- prove_cryptol {{ toM Fp.field_zero == Fp.field_zero }} [] ;

// Integer not testable, so admit
redc_Fpx2_mul_thm2b <- admit_cryptol  {{ \ x y -> redc_mont_384 (Fpx2.mul (x, y)) == toM (Fp.mul (redc_mont_384 x, redc_mont_384 y)) }};


redc_mont_mul_6x2_thm <- custom_prove_cryptol
  {{ \ x y -> redc_mont_fp6 (Fp_6x2.mul (fp6_abs_nom x, fp6_abs_nom y)) == toM_6 (Fp_6.mul(fp6_abs x, fp6_abs y)) }}
  do { goal_eval_unint ["Fpx2", "Fp", "redc_mont_384", "fp_abs", "abs_384", "toM"];
       rw_with (concat_all [ fpx2_val_thms, vec384x384_thms
                           , [fpx2_abs_rep_thm, redc_Fpx2_add_thm, redc_Fpx2_sub_thm
                             , redc_Fpx2_zero_thm, redc_Fpx2_mul_thm2b
                             , toM_Fp_add_thm, toM_Fp_sub_thm, toM_Fp_zero_thm
                             ]]);
       // print_goal_nicely;
       z3; };

// NOW. need fp6_rep_nom X = fp6_rep (toM_6 x).  Start at Fp

// "prove_cryptol", which uses w4_unint_z3, does mnot succeed in this proof:
fp_rep_nom_thm <- custom_prove_cryptol {{ \x -> rep_384 (toM x) == fp_rep x }} z3;

fp6_rep_nom_thm <- custom_prove_cryptol {{ \x -> fp6_rep x == fp6_rep_nom (toM_6 x) }}
  do { unfolding ["fp6_rep_nom", "fp2_rep_nom", "fp6_rep", "fp2_rep", "toM_6", "toM_2"];
       rw_with_1 fp_rep_nom_thm;
       w4_unint_z3 ["rep_384", "fp_rep", "toM"]; };

fp6x2_abs_rep_thm <- custom_prove_cryptol
  {{ \x -> fp6x2_abs (fp6x2_rep x) == if Fp_6x2.is_val x then x else apply fp6x2_abs (fp6x2_rep x) }}
  do { unfolding ["fp6x2_rep", "fp6x2_abs", "apply"];
       rw_with_1 fp2x2_abs_rep_thm;
       w4_unint_z3 ["Fp_2x2", "fp2x2_abs", "fp2x2_rep"]; };

fp6x2_mul_is_val_thm <- prove_cryptol {{ \x y -> Fp_6x2.is_val (fp6x2_mul x y) == True}} [];

fp6x2_is_val_op_thms <- for [{{ Fp_6x2.mul }} , {{ Fp_6x2.add }}, {{ Fp_6x2.sub }} ]
  (\ t -> prove_cryptol {{ \ p -> Fp_6x2.is_val (t p) == True }} []);

fp6x2_inv_rep_thm <- custom_prove_cryptol
  {{ \x -> fp6x2_invariant (fp6x2_rep x) == if Fp_6x2.is_val x then True else apply fp6x2_invariant (fp6x2_rep x)}}
  do { unfolding ["fp6x2_rep", "fp6x2_invariant", "apply"];
       rw_with_1 fp2x2_inv_rep_lemma2;
       z3; };

fp6x2_inv_rep_thm2 <- custom_prove_cryptol
  {{ \x y z -> fp6x2_invariant [fp2x2_rep x, fp2x2_rep y, fp2x2_rep z]
                == if Fp_6x2.is_val [x,y,z] then True
                   else apply fp6x2_invariant [fp2x2_rep x, fp2x2_rep y, fp2x2_rep z]}}
  do { unfolding ["apply", "fp6x2_invariant"];
       rw_with_1 fp2x2_inv_rep_lemma2;
       goal_eval_unint ["Fp_2x2", "fp2x2_rep", "fp2x2_invariant"];
       z3; };

// redundant -- see fp6x2_is_val_op_thms 
fp6x2_val_thms <- for
  [ {{ Fp_6x2.add }}, {{ Fp_6x2.sub }}, {{Fp_6x2.mul}} ]
  ( \ f -> prove_cryptol {{ \ x y -> Fp_6x2.is_val (f (x,y)) == True }} []);

fp6x2_val_mul_thm <- prove_cryptol
  {{ \ x y -> Fp_6x2.is_val (fp6x2_mul x y) == True }} [];


// And we need to show fp6x2_mul equivalent (mod p) to Fp_6x2.mul.
// Also that recd_mont_384 respects mod p equivalents
let {{ fp2_reduce_mod_p [x1:Integer, x2] = [x1%`p, x2%`p]
       fp6_reduce_mod_p [x1:[2]Integer,x2,x3] = [fp2_reduce_mod_p x1, fp2_reduce_mod_p x2, fp2_reduce_mod_p x3]
    }};

// algebraically true; assumed
fp6x2_mul_equiv_thm <- admit_cryptol
  {{ \x y -> fp6_reduce_mod_p (fp6x2_mul x y) == fp6_reduce_mod_p (Fp_6x2.mul (x, y)) }};

// inserts a mod p reduction; `apply` prevents it from looping.
redc_fp6_mod_p_thm <- prove_cryptol
  {{ \x -> redc_mont_fp6 x == apply redc_mont_fp6 (fp6_reduce_mod_p x) }} [];
// and need to take it out again
redc_fp6_mod_p_rev_thm <- prove_cryptol
  {{ \x ->  redc_mont_fp6 (fp6_reduce_mod_p x) == redc_mont_fp6 x }} [];


redc_fp6x2_ov <- custom_verify "redc_fp6x2"
  [redcx_mont_384_alt_ov]
  redc_fp6x2_spec
  z3;

mul_fp6_ov <- custom_verify "mul_fp6"
  [mul_fp6x2_ov, redc_fp6x2_ov]
  (mul_fp6_spec false) // not aliased
  do { simplify (addsimps [fp6x2_mul_is_val_thm, fp6x2_abs_rep_thm] prop_simpset);
       rw_with_1 redc_fp6_mod_p_thm;
       unfolding ["apply"];
       rw_with_1 fp6x2_mul_equiv_thm;
       rw_with_1 redc_fp6_mod_p_rev_thm;
       rw_with [fp6_rep_nom_thm, redc_mont_mul_6x2_thm];
       z3; };

mul_fp6_aliased_ov <- custom_verify "mul_fp6"
  [mul_fp6x2_ov, redc_fp6x2_ov]
  (mul_fp6_spec true) // aliased
  do { simplify (addsimps [fp6x2_mul_is_val_thm, fp6x2_abs_rep_thm] prop_simpset);
       rw_with_1 redc_fp6_mod_p_thm;
       unfolding ["apply"];
       rw_with_1 fp6x2_mul_equiv_thm;
       rw_with_1 redc_fp6_mod_p_rev_thm;
       rw_with [fp6_rep_nom_thm, redc_mont_mul_6x2_thm];
       z3; };


add_fp6_ov <-custom_verify "add_fp6"
  fp2_overrides
  add_fp6_spec
  (w4_unint_z3 ["Fp_2", "fp2_abs", "fp2_rep"]);

add_fp6_aliased_1_3_ov <-custom_verify "add_fp6"
  fp2_overrides
  add_fp6_aliased_1_3_spec
  (w4_unint_z3 ["Fp_2", "fp2_abs", "fp2_rep"]);

sub_fp6_ov <-custom_verify "sub_fp6"
  fp2_overrides
  sub_fp6_spec
  (w4_unint_z3 ["Fp_2", "fp2_abs", "fp2_rep"]);

// Algebraic
add_fp_nom_thm <- test_cryptol
  {{ \x y -> fp_rep (Fp.add (fp_abs x, fp_abs y)) ==
             rep_384 (Fp.add (abs_384 x, abs_384 y)) }};

add_fp6_nom_thm <- custom_prove_cryptol
  {{ \x y -> fp6_rep (Fp_6.add (fp6_abs x, fp6_abs y)) ==
             fp6_rep_nom (Fp_6.add (fp6_abs_nom x, fp6_abs_nom y)) }}
   do { goal_eval_unint ["fp_rep", "fp_abs", "Fp", "rep_384", "abs_384"];
        rw_with_1 add_fp_nom_thm;
        w4_unint_z3 ["fp_rep", "fp_abs", "Fp", "rep_384", "abs_384"];
        };

fp2x2_inv_at_thms <- for [0,1,2]
  (\ i -> prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> fp2x2_invariant (x @ (`i:[2])) ==
          if fp6x2_invariant x then True else apply fp2x2_invariant (x @ (`i:[2])) }}) []);

// Pushing in fpX_reduce_mod:
reduce_fp2x2_thms <- for
  [ {{ \x y -> fp2_reduce_mod_p (Fp_2x2.add (x, y)) == Fp_2.add (fp2_reduce_mod_p x, fp2_reduce_mod_p y) }}
  , {{ \x y -> fp2_reduce_mod_p (Fp_2x2.sub (x, y)) == Fp_2.sub (fp2_reduce_mod_p x, fp2_reduce_mod_p y) }}
  , {{ \x y -> fp2_reduce_mod_p (Fp_2x2.mul (x, y)) == Fp_2.mul (fp2_reduce_mod_p x, fp2_reduce_mod_p y) }}
  , {{ fp2_reduce_mod_p Fp_2x2.field_zero == Fp_2.field_zero }}
  , {{ fp2_reduce_mod_p Fp_2x2.field_unit == Fp_2.field_unit }}
  ] (\ t -> prove_cryptol t []);

reduce_fp6x2_thms <- for
  [ {{ \x y -> fp6_reduce_mod_p (Fp_6x2.add (x, y)) == Fp_6.add (fp6_reduce_mod_p x, fp6_reduce_mod_p y) }}
  , {{ \x y -> fp6_reduce_mod_p (Fp_6x2.sub (x, y)) == Fp_6.sub (fp6_reduce_mod_p x, fp6_reduce_mod_p y) }}
  , {{ \x y -> fp6_reduce_mod_p (Fp_6x2.mul (x, y)) == Fp_6.mul (fp6_reduce_mod_p x, fp6_reduce_mod_p y) }}
  , {{ fp6_reduce_mod_p Fp_6x2.field_zero == Fp_6.field_zero }}
  , {{ fp6_reduce_mod_p Fp_6x2.field_unit == Fp_6.field_unit }}
  ] (\ t -> custom_prove_cryptol t
      do { goal_eval_unint ["Fp_2x2", "Fp_2", "fp2_reduce_mod_p"];
           rw_with (concat [fp2_unrip_thm] reduce_fp2x2_thms);
           w4_unint_z3 ["Fp_2x2", "Fp_2"]; });

reduce_fp6x2_mul_thm <- custom_prove_cryptol
  {{ \x y -> fp6_reduce_mod_p (fp6x2_mul x y) == Fp_6.mul (fp6_reduce_mod_p x, fp6_reduce_mod_p y) }}
      do { goal_eval_unint ["Fp_2x2", "Fp_2", "fp2_reduce_mod_p"];
           rw_with (concat [fp2_unrip_thm] reduce_fp2x2_thms);
           z3; };

fp12_mul_lemma1 <- custom_prove_cryptol
  {{ \ a0 a1 b0 b1 -> fp6_reduce_mod_p (fp12_mul_1 a0 a1 b0 b1) ==
                    Fp_6.add (Fp_6.mul (a0, b1), Fp_6.mul (a1, b0)) }}
  do { unfolding ["fp12_mul_1"];
       rw_with (concat [reduce_fp6x2_mul_thm] reduce_fp6x2_thms);
       z3; };

/* These do not get the correct SAWCore and will not match
fp12_mul_0_lemmas <- for [0,1,2]
  (\ i ->
    prove_cryptol
      (rewrite (cryptol_ss ())
                {{ \ (x: t_Fp_6x2) -> fp2_reduce_mod_p (x @ `i) == (fp6_reduce_mod_p x) @ `i }})
       []);
*/
fp12_mul_0_lemmas <-
 let fp6_at0 = parse_core "\\ (x:(Vec 3 (Vec 2 Integer))) -> at 3 (Vec 2 Integer) x 0" in
  let fp6_at1 = parse_core "\\ (x:(Vec 3 (Vec 2 Integer))) -> at 3 (Vec 2 Integer) x 1" in
   let fp6_at2 = parse_core "\\ (x:(Vec 3 (Vec 2 Integer))) -> at 3 (Vec 2 Integer) x 2" in
     for
       [ {{ \ (x: t_Fp_6x2) -> fp2_reduce_mod_p (fp6_at0 x) == fp6_at0 (fp6_reduce_mod_p x) }}
       , {{ \ (x: t_Fp_6x2) -> fp2_reduce_mod_p (fp6_at1 x) == fp6_at1 (fp6_reduce_mod_p x) }}
       , {{ \ (x: t_Fp_6x2) -> fp2_reduce_mod_p (fp6_at2 x) == fp6_at2 (fp6_reduce_mod_p x) }}
       ]
       ( \ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);

fp12_mul_lemma0 <- custom_prove_cryptol
  {{ \ a0 a1 b0 b1 -> fp6_reduce_mod_p (fp12_mul_0 a0 a1 b0 b1) ==
                    Fp_6.add (Fp_6.mul(Fp_6.mul (a1, b1), v), Fp_6.mul (a0, b0)) }}
  do { unfolding ["fp12_mul_0", "fp6_reduce_mod_p"];
       simplify (addsimps reduce_fp2x2_thms (cryptol_ss()));
       rw_with fp12_mul_0_lemmas;
       rw_with (concat [reduce_fp6x2_mul_thm] reduce_fp6x2_thms);
       z3;
       };

fp6_unrip_thm <-
/*
 let fp6_at0 = parse_core "\\ (x:(Vec 3 (Vec 2 Integer))) -> at 3 (Vec 2 Integer) x 0" in
  let fp6_at1 = parse_core "\\ (x:(Vec 3 (Vec 2 Integer))) -> at 3 (Vec 2 Integer) x 1" in
   let fp6_at2 = parse_core "\\ (x:(Vec 3 (Vec 2 Integer))) -> at 3 (Vec 2 Integer) x 2" in
    prove_cryptol (rewrite (cryptol_ss ()) {{ \ (x:[3][2]Integer) -> [fp6_at0 x, fp6_at1 x, fp6_at2 x] == x }}) [];
*/ // More compactly, without parse_core!
  prove_cryptol (rewrite (cryptol_ss ()) {{ \ (x:[3][2]Integer) -> ([x0,x1,x2] == x where [x0,x1,x2] = x)}}) [];


fp12_mul_lemma_2 <- custom_prove_cryptol
  {{ \x y -> ([fp6_reduce_mod_p r1, fp6_reduce_mod_p r0] == Fp_12.mul (x, y)
               where [r1,r0] = fp12_mul x y) }}
  do { unfolding ["fp12_mul"];
       rw_with [fp12_mul_lemma0, fp12_mul_lemma1];
       z3; };

fp12_mul_lemma_rev <- custom_prove_cryptol
  {{ \x y -> (Fp_12.mul (x, y) == [fp6_reduce_mod_p r1, fp6_reduce_mod_p r0]
               where [r1,r0] = fp12_mul x y) }}
  do { unfolding ["fp12_mul"];
       rw_with [fp12_mul_lemma0, fp12_mul_lemma1];
       z3; };

redc_Fp_mul_thm <- admit_cryptol  {{ \ x y -> redc_mont_384 (Fp.mul (x, y)) == toM (Fp.mul (redc_mont_384 x, redc_mont_384 y)) }};

redc_Fp_add_thm <- prove_cryptol  {{ \ x y -> redc_mont_384 (Fp.add (x, y)) == Fp.add (redc_mont_384 x, redc_mont_384 y) }} [];

redc_Fp2_mul_thm <- custom_prove_cryptol  {{ \ x y -> redc_mont_fp2 (Fp_2.mul (x, y)) == toM_2 (Fp_2.mul (redc_mont_fp2 x, redc_mont_fp2 y)) }}
  do { goal_eval_unint ["redc_mont_384", "Fp", "toM"];
       rw_with [redc_Fp_mul_thm, redc_Fp_add_thm];
       z3;
       };

redc_Fp2_add_thm <- prove_cryptol  {{ \ x y -> redc_mont_fp2 (Fp_2.add (x, y)) == Fp_2.add (redc_mont_fp2 x, redc_mont_fp2 y) }} [];


redc_Fp6_mul_thm <- custom_prove_cryptol  {{ \ x y -> redc_mont_fp6 (Fp_6.mul (x, y)) == toM_6 (Fp_6.mul (redc_mont_fp6 x, redc_mont_fp6 y)) }}
  do { goal_eval_unint ["redc_mont_fp2", "Fp_2", "toM_2"];
       rw_with [redc_Fp2_mul_thm, redc_Fp2_add_thm];
       z3;
       };

redc_Fp6_add_thm <- prove_cryptol  {{ \ x y -> redc_mont_fp6 (Fp_6.add (x, y)) == Fp_6.add (redc_mont_fp6 x, redc_mont_fp6 y) }} [];

/*
redc_mont_mul_2_thm <- custom_prove_cryptol
  {{ \ x y -> redc_mont_fp2 (Fp_2.mul (fp2_abs_nom x, fp2_abs_nom y))
      == toM_2 (Fp_2.mul (fp2_abs x, fp2_abs y)) }}
  do { goal_eval_unint ["Fp", "redc_mont_384", "fp_abs", "abs_384", "toM"];
       rw_with [redc_Fp_add_thm]; // , redc_Fp_mul_thm];
       print_goal_nicely;
       assume_unsat; };

redc_mont_mul_6_thm <- custom_prove_cryptol
  {{ \ x y -> redc_mont_fp6 (Fp_6.mul (fp6_abs_nom x, fp6_abs_nom y))
      == toM_6 (Fp_6.mul (fp6_abs x, fp6_abs y)) }}
  do { // goal_eval_unint ["Fp_2", "Fp", "redc_mont_fp2", "fp2_abs", "fp2_abs_nom", "toM_2"];
      goal_eval_unint ["Fp", "redc_mont_384", "fp_abs", "abs_384", "toM"];
      print_goal_nicely;
      assume_unsat; };
*/
toM_Fp_6_add_thm <- prove_cryptol {{ \x y -> toM_6 (Fp_6.add (x,y)) == Fp_6.add (toM_6 x, toM_6 y) }} [] ;

// toM_Fp_6_sub_thm <- prove_cryptol {{ \x y -> toM (Fp_6.sub (x,y)) == Fp_6.sub (toM x, toM y) }} [] ;

// Algebraic assumption, easily derived on paper
redc_mont_mul_12_thm <- test_cryptol
  {{ \ x y -> redc_mont_fp12 (Fp_12.mul (fp12_abs_nom x, fp12_abs_nom y))
      == toM_12 (Fp_12.mul (fp12_abs x, fp12_abs y)) }};
//  do { //goal_eval_unint ["Fpx2", "Fp", "redc_mont_384", "fp_abs", "abs_384", "toM"];
       //rw_with (concat_all [ vec384x384_thms
       //                    , [toM_Fp_add_thm, toM_Fp_sub_thm, toM_Fp_zero_thm, redc_Fp_mul_thm
       //                      ]]);
//       goal_eval_unint ["Fp_6", "redc_mont_fp6", "fp6_abs", "fp6_abs_nom", "toM_6"];
//       rw_with [fp2_unrip_thm, fp6_unrip_thm];
//       rw_with [redc_Fp6_mul_thm, redc_Fp6_add_thm, toM_Fp_6_add_thm];
//       print_goal_nicely;
//       assume_unsat; };


fp12_rep_nom_thm <- custom_prove_cryptol {{ \x -> fp12_rep x == fp12_rep_nom (toM_12 x) }}
  do { unfolding ["fp12_rep_nom", "fp12_rep", "toM_12"];
       rw_with_1 fp6_rep_nom_thm;
       w4_unint_z3 ["fp6_rep", "fp6_rep_nom", "toM_6"]; };

fp_redc_abs_nom_thm <- prove_cryptol {{ \x -> redc_mont_384 (abs_384 x) == fp_abs x }} [];

fp2_redc_abs_nom_thm <- custom_prove_cryptol
  {{ \x -> redc_mont_fp2 (fp2_abs_nom x) == fp2_abs x }}
  do { unfolding ["redc_mont_fp2", "fp2_abs_nom", "fp2_abs"];
       rw_with_1 fp_redc_abs_nom_thm;
       z3; };

fp6_redc_abs_nom_thm <- custom_prove_cryptol
  {{ \x -> redc_mont_fp6 (fp6_abs_nom x) == fp6_abs x }}
  do { unfolding ["redc_mont_fp6", "fp6_abs_nom", "fp6_abs"];
       rw_with_1 fp2_redc_abs_nom_thm;
       z3; };

fp12_redc_abs_nom_thm <- custom_prove_cryptol
  {{ \x -> redc_mont_fp12 (fp12_abs_nom x) == fp12_abs x }}
  do { unfolding ["redc_mont_fp12", "fp12_abs_nom", "fp12_abs"];
       rw_with_1 fp6_redc_abs_nom_thm;
       z3; };

// Now, to rewrite the mul_fp12 postcondition into something we can prove fairly directly:
/*
mul_fp12_post_rewrite_thm <- custom_prove_cryptol
 {{ \ x y -> fp12_rep (Fp_12.mul (fp12_abs x, fp12_abs y)) ==
       fp12_rep_nom (redc_mont_fp12 (Fp_12.mul (fp12_abs_nom x) (fp12_abs_nom y))) }}
 do { rw_with [redc_mont_mul_12_thm, fp12_redc_abs_nom_thm, fp12_rep_nom_thm];
      print_goal_nicely;
      assume_unsat;
      };
*/

fp2x2_abs_at_thms <- for [0,1,2]
  (\ i -> custom_prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> fp2x2_abs ((fp6x2_rep x) @ (`i:[2])) ==
          if Fp_6x2.is_val x then x @ (((2-`i):[2])) else apply fp2x2_abs ((fp6x2_rep x) @ (`i:[2])) }})
       do { unfolding ["fp6x2_rep", "apply"];
            rw_with_1 fp2x2_abs_rep_thm;
            w4_unint_z3 ["Fp_2x2"]; } );

// TODO: see whether these are used
/*
fp2x2_abs_at_thms' <- for [0,1,2]
  (\ i -> custom_prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> fp2x2_abs ((fp6x2_rep x) @ (`i:[2])) == fp2x2_abs (fp2x2_rep (x @ ((2-`i):[2]))) }})
       do { unfolding ["fp6x2_rep"];
            w4_unint_z3 ["fp2x2_abs", "fp2x2_rep"]; } );
*/

fp2_abs_rep_nom_thm <- prove_cryptol
  {{ \ args -> fp2_abs_nom (fp2_rep_nom (Fp_2.add args)) == Fp_2.add args }} [];

fp6_abs_rep_nom_thm <- prove_cryptol
  {{ \ args -> fp6_abs_nom (fp6_rep_nom (Fp_6.add args)) == Fp_6.add args }} [];


x_lemma_1 <- custom_prove_cryptol
  {{ \ x y -> fp12_rep (Fp_12.mul (fp12_abs x, fp12_abs y)) ==
     fp12_rep_nom (redc_mont_fp12 (Fp_12.mul (fp12_abs_nom x, fp12_abs_nom y))) }}
  do { rw_with [fp12_rep_nom_thm, redc_mont_mul_12_thm];
       w4_unint_z3 ["fp12_rep_nom", "toM_12", "Fp_12", "fp12_abs", "fp12_abs_nom"]; };

x_lemma_2 <- custom_prove_cryptol
  {{ \ x' y' -> redc_mont_fp12 (Fp_12.mul (x', y')) == redc_mont_fp12 (fp12_mul x' y') }}
  do { rw_with_1 fp12_mul_lemma_rev;
       unfolding ["redc_mont_fp12"];
       rw_with_1 redc_fp6_mod_p_rev_thm;
       w4_unint_z3 ["redc_mont_fp6", "fp6_reduce_mod_p", "fp12_mul"]; };

// TODO: use fp12_rep_nom?
x_lemma_3 <- custom_prove_cryptol
    {{ \ a b -> fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs b)) ==
               ([f y, f x] where
                       [x,y] = fp12_mul (fp12_abs_nom a) (fp12_abs_nom b)
                       f z = fp6_rep_nom (redc_mont_fp6 z) ) }}
    do { rw_with [x_lemma_1, x_lemma_2];
         w4_unint_z3 ["fp12_rep", "Fp_12", "fp12_abs", "fp6_rep_nom", "fp12_mul"
                     , "fp12_abs_nom", "redc_mont_fp6"]; };


mul_fp12_ovs <- for [mul_fp12_spec, mul_fp12_alias_spec]
  ( \ s -> custom_verify "mul_fp12"
   (concat_all [[mul_fp6x2_ov, redc_fp6x2_ov, mul_by_u_plus_1_fp2x2_ov, add_fp6_ov
                , sub_fp6x2_ov, sub_fp6x2_alias_ov]
              , add_fp2x2_ovs, sub_fp2x2_ovs, fp2_overrides])
   s // the spec
   (goal_num_ite 11
     do { // for the postcondition goal
        rw_with_1 x_lemma_3;
        unfolding ["fp6x2_abs"];
        simplify (addsimps (concat_all [[fp2x2_abs_rep_thm, fp6x2_val_mul_thm, fp6_unrip_thm, add_fp6_nom_thm]
                                        , fp2x2_abs_at_thms
                                       , fp2x2_val_thms, fp6x2_is_val_op_thms]) (cryptol_ss()));
        simplify (addsimps [fp2_abs_rep_nom_thm, fp6_abs_rep_nom_thm, fp6x2_val_mul_thm] (cryptol_ss()));
        unfolding ["fp12_abs_nom", "fp12_mul", "fp12_mul_0", "fp12_mul_1"]; // , "fp6_abs_nom"];
        rw_with_1 fp6_unrip_thm;
        w4_unint_z3 ["fp2_rep_nom", "redc_mont_fp6", "fp6x2_mul", "Fp_6x2", "Fp_2x2"
                    , "fp2x2_invariant", "fp2x2_rep", "fp6_invariant", "fp6_abs", "fp6_rep"
                    , "u_plus_1x2", "fp2_abs_nom"];
        }
     do { // for goals to establish preconditions of called routines
       unfolding ["fp12_invariant", "fp12_abs_nom", "fp6_invariant", "fp6x2_rep", "fp6x2_abs"
                 , "fp6_rep"
                 , "fp12_mul", "fp12_mul_0", "fp12_mul_1"];
       simplify (addsimps (concat_all [fp6x2_val_thms,  fp2x2_inv_at_thms, fp2x2_val_thms
                                      , [fp6x2_val_mul_thm, fp6x2_inv_rep_thm, fp6x2_inv_rep_thm2
                                        , fp2x2_inv_rep_lemma2]])
                fp2_simpset);
       w4_unint_z3 ["fp2x2_rep", "fp2x2_invariant", "fp2_rep", "fp2_invariant"]; // , "Fp_6x2", "Fp_6"];
       }));



// ... mul_xy00z0_fp12

/*  The proof of mul_xy00z0_fp12 has quite a few parts:
  1. we specify and prove the two main subroutines
  2. We show that these subroutines do soemthing reasonable abstractly
  3. we define a Cryptol function `mul_by_xy00z0_fp12` that corresponds to the algorithm used in the code
  4. we show that this algorithm implements Fp_12 multiplication (itself a multi-step proof)
  5. we then use the theorem from (4) to rewrite the postcondition of `mul_xy00z0_fp12` to
     refer to `mul_by_xy00z0_fp12` rather than `Fp_12.mul`, and prove that the code implements that.

  Step 4 is where we deal with the Montgomery reduction, using the same strategy as applied for `mul_fp12`
*/

let fp2x2_overrides = concat_all [ add_fp2x2_ovs, sub_fp2x2_ovs
                                 , [mul_fp2x2_ov, sqr_fp2x2_ov, mul_by_u_plus_1_fp2x2_ov]];

mul_by_0y0_fp6x2_ov <- custom_verify "mul_by_0y0_fp6x2"
  fp2x2_overrides
  mul_by_0y0_fp6x2_spec
  do { rw_with fp2x2_thms;
       z3; };

mul_by_0y0_fp6x2_thm <- prove_cryptol
  {{ \ x y -> fp6_reduce_mod_p (mul_by_0y0_fp6x2 x y) ==
              Fp_6.mul (x, [Fp_2.field_zero, y, Fp_2.field_zero]) }} [];


mul_by_xy0_fp6x2_thm <- custom_prove_cryptol
  {{ \ a x y -> fp6_reduce_mod_p (mul_by_xy0_fp6x2 a x y) == Fp_6.mul (a, [Fp_2.field_zero, x, y]) }}
  do { goal_eval_unint ["Fp_2", "Fp_2x2", "u_plus_1", "u_plus_1x2", "fp2_reduce_mod_p"];
       simplify (addsimp fp2_unrip_thm (addsimps reduce_fp2x2_thms fp2_simpset));
       z3; };

// That theorem needs the fp6_reduction:
// fails(
//  custom_prove_cryptol
//   {{ \ a x y -> (mul_by_xy0_fp6x2 a x y) == Fp_6.mul (a, [Fp_2.field_zero, x, y]) }}
//   do { goal_eval_unint ["Fp_2", "Fp_2x2", "u_plus_1", "u_plus_1x2", "fp2_reduce_mod_p"];
//        simplify (addsimp fp2_unrip_thm (addsimps reduce_fp2x2_thms fp2_simpset));
//        z3; });

add_fp2_nom_thm <- custom_prove_cryptol
  {{ \x y -> fp2_rep (Fp_2.add (fp2_abs x, fp2_abs y)) ==
             fp2_rep_nom (Fp_2.add (fp2_abs_nom x, fp2_abs_nom y)) }}
   do { goal_eval_unint ["fp_rep", "fp_abs", "Fp", "rep_384", "abs_384"];
        rw_with_1 add_fp_nom_thm;
        w4_unint_z3 ["fp_rep", "fp_abs", "Fp", "rep_384", "abs_384"];
        };

fp2_abs_rep_nom_thm_2 <- prove_cryptol
  {{ \ args -> abs_384x (fp2_rep_nom (Fp_2.add args)) == Fp_2.add args }} [];

mul_by_xy0_fp6x2_ov <- custom_verify "mul_by_xy0_fp6x2"
  (concat fp2_overrides fp2x2_overrides)
  mul_by_xy0_fp6x2_spec
  do { rw_with fp2x2_thms;
       simplify fp2_simpset;
       goal_num_ite 12
         do { // for the final "points_to" goal
           unfolding ["mul_by_xy0_fp6x2", "fp6x2_rep", "fp6_abs_nom"];
           rw_with [add_fp2_nom_thm, fp2_abs_rep_nom_thm_2, fp2_abs_nom_thm];
           w4_unint_z3 fp2_unints; }
         (w4_unint_z3 fp2_unints); // the precondition goals
       };


fp6_abs_rep_add_thm <-prove_cryptol
 {{ \ x y -> fp6_invariant (fp6_rep (Fp_6.add (x, y))) == True }} [];

// Need fp_2x2.is_val (x@i) == if Fp_6x2.is_val x then True ... (see Fpx2_val_at ...
// Need Fp_6x2.is_val (mul_by ...) for the two subroutines

fpx2x2_val_at_thms <- for [0,1,2]
  (\ i -> prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> Fp_2x2.is_val (x @ (`i:[2])) ==
          if Fp_6x2.is_val x then True else apply Fp_2x2.is_val (x @ (`i:[2]))}}) []);

mul_by_xy0_fp6x2_is_val_thm <- prove_cryptol
  {{ \ x y z -> Fp_6x2.is_val (mul_by_xy0_fp6x2 x y z) == True }} [];

mul_by_0y0_fp6x2_is_val_thm <- prove_cryptol
  {{ \ x y -> Fp_6x2.is_val (mul_by_0y0_fp6x2 x y) == True }} [];

fp2x2_is_val_op_thms <- for [{{ Fp_2x2.mul }} , {{ Fp_2x2.add }}, {{ Fp_2x2.sub }} ]
  (\ t -> prove_cryptol {{ \ p -> Fp_2x2.is_val (t p) == True }} []);

let {{ fp12_reduce_mod_p [x, y] = [fp6_reduce_mod_p x, fp6_reduce_mod_p y] }};
fp2_reduce_at_thms <- for
  [ {{ \x -> (fp2_reduce_mod_p x0 == (fp6_reduce_mod_p x) @ 0 where [x0,x1,x2] = x )}}
  , {{ \x -> (fp2_reduce_mod_p x1 == (fp6_reduce_mod_p x) @ 1 where [x0,x1,x2] = x )}}
  , {{ \x -> (fp2_reduce_mod_p x2 == (fp6_reduce_mod_p x) @ 2 where [x0,x1,x2] = x )}}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss()) t) []);

mul_by_xy00z0_fp12_thm <-
 custom_prove_cryptol {{ \ a xyz  ->
    fp12_reduce_mod_p (mul_by_xy00z0_fp12 a xyz) == Fp_12.mul(a,  fp6_to_fp12_xy00z0 xyz) }}
 do { goal_eval_unint ["Fp_2", "Fp_2x2", "u_plus_1", "u_plus_1x2", "fp6_reduce_mod_p", "Fp_6"
                       , "mul_by_0y0_fp6x2", "mul_by_xy0_fp6x2"];
      simplify (addsimps (concat [fp2_unrip_thm, fp6_unrip_thm] (concat fp2_alg_thms fp6_alg_thms))
                         (cryptol_ss()));
      unfolding ["fp6_reduce_mod_p"];
      rw_with reduce_fp2x2_thms;
      rw_with (concat fp2_reduce_at_thms [mul_by_xy0_fp6x2_thm, mul_by_0y0_fp6x2_thm]);
      z3; };

fp6_to_fp12_xy00z0_abs_nom_thm <- prove_cryptol
  {{ \ xyz -> (fp6_to_fp12_xy00z0 (fp6_abs_nom xyz)) == (fp12_abs_nom (xy00z0_expander xyz)) }} [];

redc_fp12_mod_p_thm <- prove_cryptol
  {{ \x -> redc_mont_fp12 x == apply redc_mont_fp12 (fp12_reduce_mod_p x) }} [];

/* proof plan for mul_by_xy00z0_fp12_equiv_lemma:

    fp12_rep_nom (redc_mont_fp12 (mul_by_xy00z0_fp12' (fp12_abs_nom a) (fp6_abs_nom xyz)))
  ~~> redc_fp6_mod_p_thm, unfold `apply`
    fp12_rep_nom (redc_mont_fp12 (fp12_reduce_mod_p (mul_by_xy00z0_fp12' (fp12_abs_nom a) (fp6_abs_nom xyz))))
  ~~> mul_by_xy00z0_fp12_thm
    fp12_rep_nom (redc_mont_fp12 (Fp_12.mul (fp12_abs_nom a) (fp6_to_fp12_xy00z0 (fp6_abs_nom xyz))))
  ~~> fp6_to_fp12_xy00z0_abs_nom_thm
    fp12_rep_nom (redc_mont_fp12 (Fp_12.mul (fp12_abs_nom a) (fp12_abs_nom (xy00z0_expander xyz))))
  ~~> redc_mont_mul_12_thm
    fp12_rep_nom (toM_12 (Fp_12.mul (fp12_abs a, fp12_abs (xy00z0_expander xyz))))
   ~~> fp12_rep_nom_thm (reversed)
     fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs (xy00z0_expander xyz)))
*/

mul_by_xy00z0_fp12_equiv_lemma <- custom_prove_cryptol
  {{ \ a xyz -> fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs (xy00z0_expander xyz))) ==
         fp12_rep_nom (redc_mont_fp12 (mul_by_xy00z0_fp12 (fp12_abs_nom a) (fp6_abs_nom xyz))) }}
   do { rw_with [redc_fp12_mod_p_thm];
        unfolding ["apply"];
        rw_with_1 mul_by_xy00z0_fp12_thm;
        rw_with_1 fp6_to_fp12_xy00z0_abs_nom_thm;
        rw_with_1 redc_mont_mul_12_thm;
        rw_with_1 fp12_rep_nom_thm;
        w4_unint_z3 ["fp12_rep_nom", "toM_12", "Fp_12", "fp12_abs", "xy00z0_expander"];
        };

select_from_fp6_abs_nom_thms <- for
  [ {{ \ x -> (r0 == fp2_abs_nom (x@2) where [r0,r1,r2] = fp6_abs_nom x) }}
  , {{ \ x -> (r1 == fp2_abs_nom (x@1) where [r0,r1,r2] = fp6_abs_nom x) }}
  , {{ \ x -> (r2 == fp2_abs_nom (x@0) where [r0,r1,r2] = fp6_abs_nom x) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss()) t) ["fp2_abs_nom"] );

select_from_fp6_rep_nom_thms <- for
  [ {{ \ x -> (r0 == fp2_rep_nom (x@2) where [r0,r1,r2] = fp6_rep_nom x) }}
  , {{ \ x -> (r1 == fp2_rep_nom (x@1) where [r0,r1,r2] = fp6_rep_nom x) }}
  , {{ \ x -> (r2 == fp2_rep_nom (x@0) where [r0,r1,r2] = fp6_rep_nom x) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss()) t) ["fp2_rep_nom"] );

fp6x2_rep_seq_thm <- prove_cryptol
  {{ \ x y z -> fp6x2_abs [x, y, z] == [fp2x2_abs z, fp2x2_abs y, fp2x2_abs x] }} [];

// and finally the proof of mul_by_xy00z0_fp12
mul_by_xy00z0_fp12_ovs <- for [mul_by_xy00z0_fp12_spec, mul_by_xy00z0_fp12_alias_spec]
 (\ spec -> custom_verify "mul_by_xy00z0_fp12"
  (concat [ mul_by_xy0_fp6x2_ov, mul_by_0y0_fp6x2_ov
          , mul_fp6x2_ov, redc_fp6x2_ov, add_fp6_ov, add_fp6_aliased_1_3_ov, sub_fp6x2_ov, sub_fp6x2_alias_ov]
          (concat fp2_overrides fp2x2_overrides))
  spec
  do { goal_num_ite 11
         do { // for the main postcondition goal
              rw_with_1 mul_by_xy00z0_fp12_equiv_lemma; // get the post in a moreamenable form
              rw_with [add_fp2_nom_thm, add_fp6_nom_thm]; // get rid of the non-nom abs/rep functions
              simplify (cryptol_ss ());
              rw_with (concat_all [ [ fp6x2_rep_seq_thm, fp6x2_abs_rep_thm, fp2x2_abs_rep_thm
                                    , mul_by_xy0_fp6x2_is_val_thm, mul_by_0y0_fp6x2_is_val_thm
                                    , fp2_abs_rep_nom_thm, fp6_abs_rep_nom_thm]
                                  , fp6x2_is_val_op_thms, fp2x2_is_val_op_thms, fpx2x2_val_at_thms
                                  , fp2x2_abs_at_thms
                                  , select_from_fp6_rep_nom_thms, select_from_fp6_abs_nom_thms
                                  ]);
              unfolding ["fp12_rep_nom", "fp12_abs_nom", "mul_by_xy00z0_fp12", "fp6_abs_nom", "fp6_rep_nom"];
              z3;
            }
         do { // for establishing preconditions of called functions
            rw_with (concat [fp6_abs_rep_add_thm, fp6x2_inv_rep_thm, fp6x2_inv_rep_thm2] fp2x2_thms);
            simplify fp2_simpset;
            unfolding ["fp6x2_rep"];
            rw_with fp2x2_thms;
            w4_unint_z3 fp2_unints;
            };
         });

// ... conjugate_fp12

conjugate_fp12_ov <- custom_verify "conjugate_fp12"
  fp2_overrides
  conjugate_fp12_spec
  do { unfolding ["fp12_conjugate", "f12", "f6", "Fp_6", "Fp_12", "extension_field"
                  ,"fp12_rep", "fp6_rep", "fp12_abs", "fp6_abs",
                  "fp12_invariant", "fp6_invariant"];
       simplify (addsimps propositional_rewrites fp2_simpset);
       w4_unint_z3 fp2_unints; };


// ... frobenius_map_fp12

frobenius_map_fp2_1_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_spec 1)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimps nest_fp2_thms fp_simpset);
         w4_unint_z3 fp_unints;};

frobenius_map_fp2_1_alias_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_alias_spec 1)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimps nest_fp2_thms fp_simpset);
         w4_unint_z3 fp_unints;};

fp_rep_normalize_abs_thm <- admit_cryptol {{ \x -> fp_rep (Fp.normalize (fp_abs x)) == fp_normalize x }};

frobenius_map_fp2_2_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_spec 2)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm] (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

frobenius_map_fp2_2_alias_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_alias_spec 2)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm] (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

fp_neg_normalize_thm <- prove_cryptol {{ \x -> Fp.neg (Fp.normalize x) == Fp.neg x }} [];

frobenius_map_fp2_3_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_spec 3)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm, fp_neg_normalize_thm]
                            (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

frobenius_map_fp2_3_alias_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_alias_spec 3)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm, fp_neg_normalize_thm]
                            (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

frobenius_constant_thms <- for [
    {{ fp2_invariant rep_v_frobenius_constant == True }}
  , {{ fp2_abs       rep_v_frobenius_constant ==  v_frobenius_constant }}
  , {{ fp2_invariant rep_v_frobenius_constant_sq == True }}
  , {{ fp2_abs       rep_v_frobenius_constant_sq ==  v_frobenius_constant_sq }}
  , {{ fp_invariant  rep_v_frobenius_constant_sq_const_part == True }}
  , {{ fp_abs        rep_v_frobenius_constant_sq_const_part ==  v_frobenius_constant_sq!0 }}
  , {{ fp2_invariant rep_w_frobenius_constant_const_part == True }}
  , {{ fp2_abs       rep_w_frobenius_constant_const_part ==  w_frobenius_constant!0 }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss ())
                          (unfold_term [ "rep_v_frobenius_constant"
                                       , "rep_v_frobenius_constant_sq"
                                       , "rep_v_frobenius_constant_sq_const_part"
                                       , "rep_w_frobenius_constant_const_part"
                                       ] t))
                         []);


fp2_mul_v_sq_thm <- prove_cryptol
// {{ \ x y -> Fp_2.mul (v_frobenius_constant_sq, [x,y])
//             == [Fp.mul (x, v_frobenius_constant_sq!0), Fp.mul (y, v_frobenius_constant_sq!0)] }}
 {{ \ x -> Fp_2.mul (v_frobenius_constant_sq, x)
             == [Fp.mul (x@0, v_frobenius_constant_sq!0), Fp.mul (x@1, v_frobenius_constant_sq!0)] }}
 [];

fp2_mul_comutes_thm <- prove_cryptol {{ \x y -> Fp_2.mul (x, y) == apply Fp_2.mul (y,x) }} [];

frobenius_map_fp6_1_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_1_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_spec 1)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with frobenius_constant_thms;
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };


frobenius_map_fp6_1_alias_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_1_alias_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_alias_spec 1)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with frobenius_constant_thms;
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       // w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };
       w4_unint_z3 (concat fp_unints fp2_unints); };

// For double Frobenius:
frobenius_2_constant_thms <- for [
    {{ fp2_invariant rep_v_frobenius_constant_2 == True }}
  , {{ fp2_abs       rep_v_frobenius_constant_2 ==  v_frobenius_constant_2 }}
  , {{ fp_invariant rep_v_frobenius_constant_2_sq_const_part == True }}
  , {{ fp_abs       rep_v_frobenius_constant_2_sq_const_part ==  v_frobenius_constant_2_sq @ 1}}
  , {{ fp2_invariant rep_w_frobenius_constant_2_const_part == True }}
  , {{ fp2_abs       rep_w_frobenius_constant_2_const_part == w_frobenius_constant_2_part }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss ())
                          (unfold_term [ "rep_v_frobenius_constant_2"
                                       , "rep_v_frobenius_constant_2_sq_const_part"
                                       , "rep_w_frobenius_constant_2_const_part"
                                       ] t))
                         []);

fp2_mul_v_sq_2_thm <- prove_cryptol
 {{ \ x -> Fp_2.mul (v_frobenius_constant_2_sq, x)
             == [Fp.mul (x@0, v_frobenius_constant_2_sq@1), Fp.mul (x@1, v_frobenius_constant_2_sq@1)] }}
 [];

frobenius_2_theorems <- for
  [ // {{ \x -> fp2_frobenius (fp2_frobenius x) == [Fp.normalize (x@0), x@1] }}
  // ,
  {{ \x -> fp6_frobenius (fp6_frobenius x) == fp6_frobenius2 x }}
  ] (\t -> prove_cryptol t []);

frobenius_map_fp6_2_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_2_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_spec 2)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_2_theorems frobenius_2_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius2", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_2_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };

frobenius_map_fp6_2_alias_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_2_alias_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_alias_spec 2)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_2_theorems frobenius_2_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius2", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_2_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       // w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };
       w4_unint_z3 (concat fp_unints fp2_unints); };


// for triple Frobenius
frobenius_3_constant_thms <- for [
    {{ fp2_invariant rep_v_frobenius_constant_3 == True }}
  , {{ fp2_abs       rep_v_frobenius_constant_3 ==  v_frobenius_constant_3 }}
  , {{ fp_invariant rep_v_frobenius_constant_3_sq_const_part == True }}
  , {{ fp_abs       rep_v_frobenius_constant_3_sq_const_part ==  v_frobenius_constant_3_sq @ 1}}
  , {{ fp2_invariant rep_w_frobenius_constant_3_const_part == True }}
  , {{ fp2_abs       rep_w_frobenius_constant_3_const_part == w_frobenius_constant_3_part }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss ())
                          (unfold_term [ "rep_v_frobenius_constant_3"
                                       , "rep_v_frobenius_constant_3_sq_const_part"
                                       , "rep_w_frobenius_constant_3_const_part"
                                       ] t))
                         []);

fp2_mul_v_sq_3_thm <- prove_cryptol
 {{ \ x -> Fp_2.mul (v_frobenius_constant_3_sq, x)
             == [Fp.mul (x@0, v_frobenius_constant_3_sq@1), Fp.mul (x@1, v_frobenius_constant_3_sq@1)] }}
 [];

frobenius_3_theorems <- for
  [ {{ \x -> fp2_frobenius (fp2_frobenius (fp2_frobenius x)) == fp2_frobenius x }}
  , {{ \x -> fp6_frobenius (fp6_frobenius (fp6_frobenius x)) == fp6_frobenius3 x }}
  ] (\t -> prove_cryptol t []);

frobenius_map_fp6_3_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_3_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_spec 3)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_3_theorems frobenius_3_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius3", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_3_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant_3", "v_frobenius_constant_3_sq"] (concat fp_unints fp2_unints)); };

frobenius_map_fp6_3_alias_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_3_alias_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_alias_spec 3)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_3_theorems frobenius_3_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius3", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_3_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant_3", "v_frobenius_constant_3_sq"] (concat fp_unints fp2_unints)); };

// Finally, fp12_frobenius_map

// For the fp2 multiplications in frobenius_map_fp12:

fp6_mul_w_const_thm <- prove_cryptol
  {{ \ x -> Fp_6.mul (w_frobenius_constant, x) == [Fp_2.mul(x@0,c), Fp_2.mul(x@1,c), Fp_2.mul(x@2,c)] where
     c = w_frobenius_constant!0 }}
  [];

frobenius_map_fp12_1_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_1_ov] fp2_overrides)
    (frobenius_map_fp12_spec 1)
    do {
       rw_with (concat nest_fp6_thms frobenius_constant_thms);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps [fp6_mul_w_const_thm] fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_map_fp12_1_alias_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_1_alias_ov] fp2_overrides)
    (frobenius_map_fp12_alias_spec 1)
    do {
       rw_with (concat nest_fp6_thms frobenius_constant_thms);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps [fp6_mul_w_const_thm] fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_12_2_theorems <- for
  [ {{ \x -> fp12_frobenius (fp12_frobenius x) == fp12_frobenius2 x }}
  , {{ \ x -> Fp_6.mul (Fp_2_to_Fp_6 c, x) == [Fp_2.mul(x@0,c), Fp_2.mul(x@1,c), Fp_2.mul(x@2,c)] where
              c = w_frobenius_constant_2_part }}
  ] (\t -> prove_cryptol t []);

frobenius_map_fp12_2_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_2_ov] fp2_overrides)
    (frobenius_map_fp12_spec 2)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_2_constant_thms, frobenius_12_2_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius2", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_2_theorems fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_map_fp12_2_alias_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_2_alias_ov] fp2_overrides)
    (frobenius_map_fp12_alias_spec 2)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_2_constant_thms, frobenius_12_2_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius2", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_2_theorems fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_12_3_theorems <- for
  [ {{ \x -> fp12_frobenius (fp12_frobenius (fp12_frobenius x)) == fp12_frobenius3 x }}
  , {{ \ x -> Fp_6.mul (Fp_2_to_Fp_6 c, x) == [Fp_2.mul(x@0,c), Fp_2.mul(x@1,c), Fp_2.mul(x@2,c)] where
              c = w_frobenius_constant_3_part }}
  ] (\t -> prove_cryptol t []);


frobenius_map_fp12_3_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_3_ov] fp2_overrides)
    (frobenius_map_fp12_spec 3)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_3_constant_thms, frobenius_12_3_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius3", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_3_theorems fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_map_fp12_3_alias_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_3_alias_ov] fp2_overrides)
    (frobenius_map_fp12_alias_spec 3)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_3_constant_thms, frobenius_12_3_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius3", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_3_theorems fp2_simpset);
       w4_unint_z3 (concat ["Fp_4"] fp2_unints); };


// ... cyclotomic squaring

more_fp2_alg_thms <- for
  [ {{ \ x y -> Fp_2.add(x, Fp_2.normalize y) == Fp_2.add (x, y) }}
  , {{ \ x y -> Fp_2.neg (Fp_2.add (x, y)) == Fp_2.add (Fp_2.neg x, Fp_2.neg y) }}
  ] (\ t -> prove_cryptol t []);

let all_fp2_alg_thms = concat fp2_alg_thms more_fp2_alg_thms;

sqr_fp4_ov <- admit "sqr_fp4" sqr_fp4_spec; //TODO - prove

// mul_by_u_plus_1_fp2 directly calls an assembly-language subroutine
mul_by_u_plus_1_fp2_alias_ov <- admit "mul_by_u_plus_1_fp2" mul_by_u_plus_1_fp2_alias_spec;
mul_by_u_plus_1_fp2_ov <- admit "mul_by_u_plus_1_fp2" mul_by_u_plus_1_fp2_spec;

fp4_mul_thm <- prove_cryptol
  {{ \x y -> Fp_4.mul (x, y) == [ Fp_2.add (Fp_2.mul(x@0,y@1), Fp_2.mul(x@1, y@0))
                                , Fp_2.add(Fp_2.mul(u_plus_1, Fp_2.mul(x@0, y@0)), Fp_2.mul (x@1, y@1))
                                ] }} [];

fp4_add_thm <- prove_cryptol {{ \x y -> Fp_4.add (x, y) == [Fp_2.add (x@0, y@0), Fp_2.add(x@1, y@1)] }} [];
fp4_sub_thm <- prove_cryptol {{ \x y -> Fp_4.sub (x, y) == [Fp_2.sub (x@0, y@0), Fp_2.sub(x@1, y@1)] }} [];

cyclotomic_sqr_equiv_thm <- custom_prove_cryptol
  {{ \x -> cyclotomic_sqr_fp12 x == cyclotomic_sqr_fp12_imp x }}
  do { // unfolding_non ["Fp_4", "Fp_2"];
       unfolding ["cyclotomic_sqr_fp12", "cyclotomic_sqr_fp12_imp", "Fp_12_alt_to_Fp_12"
                 , "cyclotomic_sqr_alt", "Fp_12_to_Fp_12_alt"];
       rw_with [fp4_mul_thm, fp4_add_thm, fp4_sub_thm];
       rw_with all_fp2_alg_thms;  // you would think this step unnecesary, but it is not!
       w4_unint_z3 ["Fp_4"]; } ;


cyclotomic_sqr_fp12_ovs <- for [cyclotomic_sqr_fp12_spec, cyclotomic_sqr_fp12_alias_spec]
 (\ spec -> custom_verify "cyclotomic_sqr_fp12"
  (concat [sqr_fp4_ov, mul_by_u_plus_1_fp2_alias_ov] fp2_overrides)
  spec
  do { rw_with_1 cyclotomic_sqr_equiv_thm;
       unfolding [ "cyclotomic_sqr_fp12_imp", "fp12_invariant", "fp6_invariant", "fp4_rep", "fp4_abs"
                 , "fp12_rep", "fp6_rep", "fp12_abs", "fp6_abs"];
       rw_with_1 fp2_invariant_alt_seq_thm;
       simplify (addsimps fp2_alg_thms fp2_simpset);
       w4_unint_z3 fp2_unints; }) ;

// ... squaring in fp_12

fp12_sqr_equiv_thm <-  prove_cryptol {{ \ x -> Fp_12.sq x == fp12_sqr x }} [];

sqr_fp12_ovs <- for [sqr_fp12_spec, sqr_fp12_alias_spec]
 ( \ s -> custom_verify "sqr_fp12"
  (concat [ add_fp6_ov , sub_fp6_ov, mul_fp6_ov, mul_fp6_aliased_ov, mul_by_u_plus_1_fp2_ov
          , mul_by_u_plus_1_fp2_alias_ov
          ]  fp2_overrides)
  s // the spec
  do { 
       goal_num_when 13 do { // for the final goal: we return the correct expression.
           rw_with_1 fp12_sqr_equiv_thm;
           unfolding ["fp12_sqr", "fp12_rep", "fp12_abs", "fp6_rep", "fp6_abs"];
           // (unfolding fp6_abs and _rep because we do not have the abs_rep rules..)
           simplify fp2_simpset;
           rw_with_1 fp6_unrip_thm;
           };
       w4_unint_z3 ["Fp_6", "Fp_2", "u_plus_1"];
       });

// ... inverse in fp_12

// uses squaring, so we start with that

sqr_fp6_ov <- admit "sqr_fp6" sqr_fp6_spec;  // TODO

eucl_inverse_fp_ov <- admit "eucl_inverse_fp" eucl_inverse_fp_spec;

inverse_fp2_ov <- custom_verify "inverse_fp2"
  (concat [eucl_inverse_fp_ov] fp_overrides)
  inverse_fp2_spec
  do { unfolding ["inverse_fp2_imp", "fp2_rep", "fp2_abs"];
       simplify fp_simpset;
       w4_unint_z3 fp_unints; };

// Algebraic fact: in fp2, inverse of a+bu is (a-bu)/(a^2+b^2)
// ... which also works for a == b == 0, when both are 0.
// Proof: if a==b==0, then both sides are 0
// otherwise, (a+bu)(a-bu) = a^2 - u^2 b^2 = a^2 + b^2 and simple algebra completes the proof.
// Note that a^2 = -b^2 implies a==b==0, since -1 is not a quadratic residue.
inverse_fp2_thm <- admit_cryptol
{{ \x -> (Fp_2.div (Fp_2.field_unit, x) == [Fp.neg(Fp.div (c, m)), Fp.div (a, m)] where
            [c, a] = x
            m = Fp.add (Fp.sq a, Fp.sq c)) }};

// Algebraic fact
mul_div_fp_unit_thm <- admit_cryptol {{ \x z -> Fp.mul (x, Fp.div (Fp.field_unit,z)) == Fp.div (x, z) }};

inverse_fp2_thm' <- custom_prove_cryptol
  {{ \x -> inverse_fp2_imp x == Fp_2.div(Fp_2.field_unit, x) }}
  do { unfolding ["inverse_fp2_imp"];
       simplify (addsimps [inverse_fp2_thm,mul_div_fp_unit_thm] (addsimps fp_alg_thms fp_simpset));
       w4_unint_z3 fp_unints; };

inverse_fp6_ov <- custom_verify "inverse_fp6"
  (concat [inverse_fp2_ov, mul_by_u_plus_1_fp2_alias_ov] fp2_overrides)
  inverse_fp6_spec
  do { unfolding ["inverse_fp6_imp", "fp6_rep", "fp6_abs"];
       simplify fp2_simpset;
       w4_unint_z3 (concat ["inverse_fp2_imp"] fp2_unints); };

/* Algebraic fact:
   the inverse of a+bv+cv^2 is (A+Bv+Cv^2)/D where
   A = a^2 - (u+1)bc
   B = (u+1)c^2 - ab
   C = b^2 - ac
   D = 
   as can be verified by multiplication, noting that v^3 = (u+1) and (u+1)^2 = 2u 
     (a + bv + cv^2)(A + Bv + Cv^2)
   = (aA + bCv^3 + cBv^3) + (aB + bA + cCv^3)v + (aC + bB + cA)v^2
   = (a^3 - (u+1)abc + b^3 - abc + c(u+1)^2 - (u+1)abc)
     + ((u+1)ac^2 + 
*/
// We can prove the multiplying-out part of that
custom_prove_cryptol
 {{ \ a2 a1 a0 -> (Fp_6.mul ([a2,a1,a0], [c2,c1,c0]) == [z,z,t1] where
    c0 = Fp_2.sub (Fp_2.sq a0, Fp_2.mul (u_plus_1,Fp_2.mul (a1,a2)))
    c1 = Fp_2.sub (Fp_2.mul (u_plus_1, Fp_2.sq a2), Fp_2.mul(a0,a1))
    c2 = Fp_2.sub (Fp_2.sq a1, Fp_2.mul (a0, a2))
    t0 = Fp_2.add (Fp_2.mul (c1, a2), Fp_2.mul (c2, a1))
    t1 = Fp_2.add (Fp_2.mul (u_plus_1, t0), Fp_2.mul (c0, a0))
    z = Fp_2.field_zero ) }}
 do { goal_eval_unint fp2_unints;
      simplify (addsimps fp2_alg_thms fp2_simpset);
      z3; };

// ... but assume the fact
inverse_fp6_thm <- admit_cryptol
  {{ \x -> (Fp_6.div (Fp_6.field_unit, x) == [c2',c1',c0'] where
    [a2,a1,a0] = x
    c0 = Fp_2.sub (Fp_2.sq a0, Fp_2.mul (u_plus_1,Fp_2.mul (a1,a2)))
    c1 = Fp_2.sub (Fp_2.mul (u_plus_1, Fp_2.sq a2), Fp_2.mul(a0,a1))
    c2 = Fp_2.sub (Fp_2.sq a1, Fp_2.mul (a0, a2))
    t0 = Fp_2.add (Fp_2.mul (c1, a2), Fp_2.mul (c2, a1))
    t1 = Fp_2.add (Fp_2.mul (u_plus_1, t0), Fp_2.mul (c0, a0))
    c0' = Fp_2.div (c0, t1)
    c1' = Fp_2.div (c1, t1)
    c2' = Fp_2.div (c2, t1) )
    }};

// Algebra
// Some additional algebraic rules for Fp_2.div operations:
mul_div_fp2_thm <- admit_cryptol {{ \x y z -> Fp_2.mul (x, Fp_2.div (y,z)) == Fp_2.div (Fp_2.mul (x, y), z) }};
div_neg_fp2_thm <- admit_cryptol {{ \x y  -> Fp_2.div (Fp_2.neg x,y) == Fp_2.neg (Fp_2.div (x, y)) }};
div_absorbs_normalization_fp2_thm <- admit_cryptol
  {{ \ x y -> Fp_2.div(Fp_2.normalize x, y) == Fp_2.div (x, y) }};

inverse_fp6_thm' <- custom_prove_cryptol
  {{ \x -> inverse_fp6_imp x == Fp_6.div(Fp_6.field_unit, x) }}
  do { unfolding ["inverse_fp6_imp"];
       simplify (addsimps [inverse_fp6_thm, inverse_fp2_thm', mul_div_fp2_thm, div_absorbs_normalization_fp2_thm]
                   (addsimps fp2_alg_thms fp2_simpset));
       w4_unint_z3 fp2_unints; };

// Algebraic fact: in fp12, inverse of a+bw is (a-bw)/(a^2-vb^2)
// ... which also works for a == b == 0, when both are 0.
// Proof: if a==b==0, then both sides are 0
// otherwise, (a+bw)(a-bw) = a^2 - w^2 b^2 = a^2 - vb^2 and simple algebra completes the proof.
// Note that a^2 = vb^2 implies a==b==0 as v is not a quadratic residue.
let {{
 inverse_fp12': t_Fp_12 -> t_Fp_12
 inverse_fp12' [a1,a0] = [r1,r0] where
  t = Fp_6.div(Fp_6.field_unit, Fp_6.sub (Fp_6.sq a0, Fp_6.mul(v, Fp_6.sq a1)))
  r0 = Fp_6.mul (a0,t)
  r1 = Fp_6.neg (Fp_6.mul (a1,t))
  }};

inverse_fp12_thm <- admit_cryptol
  {{ \x -> Fp_12.div (Fp_12.field_unit, x) == inverse_fp12' x }};

fp_6_mul_by_v_thm <- prove_cryptol {{ \x ->
  (Fp_6.mul (v, x) == [Fp_2.normalize x1, Fp_2.normalize x2, Fp_2.mul(u_plus_1, x0)] where [x0,x1,x2] = x) }} [];

fp_6_mul_by_v_thm' <- prove_cryptol {{ \x ->
  (Fp_6.mul (v, x) == [Fp_2.normalize x1, Fp_2.normalize x2, Fp_2.mul(x0, u_plus_1)] where [x0,x1,x2] = x) }} [];

fp2_is_val_op_thms <- for [{{ Fp_2.mul }} , {{ Fp_2.add }}, {{ Fp_2.sub }} ]
  (\ t -> prove_cryptol {{ \ p -> Fp_2.is_val (t p) == True }} []);

fp2_normalize_op_thms <- for [{{ Fp_2.mul }} , {{ Fp_2.add }}, {{ Fp_2.sub }} ]
  (\ t -> prove_cryptol {{ \ p -> Fp_2.normalize (t p) == t p }} []);

fp2_normalize_at_thms <- for
  [ {{ \ x -> (Fp_2.normalize r0 == r0 where [r0,r1,r2] = Fp_6.mul x) }}
  , {{ \ x -> (Fp_2.normalize r1 == r1 where [r0,r1,r2] = Fp_6.mul x) }}
  , {{ \ x -> (Fp_2.normalize r2 == r2 where [r0,r1,r2] = Fp_6.mul x) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss()) t) []);

fp6_mul_neg_thm <- prove_cryptol
  {{ \x y -> Fp_6.mul (x, Fp_6.neg y) == Fp_6.neg (Fp_6.mul (x, y)) }} [];

add_fp6_expansion_thm <- prove_cryptol
  {{ \ x y -> (Fp_6.add (x, y) == [Fp_2.add (x0,y0), Fp_2.add (x1,y1), Fp_2.add (x2,y2)] where
                [x0,x1,x2] = x
                [y0,y1,y2] = y) }} ["Fp_2"];

neg_fp6_expansion_thm <- prove_cryptol
  {{ \ x -> (Fp_6.neg x == [Fp_2.neg x0, Fp_2.neg x1, Fp_2.neg x2] where
                [x0,x1,x2] = x ) }} ["Fp_2"];

inverse_fp12_equiv_thm <- custom_prove_cryptol {{ \a -> inverse_fp12' a == inverse_fp12_imp a }}
  do { unfolding ["inverse_fp12_imp", "inverse_fp12'"];
       rw_with_1 fp_6_mul_by_v_thm';
       rw_with_1 inverse_fp6_thm';
       simplify (addsimps [add_fp6_expansion_thm, neg_fp6_expansion_thm]
                  (addsimps fp2_alg_thms
                    (addsimps fp6_alg_thms
                      (addsimps fp2_normalize_at_thms (cryptol_ss())))));
       w4_unint_z3 ["Fp_6", "Fp_2"];
       };

neg_fp6_alias_ov <- verify_unint "neg_fp6" fp2_overrides fp2_unints neg_fp6_alias_spec;

let fp6_overrides = [ mul_fp6_ov, mul_fp6_aliased_ov, add_fp6_ov, add_fp6_aliased_1_3_ov
                    , neg_fp6_alias_ov
                    , sub_fp6_ov, sqr_fp6_ov, mul_by_u_plus_1_fp2_ov, mul_by_u_plus_1_fp2_alias_ov];

// see also unrip_thm_2
fp2_rep_unrip_thm <- prove_cryptol
   (rewrite (cryptol_ss ()) {{ \ (x:[2][6][64]) -> ([x0,x1] == x where [x0,x1] = x)}}) [];

fp6_abs_rep_thms <- for
  [ {{ \ x -> fp6_abs (fp6_rep (inverse_fp6_imp x)) == inverse_fp6_imp x }}
  , {{ \ x -> fp6_abs (fp6_rep (Fp_6.mul x)) == Fp_6.mul x }}
  ] (\t ->  custom_prove_cryptol t
      do { goal_eval_unint ["Fp_2", "inverse_fp2_imp", "fp2_abs", "fp2_rep"];
           simplify (addsimps [fp2_unrip_thm, unrip_thm, fp2_rep_unrip_thm] fp2_simpset);
           w4_unint_z3 ["Fp_2", "inverse_fp2_imp", "fp2_abs", "fp2_rep"]; });


fp2_abs_at_thms <- for [0,1,2]
  (\ i -> custom_prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> fp2_abs ((fp6_rep x) @ (`i:[2])) ==
          if Fp_6.is_val x then x @ (((2-`i):[2])) else apply fp2_abs ((fp6_rep x) @ (`i:[2])) }})
       do { unfolding ["fp6_rep", "apply"];
            rw_with fp2_rep_thms;
            w4_unint_z3 ["Fp_2"]; } );

fp6_is_val_op_thms <- for [{{ Fp_6.mul }} , {{ Fp_6.add }}, {{ Fp_6.sub }}, {{ Fp_6.sq }}]
  (\ t -> prove_cryptol {{ \ p -> Fp_6.is_val (t p) == True }} []);

fp6_is_val_inverse_thm <- custom_prove_cryptol {{ \ x -> Fp_6.is_val (inverse_fp6_imp x) == True }}
      do { goal_eval_unint ["Fp_2", "inverse_fp2_imp"];
           rw_with (concat [fp2_unrip_thm] fp2_is_val_op_thms);
           z3; };

fp6_abs_seq_thm <- custom_prove_cryptol
  {{ \ x y z -> fp6_abs [fp2_rep x, fp2_rep y, fp2_rep z] == [z,y,x] }}
  do { unfolding ["fp6_abs"]; simplify fp2_simpset; w4_unint_z3 fp2_unints; };

// possibly looping, use with care
fp2_mul_u_plus_1_reordering_thm <- prove_cryptol
  {{ \ x -> Fp_2.mul (x, u_plus_1) == Fp_2.mul (u_plus_1, x) }} [];

inverse_fp12_ov <- custom_verify "inverse_fp12"
  (concat_all [[inverse_fp6_ov, mul_by_u_plus_1_fp2_alias_ov], fp2_overrides, fp6_overrides])
  inverse_fp12_spec
  do { unfolding ["inverse_fp12_imp", "fp12_rep", "fp12_abs"];
       goal_num_ite 10
         do { // For the final goal
           // rewrite the given post to use `inverse_fp12_imp`
           rw_with [inverse_fp12_thm, inverse_fp12_equiv_thm];
           unfolding ["inverse_fp12_imp"];
           rw_with (concat_all [fp6_abs_rep_thms, fp2_abs_at_thms, fp6_is_val_op_thms
                               , [fp6_abs_seq_thm, fp6_is_val_inverse_thm,fp2_mul_u_plus_1_reordering_thm]]);
          simplify fp2_simpset;
           w4_unint_z3 ["Fp_6", "Fp_2", "fp2_rep", "fp2_abs", "fp2_invariant", "inverse_fp6_imp", "u_plus_1"];
           }
         do { // for establishing preconditions of called functions
          unfolding ["fp6_invariant", "fp6_rep", "fp6_abs"];
          simplify fp2_simpset;
          w4_unint_z3 fp2_unints; };
        };



/*
sqr_fp12_ov <- verify "sqr_fp12" assembly_overrides sqr_fp12_spec;
sqr_fp12_alias_ov <- verify "sqr_fp12" assembly_overrides sqr_fp12_alias_spec;
cyclotomic_sqr_fp12_ov <- verify "cyclotomic_sqr_fp12" assembly_overrides cyclotomic_sqr_fp12_spec;
cyclotomic_sqr_fp12_alias_ov <- verify "cyclotomic_sqr_fp12" assembly_overrides cyclotomic_sqr_fp12_alias_spec;
mul_fp12_ov <- verify "mul_fp12" assembly_overrides mul_fp12_spec;
mul_fp12_alias_ov <- verify "mul_fp12" assembly_overrides mul_fp12_alias_spec;
mul_by_xy00z0_fp12_ov <- verify "mul_by_xy00z0_fp12" assembly_overrides mul_by_xy00z0_fp12_spec;
mul_by_xy00z0_fp12_alias_ov <- verify "mul_by_xy00z0_fp12" assembly_overrides mul_by_xy00z0_fp12_alias_spec;
conjugate_fp12_ov <- verify "conjugate_fp12" assembly_overrides conjugate_fp12_spec;
inverse_fp12_ov <- verify "inverse_fp12" assembly_overrides inverse_fp12_spec;
let make_frobenius_map_fp12_ov n = verify "frobenius_map_fp12" assembly_overrides (frobenius_map_fp12_spec n);
frobenius_map_fp12_ovs <- for [1,2,3] make_frobenius_map_fp12_ov; // NOTE: this could be verified for any 0 < n <= 3, but it fails with that precondition in the spec
let make_frobenius_map_fp12_alias_ov n = verify "frobenius_map_fp12" assembly_overrides (frobenius_map_fp12_alias_spec n);
frobenius_map_fp12_alias_ovs <- for [1,2,3] make_frobenius_map_fp12_alias_ov; // NOTE: this could be verified for any 0 < n <= 3, but it fails with that precondition in the spec

let fp12_tower_ovs = foldr concat [frobenius_map_fp12_alias_ovs, frobenius_map_fp12_ovs, [sqr_fp12_alias_ov, sqr_fp12_ov, mul_fp12_alias_ov, mul_fp12_ov, mul_by_xy00z0_fp12_alias_ov, mul_by_xy00z0_fp12_ov, conjugate_fp12_ov, inverse_fp12_ov, cyclotomic_sqr_fp12_ov, cyclotomic_sqr_fp12_alias_ov]] [];
*/
