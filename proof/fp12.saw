/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

/* NOTE: used in pairing.c:
  mul_by_xy00z0_fp12,
  sqr_fp12,
  conjugate_fp12, [Done]
  mul_fp12,
  cyclotomic_sqr_fp12, [Done, except for some subroutines]
  frobenius_map_fp12 [Done]
  inverse_fp12
*/

import "../spec/Parameters.cry";
import "../spec/ExtensionField.cry";
import "../spec/Frobenius.cry";
import "../spec/implementation/Field.cry";
import "../spec/implementation/Fp12.cry";

let vec384fp4_type = llvm_array 2 vec384x_type; // only used in this file

///////////////////////////////////////////////////////////////////////////////
// Specifications
///////////////////////////////////////////////////////////////////////////////



let sqr_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.sq (fp12_abs a)) }});
};

let sqr_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  crucible_execute_func [ret_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.sq (fp12_abs a)) }});
};

let mul_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_precond {{ fp12_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs b)) }});
};

let mul_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_precond {{ fp12_invariant b }};
  crucible_execute_func [ret_ptr, ret_ptr, b_ptr];
  new_ret <- crucible_fresh_var "new_mul_fp12_alias_ret" vec384fp12_type;
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (Fp_12.mul (fp12_abs a, fp12_abs b)) }});
};

let conjugate_fp12_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [a_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp12_rep (fp12_conjugate (fp12_abs a)) }});
};


let frobenius_map_fp12_spec n = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term
    (if eval_bool {{`n == 0x1}}
     then {{ fp12_rep (fp12_frobenius (fp12_abs a)) }}
     else if eval_bool {{ `n == 0x2 }}
     then {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_abs a))) }}
     else {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_frobenius (fp12_abs a)))) }} ));
};

let frobenius_map_fp12_alias_spec n = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term
    (if eval_bool {{`n == 0x1}}
     then {{ fp12_rep (fp12_frobenius (fp12_abs a)) }}
     else if eval_bool {{ `n == 0x2 }}
     then {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_abs a))) }}
     else {{ fp12_rep (fp12_frobenius (fp12_frobenius (fp12_frobenius (fp12_abs a)))) }} ));
};


// The cyclotomic square returns the square of its input PROVIDED that input is in the
// "cyclotomic subgroup" -- that is, its, `p^4-p^2+1` power is 1.
let cyclotomic_sqr_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (cyclotomic_sqr_fp12 (fp12_abs a)) }});
};

let cyclotomic_sqr_fp12_alias_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384fp12_type;
  crucible_precond {{ fp12_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp12_rep (cyclotomic_sqr_fp12 (fp12_abs a)) }});

};

// not done


let mul_by_xy00z0_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (_, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  (_, xy00z0_ptr) <- ptr_to_fresh_readonly "xy00z0" vec384fp6_type;
  crucible_execute_func [ret_ptr, a_ptr, xy00z0_ptr];
  new_mul_by_xy00z0_fp12_ret <- crucible_fresh_var "new_mul_by_xy00z0_fp12_ret" vec384fp12_type;
  crucible_points_to ret_ptr (crucible_term new_mul_by_xy00z0_fp12_ret);
};

let mul_by_xy00z0_fp12_alias_spec = do {
  (_, ret_ptr) <- ptr_to_fresh "a" vec384fp12_type;
  (_, xy00z0_ptr) <- ptr_to_fresh_readonly "xy00z0" vec384fp6_type;
  crucible_execute_func [ret_ptr, ret_ptr, xy00z0_ptr];
  new_mul_by_xy00z0_fp12_alias_ret <- crucible_fresh_var "new_mul_by_xy00z0_fp12_alias_ret" vec384fp12_type;
  crucible_points_to ret_ptr (crucible_term new_mul_by_xy00z0_fp12_alias_ret);
};


let inverse_fp12_spec = do {
  ret_ptr <- crucible_alloc vec384fp12_type;
  (_, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp12_type;
  crucible_execute_func [ret_ptr, a_ptr];
  new_inverse_fp12_ret <- crucible_fresh_var "new_inverse_fp12_ret" vec384fp12_type;
  crucible_points_to ret_ptr (crucible_term new_inverse_fp12_ret);
};


// For proof development:

let {{
  ff_zero_fp = Fp.field_zero
  ff_unit_fp = Fp.field_unit
  ff_mul_fp = Fp.mul
  ff_sq_fp  = Fp.sq
  ff_add_fp = Fp.add
  ff_sub_fp = Fp.sub
  ff_neg_fp = Fp.neg

  ff_zero_fp2 = Fp_2.field_zero
  ff_unit_fp2 = Fp_2.field_unit
  ff_mul_fp2 = Fp_2.mul
  ff_sq_fp2  = Fp_2.sq
  ff_add_fp2 = Fp_2.add
  ff_sub_fp2 = Fp_2.sub
  ff_neg_fp2 = Fp_2.neg
  }};

ff_cover_thms <- for
 [ 
   {{ Fp.field_zero == ff_zero_fp }}
 , {{ Fp.field_unit == ff_unit_fp }}
 , {{ \x -> Fp.mul x == ff_mul_fp x}}
 , {{ \x -> Fp.add x == ff_add_fp x }}
 , {{ \x -> Fp.sub x == ff_sub_fp x }}
 , {{ \x -> Fp.sq x == ff_sq_fp x }}
 , {{ \x -> Fp.neg x == ff_neg_fp x }}

 , {{ Fp_2.field_zero == ff_zero_fp2 }}
 , {{ Fp_2.field_unit == ff_unit_fp2 }}
 , {{ \x -> Fp_2.mul x == ff_mul_fp2 x}}
 , {{ \x -> Fp_2.add x == ff_add_fp2 x }}
 , {{ \x -> Fp_2.sub x == ff_sub_fp2 x }}
 , {{ \x -> Fp_2.sq x == ff_sq_fp2 x }}
 , {{ \x -> Fp_2.neg x == ff_neg_fp2 x }}
 ] ( \t -> prove_cryptol t [] );

ff_uncover_thms <- for
 [ 
   {{ ff_zero_fp == Fp.field_zero }}
 , {{ ff_unit_fp == Fp.field_unit }}
 , {{ \x -> ff_mul_fp x == Fp.mul x }}
 , {{ \x -> ff_add_fp x == Fp.add x }}
 , {{ \x -> ff_sub_fp x == Fp.sub x }}
 , {{ \x -> ff_sq_fp x == Fp.sq x }}
 , {{ \x -> ff_neg_fp x == Fp.neg x }}

 , {{ ff_zero_fp2 == Fp_2.field_zero }}
 , {{ ff_unit_fp2 == Fp_2.field_unit }}
 , {{ \x -> ff_mul_fp2 x == Fp_2.mul x }}
 , {{ \x -> ff_add_fp2 x == Fp_2.add x }}
 , {{ \x -> ff_sub_fp2 x == Fp_2.sub x }}
 , {{ \x -> ff_sq_fp2 x == Fp_2.sq x }}
 , {{ \x -> ff_neg_fp2 x == Fp_2.neg x }}
 ] ( \t -> prove_cryptol t [] );

let expand_fp2 = do {
  simplify (addsimps ff_cover_thms (cryptol_ss ()));
  };

let {{
  ff_zero_fp2x2 = Fp_2x2.field_zero
  ff_unit_fp2x2 = Fp_2x2.field_unit
  ff_mul_fp2x2 = Fp_2x2.mul
  ff_sq_fp2x2  = Fp_2x2.sq
  ff_add_fp2x2 = Fp_2x2.add
  ff_sub_fp2x2 = Fp_2x2.sub
  ff_neg_fp2x2 = Fp_2x2.neg
  }};

ffx2_cover_thms <- for
 [ {{ Fp_2x2.field_zero == ff_zero_fp2x2 }}
 , {{ Fp_2x2.field_unit == ff_unit_fp2x2 }}
 , {{ \x -> Fp_2x2.mul x == ff_mul_fp2x2 x}}
 , {{ \x -> Fp_2x2.add x == ff_add_fp2x2 x }}
 , {{ \x -> Fp_2x2.sub x == ff_sub_fp2x2 x }}
 , {{ \x -> Fp_2x2.sq x == ff_sq_fp2x2 x }}
 , {{ \x -> Fp_2x2.neg x == ff_neg_fp2x2 x }}
 ] ( \t -> prove_cryptol t [] );

ffx2_uncover_thms <- for
 [ {{ ff_zero_fp2x2 == Fp_2x2.field_zero }}
 , {{ ff_unit_fp2x2 == Fp_2x2.field_unit }}
 , {{ \x -> ff_mul_fp2x2 x == Fp_2x2.mul x }}
 , {{ \x -> ff_add_fp2x2 x == Fp_2x2.add x }}
 , {{ \x -> ff_sub_fp2x2 x == Fp_2x2.sub x }}
 , {{ \x -> ff_sq_fp2x2 x == Fp_2x2.sq x }}
 , {{ \x -> ff_neg_fp2x2 x == Fp_2x2.neg x }}
 ] ( \t -> prove_cryptol t [] );

let print_goal_nicely = do {
    unfolding ["/\\", "\\/", "==>"];
    expand_fp2;
    simplify (addsimps ffx2_cover_thms (cryptol_ss ()));
    simplify prop_simpset;
    print_goal;
    simplify (addsimps ffx2_uncover_thms (cryptol_ss ()));
    simplify (addsimps ff_uncover_thms (cryptol_ss ())); // put things back. ish
    };

// non-top-level specifications

let mul_by_1_plus_i_mod_384x_spec = do {
  ret_ptr <- crucible_alloc vec384x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  // (p, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_global "BLS12_381_P"];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs a)) }});
};

let mul_by_1_plus_i_mod_384x_alias_ret_a_spec = do {
  (a, ret_ptr) <- ptr_to_fresh "ret" vec384x_type;
  // (p, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_global "BLS12_381_P"];
  new_ret <- crucible_fresh_var "new_ret" vec384x_type;
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs a)) }});
};

let frobenius_map_fp2_spec n = do {
  ret_ptr <- crucible_alloc vec384x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (nest fp2_frobenius (fp2_abs a) `n) }} );
};

let frobenius_map_fp2_alias_spec n = do {
  (a, ret_ptr) <- ptr_to_fresh "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (nest fp2_frobenius (fp2_abs a) `n) }} );
};

let frobenius_map_fp6_spec n = do {
  ret_ptr <- crucible_alloc vec384fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [ret_ptr, a_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (nest fp6_frobenius (fp6_abs a) `n) }} );
};

let frobenius_map_fp6_alias_spec n = do {
  (a, ret_ptr) <- ptr_to_fresh "a" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_execute_func [ret_ptr, ret_ptr, crucible_term {{ `n:[64] }}];
  crucible_points_to ret_ptr (crucible_term {{ fp6_rep (nest fp6_frobenius (fp6_abs a) `n) }} );
};

let sqr_fp4_spec = do {
  ret_ptr <- crucible_alloc vec384fp4_type;
  (a0, a0_ptr) <- ptr_to_fresh_readonly "a0" vec384x_type;
  (a1, a1_ptr) <- ptr_to_fresh_readonly "a1" vec384x_type;
  crucible_precond {{ fp2_invariant a0 }};
  crucible_precond {{ fp2_invariant a1 }};
  crucible_execute_func [ret_ptr, a0_ptr, a1_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp4_rep (Fp_4.sq (fp4_abs [a0, a1])) }});
};

let mul_by_u_plus_1_fp2_alias_spec = do {
  (ret,ret_ptr) <- ptr_to_fresh "ret" vec384x_type;
  crucible_precond {{ fp2_invariant ret }};
  crucible_execute_func [ret_ptr, ret_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2_rep (Fp_2.mul (u_plus_1, fp2_abs ret)) }});
};

let {{ 
  mul_by_u_plus_1_fp2x2: t_Fp_2x2 -> t_Fp_2x2 
  mul_by_u_plus_1_fp2x2 [x, y] = [add_mod_384x384 y x, sub_mod_384x384 y x]
  }};
// Both prove, but when we expand Fp_6x2.mul we get u_plus_1 on the right.
//prove z3 {{ \x y ->  mul_by_u_plus_1_fp2x2 [x, y] == Fp_2x2.mul (u_plus_1x2, [x, y]) }};
//prove z3 {{ \x y ->  mul_by_u_plus_1_fp2x2 [x, y] == Fp_2x2.mul ([x, y], u_plus_1x2) }};
mul_by_u_plus_1_fp2x2_equiv_thm  <-
  prove_cryptol {{ \x ->  Fp_2x2.mul (x, u_plus_1x2) == mul_by_u_plus_1_fp2x2 x }} [];

let mul_by_u_plus_1_fp2x2_spec = do {
  ret_ptr <- crucible_alloc vec768x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec768x_type;
  crucible_precond {{ fp2x2_invariant a }} ;
  crucible_execute_func [ret_ptr, a_ptr];
  // crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (mul_by_u_plus_1_fp2x2 (fp2x2_abs a)) }} );
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.mul (fp2x2_abs a, u_plus_1x2)) }} );
  };

// ... Fp2x2 operations 
let add_fp2x2_spec a_aliased b_aliased = do {
  (ret, ret_ptr) <- if either a_aliased b_aliased
                    then ptr_to_fresh "ret" vec768x_type
                    else do { ptr <- crucible_alloc vec768x_type;
                              return ({{zero: [2]Vec768}}, ptr);
                            };
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768x_type;
  (b, b_ptr) <- if b_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "b" vec768x_type;
  crucible_precond {{ fp2x2_invariant a }};
  crucible_precond {{ fp2x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.add (fp2x2_abs a, fp2x2_abs b)) }});
};

let sub_fp2x2_spec a_aliased b_aliased = do {
  (ret, ret_ptr) <- if either a_aliased b_aliased
                    then ptr_to_fresh "ret" vec768x_type
                    else do { ptr <- crucible_alloc vec768x_type;
                              return ({{zero: [2]Vec768}}, ptr);
                            };
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768x_type;
  (b, b_ptr) <- if b_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "b" vec768x_type;
  crucible_precond {{ fp2x2_invariant a }};
  crucible_precond {{ fp2x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.sub (fp2x2_abs a, fp2x2_abs b)) }});
};


let mul_fp2x2_spec = do {
  ret_ptr <- crucible_alloc vec768x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
  crucible_precond {{ fp2_invariant a }}; // a is smallish
  crucible_precond {{ fp2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.mul (abs_384x a, abs_384x b)) }});
};

let sqr_fp2x2_spec = do {
  ret_ptr <- crucible_alloc vec768x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  crucible_precond {{ fp2_invariant a }}; // a is smallish
  crucible_execute_func [ret_ptr, a_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp2x2_rep (Fp_2x2.mul (abs_384x a, abs_384x a)) }});
};

// ... Fp6x2 operations

let sub_fp6x2_spec a_aliased = do {
  (ret, ret_ptr) <- if a_aliased
                    then ptr_to_fresh "a" vec768fp6_type
                    else do { r <- crucible_alloc vec768fp6_type;
                              return ( {{ zero: [3][2]Vec768 }}, r ); } ; // TODO fix Cryptol type?
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec768fp6_type;
  crucible_precond {{ fp6x2_invariant a }};
  crucible_precond {{ fp6x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (Fp_6x2.sub (fp6x2_abs a, fp6x2_abs b)) }});
};

/*
let mul_fp6x2_spec a_aliased = do {
  (ret, ret_ptr) <- if a_aliased
                    then ptr_to_fresh "a" vec768fp6_type
                    else do { r <- crucible_alloc vec768fp6_type;
                              return ( {{ zero: [3][2]Vec768 }}, r ); } ; // TODO fix Cryptol type?
  (a, a_ptr) <- if a_aliased then return (ret, ret_ptr) else ptr_to_fresh_readonly "a" vec768fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec768fp6_type;
  crucible_precond {{ fp6x2_invariant a }};
  crucible_precond {{ fp6x2_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (Fp_6x2.mul (fp6x2_abs a, fp6x2_abs b)) }});
};
*/

// "nom" variants do not apply the Montgomery decode.
let {{
  fp2_abs_nom [x, y] = [abs_384 y, abs_384 x]
  fp6_abs_nom [x,y,z] = [fp2_abs_nom z, fp2_abs_nom y, fp2_abs_nom x]
  }};

let mul_fp6x2_spec a_aliased = do {
  ret_ptr <- crucible_alloc vec768fp6_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384fp6_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384fp6_type;
  crucible_precond {{ fp6_invariant a }};
  crucible_precond {{ fp6_invariant b }};
  crucible_execute_func [ret_ptr, a_ptr, b_ptr];
  // crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (Fp_6x2.mul (fp6_abs_nom a, fp6_abs_nom b)) }});
  crucible_points_to ret_ptr (crucible_term {{ fp6x2_rep (fp6x2_mul (fp6_abs_nom a) (fp6_abs_nom b)) }});
};

///////////////////////////////////////////////////////////////////////////////
// Proofs
///////////////////////////////////////////////////////////////////////////////

nest_fp2_thms <- for
  [ {{ \ f (x:t_Fp_2) -> nest f x 1 == f x }}
  , {{ \ f (x:t_Fp_2) -> nest f x 2 == f (f x) }}
  , {{ \ f (x:t_Fp_2) -> nest f x 3 == f (f (f x)) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);

nest_fp6_thms <- for
  [ {{ \ f (x:t_Fp_6) -> nest f x 1 == f x }}
  , {{ \ f (x:t_Fp_6) -> nest f x 2 == f (f x) }}
  , {{ \ f (x:t_Fp_6) -> nest f x 3 == f (f (f x)) }}
  ] (\ t -> prove_cryptol (rewrite (cryptol_ss ()) t) []);

// borrowed from exp2.saw:
fp2_invariant_alt_thm <-
  prove_cryptol
  {{ \x -> fp2_invariant x == (fp_invariant (x@0) /\ fp_invariant (x@1)) }}
  ["fp_invariant"];


fp2_invariant_alt_seq_thm <-
  prove_cryptol
  {{ \x y -> fp2_invariant [x,y] == (fp_invariant x /\ fp_invariant y) }}
  ["fp_invariant"];


mul_by_1_plus_i_mod_384x_ov <- admit "mul_by_1_plus_i_mod_384x" mul_by_1_plus_i_mod_384x_spec;
mul_by_1_plus_i_mod_384x_alias_ret_a_ov <- admit "mul_by_1_plus_i_mod_384x" mul_by_1_plus_i_mod_384x_alias_ret_a_spec;

mul_by_u_plus_1_fp2x2_ov <- custom_verify "mul_by_u_plus_1_fp2x2"
  all_384x384_ovs
  mul_by_u_plus_1_fp2x2_spec
  // (w4_unint_z3 all_384x384_unints);
  do {
   rw_with_1 mul_by_u_plus_1_fp2x2_equiv_thm;
   unfolding ["mul_by_u_plus_1_fp2x2", "fp2x2_rep", "fp2x2_abs"];
   simplify (cryptol_ss());
   w4_unint_z3 all_384x384_unints; };

// prove z3 {{ \ x y s t  -> mul_382x [x,y] [s ,t] == Fp_2x2.mul ([x,y], [s,t]) }};
// prove z3 {{ \ x y  -> mul_382x x y == Fp_2x2.mul (x,y) }};

mul_382x_equiv_thm <- prove_cryptol {{ \ x y  -> Fp_2x2.mul (x,y) == mul_382x x y }} [];

mul_fp2x2_ov <- custom_verify "mul_fp2x2"
  all_384x384_ovs
  mul_fp2x2_spec
  do {
   rw_with_1 mul_382x_equiv_thm; // eliminate Fp_2x2.mul
   // w4_unint_z3 ["mul_382x"];
   w4_unint_z3 ["mul_382x", "fp2x2_rep", "abs_384x"];
   };

sqr_fp2x2_ov <- custom_verify "sqr_fp2x2"
  all_384x384_ovs
  sqr_fp2x2_spec
  do {
   rw_with_1 mul_382x_equiv_thm; // eliminate Fp_2x2.mul
   print_goal;
   w4_unint_z3 ["mul_382x", "fp2x2_rep", "abs_384x"];
   };



sub_fp6x2_ov <- custom_verify "sub_fp6x2"
  all_384x384_ovs
  (sub_fp6x2_spec false) // not aliased
  z3;

/* FAILS!
sub_fp6c2_ov <- really_verify "sub_fp6x2"
  all_384x384_ovs
  (sub_fp6x2_spec false); // not aliased
*/

sub_fp6x2_ov <- really_custom_verify "sub_fp6x2"
  all_384x384_ovs
  (sub_fp6x2_spec true) // (ret, a)
  z3; 

// abs and rep theorems for fp2x2 are a bit complicated.
// bv_384_thms <- bv_int_axioms 384;
bv768_thms <- bv_int_axioms 768;

// ... first fpx2
vec768_abs_rep_thm <- prove_cryptol {{ \x -> vec768_abs (vec768_rep x) == x }} [];
vec768_rep_abs_thm <- prove_cryptol {{ \x -> vec768_rep (vec768_abs x) == x }} [];

fpx2_inv_rep_lemma <- custom_prove_cryptol
  {{ \ x -> fpx2_invariant (fpx2_rep x) == Fpx2.is_val (x % 2^^768) }}
  do { unfolding ["fpx2_invariant", "fpx2_rep", "Fpx2", "prime_field_integer"];
       simplify (addsimp vec768_abs_rep_thm empty_ss);
       simplify (addsimps bv768_thms empty_ss);
       z3; };

fpx2_inv_rep_lemma2 <- custom_prove_cryptol
  {{ \ x -> fpx2_invariant (fpx2_rep x) ==
       if Fpx2.is_val x then True else apply fpx2_invariant (fpx2_rep x) }}
  do { unfolding ["apply"]; rw_with_1 fpx2_inv_rep_lemma; z3; };

// TODO: eliminate?
fpx2_inv_rep_thms <- for
  [ {{ Fpx2.add }}, {{ Fpx2.sub }}, {{Fpx2.mul}} ]
  ( \ f -> custom_prove_cryptol {{ \ x y -> fpx2_invariant (fpx2_rep (f (x,y))) == True }}
    do { rw_with_1 fpx2_inv_rep_lemma2; z3; } );

fpx2_val_thms <- for
  [ {{ Fpx2.add }}, {{ Fpx2.sub }}, {{Fpx2.mul}} ]
  ( \ f -> prove_cryptol {{ \ x y -> Fpx2.is_val (f (x,y)) == True }} [] );


fpx2_abs_rep_lemma <- custom_prove_cryptol
  {{ \x -> fpx2_abs (fpx2_rep x) == x % 2^^768}}
  do { unfolding ["fpx2_abs", "fpx2_rep"];
       simplify (addsimp vec768_abs_rep_thm (addsimps bv768_thms empty_ss));
       z3; };

// TODO: eliminate?
fpx2_abs_rep_thms <- for
  [ {{ Fpx2.add }}, {{ Fpx2.sub }}, {{Fpx2.mul}} ]
  ( \ f -> custom_prove_cryptol {{ \ x y -> fpx2_abs (fpx2_rep (f (x,y))) == f (x,y) }}
    do { rw_with_1 fpx2_abs_rep_lemma; z3; } );

fpx2_abs_rep_thm <- custom_prove_cryptol
    {{ \x -> fpx2_abs (fpx2_rep x) == if Fpx2.is_val x then x else x % 2^^768 }}
    do { rw_with_1 fpx2_abs_rep_lemma; z3; };

fpx2_rep_abs_thm <- custom_prove_cryptol {{ \x -> fpx2_rep (fpx2_abs x) == x }}
  do { unfolding ["fpx2_abs", "fpx2_rep"];
       simplify (addsimp vec768_rep_abs_thm (addsimps bv768_thms empty_ss));
       z3; };

// let fpx2_thms = concat_all [fpx2_inv_rep_thms, fpx2_abs_rep_thms, [fpx2_rep_abs_thm]];
let fpx2_thms = concat_all [[fpx2_inv_rep_lemma2], fpx2_val_thms, [fpx2_abs_rep_thm, fpx2_rep_abs_thm]];

// ... then fp2x2

fp2x2_inv_rep_lemma2 <- custom_prove_cryptol
  {{ \ x -> fp2x2_invariant (fp2x2_rep x) ==
       if Fp_2x2.is_val x then True else apply fp2x2_invariant (fp2x2_rep x) }}
  do { unfolding ["apply", "fp2x2_invariant", "fp2x2_rep"];
       rw_with_1 fpx2_inv_rep_lemma2;
       w4_unint_z3 ["fpx2_invariant", "fpx2_rep", "Fpx2"]; };

// drop?
fp2x2_inv_rep_thms <- for
  [ {{ Fp_2x2.add }}, {{ Fp_2x2.sub }}, {{Fp_2x2.mul}} ]
  ( \ f -> custom_prove_cryptol {{ \ x y -> fp2x2_invariant (fp2x2_rep (f (x,y))) == True }}
    do { rw_with_1 fp2x2_inv_rep_lemma2; z3; } );

fp2x2_val_thms <- for
  [ {{ Fp_2x2.add }}, {{ Fp_2x2.sub }}, {{Fp_2x2.mul}} ]
  ( \ f -> prove_cryptol {{ \ x y -> Fp_2x2.is_val (f (x,y)) == True }} []);

fp2x2_ite_thms <- for
  [ {{ fp2x2_invariant }}, {{ fp2x2_rep }}, {{ fp2x2_abs }} ]
  (\t -> hoist t ["fp2x2_invariant", "fp2x2_rep", "fp2x2_abs"]) ;

fpx2_inv_at_thms <- for [0,1]
  (\ i -> prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> fpx2_invariant (x @ (`i:[1])) ==
          if fp2x2_invariant x then True else apply fpx2_invariant (x @ (`i:[1])) }}) []);

fp2x_inv_list_thm <- prove_cryptol
  {{ \ x y -> fp2x2_invariant [x, y] == (fpx2_invariant x /\ fpx2_invariant y) }} [];

fp2x2_abs_rep_thm <- custom_prove_cryptol
    {{ \x -> fp2x2_abs (fp2x2_rep x) == if Fp_2x2.is_val x then x else apply fp2x2_abs (fp2x2_rep x) }}
    do { unfolding ["apply", "fp2x2_abs", "fp2x2_rep", "Fp_2x2", "extension_field"];
         rw_with_1 fpx2_abs_rep_thm; z3; };


Fpx2_val_at_thms <- for [0,1]
  (\ i -> prove_cryptol (rewrite (cryptol_ss())
       {{ \ x -> Fpx2.is_val (x @ (`i:[1])) ==
          if Fp_2x2.is_val x then True else apply Fpx2.is_val (x @ (`i:[1]))}}) []);

let fp2x2_thms = concat_all [fp2x2_val_thms, fp2x2_ite_thms, Fpx2_val_at_thms
                            , [fp2x2_inv_rep_lemma2,fp2x_inv_list_thm, fp2x2_abs_rep_thm] ];

add_fp2x2_ovs <- for possible_aliases
  (\ (ar, br) -> custom_verify "add_fp2x2" all_384x384_ovs (add_fp2x2_spec ar br) z3);

sub_fp2x2_ovs <- for possible_aliases
  (\ (ar, br) -> custom_verify "sub_fp2x2" all_384x384_ovs (sub_fp2x2_spec ar br) z3);

// and fp6x2
// TODO: maybe not needed:
fp6x2_mul_expansion_thm <- prove_cryptol
 {{ \ x y -> ( Fp_6x2.mul(x, y) ==
     [ R.add (R.mul (a, f), R.add (R.mul(b, e), R.mul(c,d)))
     , R.add (R.mul(R.mul(a, d), u_plus_1x2),
              R.add(R.mul(b,f), R.mul(c,e)))
     , R.add (R.mul (R.add (R.mul(a, e), R.mul(b,d)), u_plus_1x2),
               R.mul(c, f))
     ] where
       [a,b,c] = x
       [d,e,f] = y
       R = Fp_2x2 ) }} [] ;

reabstracted_add_thm <- test_cryptol
  {{ \ x y -> abs_384x (fp2_rep (Fp_2.add (fp2_abs x, fp2_abs y))) == Fp_2.add (fp2_abs_nom x, fp2_abs_nom y) }};

fp2_abs_nom_thm <- prove_cryptol {{ \x -> fp2_abs_nom x == abs_384x x }} [];

mul_fp6x2_ov <- really_custom_verify "mul_fp6x2"
  (concat_all [[mul_fp2x2_ov, sqr_fp2x2_ov, mul_by_u_plus_1_fp2x2_ov], add_fp2x2_ovs, sub_fp2x2_ovs, fp2_overrides])
  (mul_fp6x2_spec false) // not aliased
  do {
   //rw_with_1 fp6x2_mul_expansion_thm;
   // unfolding ["fp6_invariant", "fp2x2_rep", "fp6x2_rep"];
   unfolding ["fp6_invariant", "fp6x2_rep", "fp6_abs_nom", "fp6x2_mul", "fp6x2_tmp"];
   // simplify fp_simpset;
   simplify fp2_simpset;
   rw_with (concat_all [fpx2_thms, fp2x2_thms, [reabstracted_add_thm, fp2_abs_nom_thm]]);
   // goal_eval_unint ["Fp_2x2", "Fp_2"];
   // print_goal_nicely;
   z3; // w4_unint_z3 ["Fp_2x2"];
   };

mul_fp6x2_aliased_ov <- really_custom_verify "mul_fp6x2"
  (concat_all [[mul_fp2x2_ov, sqr_fp2x2_ov, mul_by_u_plus_1_fp2x2_ov], add_fp2x2_ovs, sub_fp2x2_ovs, fp2_overrides])
  (mul_fp6x2_spec true) // aliased
  do {
   unfolding ["fp6_invariant", "fp6x2_rep", "fp6_abs_nom", "fp6x2_mul", "fp6x2_tmp"];
   simplify fp2_simpset;
   rw_with (concat_all [fpx2_thms, fp2x2_thms, [reabstracted_add_thm, fp2_abs_nom_thm]]);
   z3;
   };


// sub_mod_384x
/*
sub_mod_384x384_ovs <-
  for [ sub_mod_384x384_spec, sub_mod_384x384_alias_ret_a_spec,  sub_mod_384x384_alias_ret_b_spec
      , sub_mod_384x384_alias_a_b_spec, sub_mod_384x384_alias_ret_a_b_spec]
      (\ s -> admit "sub_mod_384x384" s);
*/

conjugate_fp12_ov <- custom_verify "conjugate_fp12"
  fp2_overrides
  conjugate_fp12_spec
  do { unfolding ["fp12_conjugate", "f12", "f6", "Fp_6", "Fp_12", "extension_field"
                  ,"fp12_rep", "fp6_rep", "fp12_abs", "fp6_abs",
                  "fp12_invariant", "fp6_invariant"];
       simplify (addsimps propositional_rewrites fp2_simpset);
       w4_unint_z3 fp2_unints; };

/* FAILS
conjugate_fp12_ov <- custom_verify "conjugate_fp12"
  fp2_overrides
  conjugate_fp12_spec
  (w4_unint_z3 fp2_unints);
*/

frobenius_map_fp2_1_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_spec 1)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimps nest_fp2_thms fp_simpset);
         w4_unint_z3 fp_unints;};

frobenius_map_fp2_1_alias_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_alias_spec 1)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimps nest_fp2_thms fp_simpset);
         w4_unint_z3 fp_unints;};

fp_rep_normalize_abs_thm <- admit_cryptol {{ \x -> fp_rep (Fp.normalize (fp_abs x)) == fp_normalize x }};
 
frobenius_map_fp2_2_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_spec 2)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm] (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

frobenius_map_fp2_2_alias_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_alias_spec 2)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm] (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

fp_neg_normalize_thm <- prove_cryptol {{ \x -> Fp.neg (Fp.normalize x) == Fp.neg x }} [];

frobenius_map_fp2_3_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_spec 3)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm, fp_neg_normalize_thm]
                            (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

frobenius_map_fp2_3_alias_ov <- custom_verify "frobenius_map_fp2"
    (concat fp_overrides fp2_overrides)
    (frobenius_map_fp2_alias_spec 3)
    do { unfolding ["fp2_rep", "fp2_frobenius", "fp2_conjugate", "f1", "fp2_abs"];
         simplify (addsimp fp2_invariant_alt_thm (addsimps nest_fp2_thms fp_simpset));
         simplify (addsimps [fp_rep_normalize_abs_thm, fp_normalize_thm, fp_neg_normalize_thm]
                            (addsimps fp_alg_thms empty_ss));
         w4_unint_z3 fp_unints;};

frobenius_constant_thms <- for [
    {{ fp2_invariant rep_v_frobenius_constant == True }}
  , {{ fp2_abs       rep_v_frobenius_constant ==  v_frobenius_constant }}
  , {{ fp2_invariant rep_v_frobenius_constant_sq == True }}
  , {{ fp2_abs       rep_v_frobenius_constant_sq ==  v_frobenius_constant_sq }}
  , {{ fp_invariant  rep_v_frobenius_constant_sq_const_part == True }}
  , {{ fp_abs        rep_v_frobenius_constant_sq_const_part ==  v_frobenius_constant_sq!0 }}
  , {{ fp2_invariant rep_w_frobenius_constant_const_part == True }}
  , {{ fp2_abs       rep_w_frobenius_constant_const_part ==  w_frobenius_constant!0 }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss ())
                          (unfold_term [ "rep_v_frobenius_constant"
                                       , "rep_v_frobenius_constant_sq"
                                       , "rep_v_frobenius_constant_sq_const_part"
                                       , "rep_w_frobenius_constant_const_part"
                                       ] t))
                         []);


fp2_mul_v_sq_thm <- prove_cryptol
// {{ \ x y -> Fp_2.mul (v_frobenius_constant_sq, [x,y])
//             == [Fp.mul (x, v_frobenius_constant_sq!0), Fp.mul (y, v_frobenius_constant_sq!0)] }}
 {{ \ x -> Fp_2.mul (v_frobenius_constant_sq, x)
             == [Fp.mul (x@0, v_frobenius_constant_sq!0), Fp.mul (x@1, v_frobenius_constant_sq!0)] }}
 [];

fp2_mul_comutes_thm <- prove_cryptol {{ \x y -> Fp_2.mul (x, y) == apply Fp_2.mul (y,x) }} [];

frobenius_map_fp6_1_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_1_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_spec 1)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with frobenius_constant_thms;
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };


frobenius_map_fp6_1_alias_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_1_alias_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_alias_spec 1)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with frobenius_constant_thms;
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       // w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };
       w4_unint_z3 (concat fp_unints fp2_unints); };

// For double Frobenius:
frobenius_2_constant_thms <- for [
    {{ fp2_invariant rep_v_frobenius_constant_2 == True }}
  , {{ fp2_abs       rep_v_frobenius_constant_2 ==  v_frobenius_constant_2 }}
  , {{ fp_invariant rep_v_frobenius_constant_2_sq_const_part == True }}
  , {{ fp_abs       rep_v_frobenius_constant_2_sq_const_part ==  v_frobenius_constant_2_sq @ 1}}
  , {{ fp2_invariant rep_w_frobenius_constant_2_const_part == True }}
  , {{ fp2_abs       rep_w_frobenius_constant_2_const_part == w_frobenius_constant_2_part }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss ())
                          (unfold_term [ "rep_v_frobenius_constant_2"
                                       , "rep_v_frobenius_constant_2_sq_const_part"
                                       , "rep_w_frobenius_constant_2_const_part"
                                       ] t))
                         []);

fp2_mul_v_sq_2_thm <- prove_cryptol
 {{ \ x -> Fp_2.mul (v_frobenius_constant_2_sq, x)
             == [Fp.mul (x@0, v_frobenius_constant_2_sq@1), Fp.mul (x@1, v_frobenius_constant_2_sq@1)] }}
 [];

frobenius_2_theorems <- for
  [ // {{ \x -> fp2_frobenius (fp2_frobenius x) == [Fp.normalize (x@0), x@1] }}
  // ,
  {{ \x -> fp6_frobenius (fp6_frobenius x) == fp6_frobenius2 x }}
  ] (\t -> prove_cryptol t []);

frobenius_map_fp6_2_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_2_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_spec 2)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_2_theorems frobenius_2_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius2", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_2_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };

frobenius_map_fp6_2_alias_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_2_alias_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_alias_spec 2)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_2_theorems frobenius_2_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius2", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_2_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       // w4_unint_z3 (concat ["v_frobenius_constant", "v_frobenius_constant_sq"] (concat fp_unints fp2_unints)); };
       w4_unint_z3 (concat fp_unints fp2_unints); };


// for triple Frobenius
frobenius_3_constant_thms <- for [
    {{ fp2_invariant rep_v_frobenius_constant_3 == True }}
  , {{ fp2_abs       rep_v_frobenius_constant_3 ==  v_frobenius_constant_3 }}
  , {{ fp_invariant rep_v_frobenius_constant_3_sq_const_part == True }}
  , {{ fp_abs       rep_v_frobenius_constant_3_sq_const_part ==  v_frobenius_constant_3_sq @ 1}}
  , {{ fp2_invariant rep_w_frobenius_constant_3_const_part == True }}
  , {{ fp2_abs       rep_w_frobenius_constant_3_const_part == w_frobenius_constant_3_part }}
  ] (\t -> prove_cryptol (rewrite (cryptol_ss ())
                          (unfold_term [ "rep_v_frobenius_constant_3"
                                       , "rep_v_frobenius_constant_3_sq_const_part"
                                       , "rep_w_frobenius_constant_3_const_part"
                                       ] t))
                         []);

fp2_mul_v_sq_3_thm <- prove_cryptol
 {{ \ x -> Fp_2.mul (v_frobenius_constant_3_sq, x)
             == [Fp.mul (x@0, v_frobenius_constant_3_sq@1), Fp.mul (x@1, v_frobenius_constant_3_sq@1)] }}
 [];

frobenius_3_theorems <- for
  [ {{ \x -> fp2_frobenius (fp2_frobenius (fp2_frobenius x)) == fp2_frobenius x }}
  , {{ \x -> fp6_frobenius (fp6_frobenius (fp6_frobenius x)) == fp6_frobenius3 x }}
  ] (\t -> prove_cryptol t []);

frobenius_map_fp6_3_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_3_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_spec 3)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_3_theorems frobenius_3_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius3", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_3_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant_3", "v_frobenius_constant_3_sq"] (concat fp_unints fp2_unints)); };

frobenius_map_fp6_3_alias_ov <- custom_verify "frobenius_map_fp6"
    (concat [frobenius_map_fp2_3_alias_ov] (concat fp_overrides fp2_overrides))
    (frobenius_map_fp6_alias_spec 3)
    do { rw_with_1 fp2_mul_comutes_thm;
       rw_with (concat nest_fp2_thms nest_fp6_thms);
       rw_with (concat frobenius_3_theorems frobenius_3_constant_thms);
       rw_with_1 fp2_invariant_alt_seq_thm;
       unfolding ["fp6_rep", "fp6_abs", "fp6_invariant", "fp6_frobenius3", "f2", "apply"];
       simplify (addsimps [fp2_mul_v_sq_3_thm, fp2_invariant_alt_thm] (addsimps fp_inv_fp2_rep_thms fp2_simpset));
       unfolding ["fp2_rep"];
       simplify fp_simpset;
       w4_unint_z3 (concat ["v_frobenius_constant_3", "v_frobenius_constant_3_sq"] (concat fp_unints fp2_unints)); };

// Finally, fp12_frobenius_map

// For the fp2 multiplications in frobenius_map_fp12:

fp6_mul_w_const_thm <- prove_cryptol
  {{ \ x -> Fp_6.mul (w_frobenius_constant, x) == [Fp_2.mul(x@0,c), Fp_2.mul(x@1,c), Fp_2.mul(x@2,c)] where
     c = w_frobenius_constant!0 }}
  [];

frobenius_map_fp12_1_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_1_ov] fp2_overrides)
    (frobenius_map_fp12_spec 1)
    do {
       rw_with (concat nest_fp6_thms frobenius_constant_thms);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps [fp6_mul_w_const_thm] fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_map_fp12_1_alias_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_1_alias_ov] fp2_overrides)
    (frobenius_map_fp12_alias_spec 1)
    do {
       rw_with (concat nest_fp6_thms frobenius_constant_thms);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps [fp6_mul_w_const_thm] fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_12_2_theorems <- for
  [ {{ \x -> fp12_frobenius (fp12_frobenius x) == fp12_frobenius2 x }}
  , {{ \ x -> Fp_6.mul (Fp_2_to_Fp_6 c, x) == [Fp_2.mul(x@0,c), Fp_2.mul(x@1,c), Fp_2.mul(x@2,c)] where
              c = w_frobenius_constant_2_part }}
  ] (\t -> prove_cryptol t []);

frobenius_map_fp12_2_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_2_ov] fp2_overrides)
    (frobenius_map_fp12_spec 2)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_2_constant_thms, frobenius_12_2_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius2", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_2_theorems fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_map_fp12_2_alias_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_2_alias_ov] fp2_overrides)
    (frobenius_map_fp12_alias_spec 2)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_2_constant_thms, frobenius_12_2_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius2", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_2_theorems fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_12_3_theorems <- for
  [ {{ \x -> fp12_frobenius (fp12_frobenius (fp12_frobenius x)) == fp12_frobenius3 x }}
  , {{ \ x -> Fp_6.mul (Fp_2_to_Fp_6 c, x) == [Fp_2.mul(x@0,c), Fp_2.mul(x@1,c), Fp_2.mul(x@2,c)] where
              c = w_frobenius_constant_3_part }}
  ] (\t -> prove_cryptol t []);


frobenius_map_fp12_3_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_3_ov] fp2_overrides)
    (frobenius_map_fp12_spec 3)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_3_constant_thms, frobenius_12_3_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius3", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_3_theorems fp2_simpset);
       w4_unint_z3 fp2_unints; };

frobenius_map_fp12_3_alias_ov <- custom_verify "frobenius_map_fp12"
    (concat [frobenius_map_fp6_3_alias_ov] fp2_overrides)
    (frobenius_map_fp12_alias_spec 3)
    do {
       rw_with (concat_all [nest_fp6_thms, frobenius_3_constant_thms, frobenius_12_3_theorems]);
       unfolding [ "fp12_rep", "fp12_abs", "fp12_invariant", "fp12_frobenius3", "f6"
                 , "fp6_rep", "fp6_abs", "fp6_invariant"];
       simplify (addsimps frobenius_12_3_theorems fp2_simpset);
       w4_unint_z3 (concat ["Fp_4"] fp2_unints); };


// Cyclotomic squaring

more_fp2_alg_thms <- for
  [ {{ \ x y -> Fp_2.add(x, Fp_2.normalize y) == Fp_2.add (x, y) }}
  , {{ \ x y -> Fp_2.neg (Fp_2.add (x, y)) == Fp_2.add (Fp_2.neg x, Fp_2.neg y) }}
  ] (\ t -> prove_cryptol t []);

let all_fp2_alg_thms = concat fp2_alg_thms more_fp2_alg_thms;

sqr_fp4_ov <- admit "sqr_fp4" sqr_fp4_spec; //TODO - prove
mul_by_u_plus_1_fp2_alias_ov <- admit "mul_by_u_plus_1_fp2" mul_by_u_plus_1_fp2_alias_spec; // TODO

fp4_mul_thm <- prove_cryptol
  {{ \x y -> Fp_4.mul (x, y) == [ Fp_2.add (Fp_2.mul(x@0,y@1), Fp_2.mul(x@1, y@0))
                                , Fp_2.add(Fp_2.mul(u_plus_1, Fp_2.mul(x@0, y@0)), Fp_2.mul (x@1, y@1))
                                ] }} [];

fp4_add_thm <- prove_cryptol {{ \x y -> Fp_4.add (x, y) == [Fp_2.add (x@0, y@0), Fp_2.add(x@1, y@1)] }} [];
fp4_sub_thm <- prove_cryptol {{ \x y -> Fp_4.sub (x, y) == [Fp_2.sub (x@0, y@0), Fp_2.sub(x@1, y@1)] }} [];

cyclotomic_sqr_equiv_thm <- really_custom_prove_cryptol
  {{ \x -> cyclotomic_sqr_fp12 x == cyclotomic_sqr_fp12_imp x }}
  do { // unfolding_non ["Fp_4", "Fp_2"];
       unfolding ["cyclotomic_sqr_fp12", "cyclotomic_sqr_fp12_imp", "Fp_12_alt_to_Fp_12"
                 , "cyclotomic_sqr_alt", "Fp_12_to_Fp_12_alt"];
       rw_with [fp4_mul_thm, fp4_add_thm, fp4_sub_thm];
       rw_with all_fp2_alg_thms;  // you would think this step unnecesary, but it is not!
       w4_unint_z3 ["Fp_4"]; /* fp2_unints; */ } ;

cyclotomic_sqr_fp12_ov <- really_custom_verify "cyclotomic_sqr_fp12"
  (concat [sqr_fp4_ov, mul_by_u_plus_1_fp2_alias_ov] fp2_overrides)
  cyclotomic_sqr_fp12_spec
  do { rw_with_1 cyclotomic_sqr_equiv_thm;
       unfolding [ "cyclotomic_sqr_fp12_imp", "fp12_invariant", "fp6_invariant", "fp4_rep", "fp4_abs"
                 , "fp12_rep", "fp6_rep", "fp12_abs", "fp6_abs"];
       rw_with_1 fp2_invariant_alt_seq_thm;
       simplify (addsimps fp2_alg_thms fp2_simpset);
       w4_unint_z3 fp2_unints; } ;

/*
sqr_fp12_ov <- verify "sqr_fp12" assembly_overrides sqr_fp12_spec;
sqr_fp12_alias_ov <- verify "sqr_fp12" assembly_overrides sqr_fp12_alias_spec;
cyclotomic_sqr_fp12_ov <- verify "cyclotomic_sqr_fp12" assembly_overrides cyclotomic_sqr_fp12_spec;
cyclotomic_sqr_fp12_alias_ov <- verify "cyclotomic_sqr_fp12" assembly_overrides cyclotomic_sqr_fp12_alias_spec;
mul_fp12_ov <- verify "mul_fp12" assembly_overrides mul_fp12_spec;
mul_fp12_alias_ov <- verify "mul_fp12" assembly_overrides mul_fp12_alias_spec;
mul_by_xy00z0_fp12_ov <- verify "mul_by_xy00z0_fp12" assembly_overrides mul_by_xy00z0_fp12_spec;
mul_by_xy00z0_fp12_alias_ov <- verify "mul_by_xy00z0_fp12" assembly_overrides mul_by_xy00z0_fp12_alias_spec;
conjugate_fp12_ov <- verify "conjugate_fp12" assembly_overrides conjugate_fp12_spec;
inverse_fp12_ov <- verify "inverse_fp12" assembly_overrides inverse_fp12_spec;
let make_frobenius_map_fp12_ov n = verify "frobenius_map_fp12" assembly_overrides (frobenius_map_fp12_spec n);
frobenius_map_fp12_ovs <- for [1,2,3] make_frobenius_map_fp12_ov; // NOTE: this could be verified for any 0 < n <= 3, but it fails with that precondition in the spec
let make_frobenius_map_fp12_alias_ov n = verify "frobenius_map_fp12" assembly_overrides (frobenius_map_fp12_alias_spec n);
frobenius_map_fp12_alias_ovs <- for [1,2,3] make_frobenius_map_fp12_alias_ov; // NOTE: this could be verified for any 0 < n <= 3, but it fails with that precondition in the spec

let fp12_tower_ovs = foldr concat [frobenius_map_fp12_alias_ovs, frobenius_map_fp12_ovs, [sqr_fp12_alias_ov, sqr_fp12_ov, mul_fp12_alias_ov, mul_fp12_ov, mul_by_xy00z0_fp12_alias_ov, mul_by_xy00z0_fp12_ov, conjugate_fp12_ov, inverse_fp12_ov, cyclotomic_sqr_fp12_ov, cyclotomic_sqr_fp12_alias_ov]] [];
*/
