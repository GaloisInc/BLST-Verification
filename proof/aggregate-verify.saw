let {{
  // TODO: Define
  all_distinct: {n, m} [n][m][8] -> Bit
  all_distinct messages = undefined
}};

let all_distinct_spec n = do {
  let message_len = 32;
  (messages, messages_ptr) <-
      ptr_to_fresh_readonly "messages"
                            (llvm_array n
                                        (llvm_array message_len (llvm_int 8)));
  llvm_execute_func [ llvm_term {{ `n : [64] }}
                    , llvm_term {{ `message_len : [64] }} 
                    , messages_ptr ];
  llvm_return (llvm_term {{ bool_to_limb (all_distinct messages) }});
};

// TODO: What should n be?  2 and 8 have good coverage.  Maybe just those two?
// There's an argument to be made for 16 as well, which hits an additional
// branch.  9 will also hit an additional branch in pairing_commit
let aggregate_n = 2;

// TODO: Prove
all_distinct_ov <- admit "all_distinct" (all_distinct_spec aggregate_n);

let demo_BasicAggregateVerify_A_spec n = do {
  global_alloc_init "demo_DST_A" {{ DST }};
  (sig, sig_ptr) <- ptr_to_fresh_readonly "sig" compressed_E1_rep_type;
  (pks, pks_ptr) <-
      ptr_to_fresh_readonly "pks" (llvm_array n compressed_E2_rep_type);
  let message_len = 32;
  (messages, messages_ptr) <-
      ptr_to_fresh_readonly "messages"
                            (llvm_array n
                                        (llvm_array message_len (llvm_int 8)));
  verify_A_sig_preconds sig;
  llvm_precond {{ all verify_A_pk_precond pks }};
  /*
  llvm_precond {{ verify_A_pk_precond (pks@0) }};
  llvm_precond {{ verify_A_pk_precond (pks@1) }};
  llvm_precond {{ verify_A_pk_precond (pks@2) }};
  */
  // TODO: Preconditions.  Likely can lift signature preconditions from
  // BasicVerify, and apply pk preconds to every element in pks.  Also need
  // precond that all messages are unique (Or to integrate that into postcond)
  llvm_execute_func [ llvm_term {{ `n : [64] }}
                    , llvm_term {{ `message_len : [64] }}
                    , pks_ptr
                    , messages_ptr
                    , sig_ptr ];
  // TODO: Postcond
  /*
  llvm_return (llvm_term
      {{ bool_to_limb (CoreAggregateVerify pks messages sig) }});
      */
};

let msg_len = 32;
let dst_len = 43;
let aug_len = 0;

Hash_to_G1_ov <- prove_Hash_to_G1_impl_ov msg_len dst_len aug_len;

normalize_hash_to_curve_opt_impl_rws <-
  normalize_hash_to_curve_impl_thms msg_len dst_len aug_len;

hash_to_curve_opt_impl_POINTonE1_from_Jacobian_precond_thms <-
  core_verify_pk_in_g2_POINTonE1_from_Jacobian_hash_preconds msg_len dst_len aug_len;

unfold_all_POINTonE2_affine_invariant_2_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \x1 x2 -> all POINTonE2_affine_invariant [x1, x2] ==
               (POINTonE2_affine_invariant x1 /\
                POINTonE2_affine_invariant x2) }}) [];

unfold_all_POINTonE1_affine_invariant_2_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \x1 x2 -> all POINTonE1_affine_invariant [x1, x2] ==
               (POINTonE1_affine_invariant x1 /\
                POINTonE1_affine_invariant x2) }}) [];

normalize_affine_fp_pair0_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> (Fp.normalize P.0) == (normalize_affine_point Fp P).0 }}) [];

normalize_affine_fp_pair1_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> (Fp.normalize P.1) == (normalize_affine_point Fp P).1 }}) [];

hoist_fp_invariant <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c x1 x2 -> fp_invariant (if c then x1 else x2) ==
                   if c then fp_invariant x1 else fp_invariant x2 }})
  ["fp_invariant"];

hoist_fp_abs <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c x1 x2 -> fp_abs (if c then x1 else x2) ==
                   if c then fp_abs x1 else fp_abs x2 }})
  ["fp_abs"];

hoist_is_point_projective_E_z_thm <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c x y z1 z2 -> is_point_projective E (x, y, if c then z1 else z2) ==
                       if c
                       then is_point_projective E (x, y, z1)
                       else is_point_projective E (x, y, z2) }}) [];

// TODO: Is this true?  Z==1 should indicate that the point is already affine.
// So if it's on the curve in projective coordinates shouldn't it also be on
// the curve in affine coordinates?  Prove?
is_point_projective_E_affine_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \x y -> is_point_projective E (x, y, Fp.field_unit) ==
             is_point_affine E (x, y) }});


demo_BasicAggregateVerify_A_ov <- really_custom_verify
  "demo_BasicAggregateVerify_A"
  (foldr concat [vec_fp2_overrides, vec_overrides]
                [ all_distinct_ov
                , POINTonE1_Uncompress_OK_ov // blst_p1_uncompress_OK_ov
                , POINTonE1_affine_on_curve_ov
                , blst_p1_affine_in_g1_ov
                , demo_KeyValidate_A_ov
                , blst_p2_uncompress_OK_ov
                // ovs used in pairing aggregate:
                , POINTonE1_in_G1_ov
                , Hash_to_G1_ov
                , POINTonE1_from_Jacobian_alias_ov
                , vec_copy_2fp_ov
                // ovs used in blst_pairing_commit:
                , miller_loop_n_2_ov
                // ovs used in blst_pairing_finalverify:
                , POINTonE1_from_Jacobian_ov
                ])
  (demo_BasicAggregateVerify_A_spec aggregate_n)
  do {
    // Precondition proof(s)
    unfolding [ "POINTonE1_affine_abs"
              , "uncompress_E1_imp"
              , "POINTonE2_affine_abs"
              , "blst_core_verify_pk_in_g2_error_precond"
              ];
    simplify basic_ss;
    simplify (cryptol_ss());
    simplify basic_ss;
    rw_with [ hoist_POINTonE1_affine_rep
            , hoist_POINTonE1_affine_invariant
            , hoist_POINTonE2_affine_rep
            , hoist_POINTonE2_affine_invariant
            , affine_inv_affine_rep_e2_thm
            , zero_lt_one_thm
            , intLe_sym_thm
            , affine_inv_affine_rep_e1_thm ];
    rw_with structural_rewrites;
    simplify basic_ss;
    rw_with [ fold_POINTonE1_affine_invariant
            , fold_POINTonE2_affine_invariant
            , hoist_POINTonE1_affine_invariant
            , hoist_POINTonE2_affine_invariant
            , affine_inv_affine_rep_e2_thm
            , fold_POINTonE2_affine_abs_thm
            , hoist_POINTonE2_affine_abs_thm
            , hoist_is_point_O_E'_thm
            , POINTonE2_affine_abs_rep_thm
            , is_point_O_KeyValidate_thm
            , normalize_uncompress_E2_OK_thm
            , unfold_all_POINTonE1_affine_invariant_2_thm
            , unfold_all_POINTonE2_affine_invariant_2_thm
            , affine_inv_affine_rep_e1_thm ];
    rw_with POINTonE1_base_thms;
    unfolding ["POINTonE1_rep"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp_rep_thms;
    rw_with normalize_hash_to_curve_opt_impl_rws;
    rw_with hash_to_curve_opt_impl_POINTonE1_from_Jacobian_precond_thms;
    //rw_with_1 is_point_O_affine_rev_thm;
    simplify basic_ss;
    simplify (cryptol_ss());
    unfolding [ "POINTonE1_invariant"
              , "POINTonE1_affine_rep"
              , "select"
              , "POINTonE1_abs" ];
    //hoist_ifs_in_goal;
    rw_with fp_rep_thms;
    rw_with [ normalize_affine_fp_pair0_thm
            , hoist_fp_invariant
            , hoist_fp_abs
            , normalize_affine_fp_pair1_thm
            , one_mont_p_invariant_thm
            , one_mont_p_abs_thm
            , hoist_is_point_projective_E_z_thm
            , is_point_projective_E_affine_thm
            , normalize_uncompress_E1_OK_thm];
    rw_with fp_rep_thms;
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with remove_ho_rules;
    //print_readably;
    print_goal;
    w4_unint_z3 (concat [ "all_distinct" ]
                        BasicVerify_A_unints);
  };
