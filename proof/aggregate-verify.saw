let {{
  // TODO: Define
  all_distinct: {n, m} [n][m][8] -> Bit
  all_distinct messages = undefined
  AGGR_MIN_SIG        = 0x00000001
  AGGR_SIGN_SET       = 0x00000010
  AGGR_GT_SET         = 0x00000020
  AGGR_HASH_OR_ENCODE = 0x00000040
  finalverify: ProjectivePoint t_Fp -> t_Fp_12 -> Bit
  finalverify e1 ctx_GT = is_head_one /\ is_tail_zero where
    e1_affine = affinify E e1
    // TODO: BP' is BLS12_381_G2?
    GT0 = miller_loop_opt_checked e1_affine (POINTonE2_affine_abs (G2.0, G2.1))
    GT1 = fp12_conjugate GT0
    GT2 = Fp_12.mul (GT1, ctx_GT)
    GT3 = fp12_rep (final_exponentiation_impl GT2)
    [[a0, a1, a2], [a3, a4, a5]] = GT3
    // TODO: Might want to create a function "fp12_is_one" that does this last
    // check so that it can be used in both the spec and the proof
    is_head_one = Fp_2.is_equal (fp2_abs a0, fp2_abs one_mont_px)
    is_tail_zero = Fp_2.is_equal (fp2_abs a1, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a2, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a3, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a4, Fp_2.field_zero)
                /\ Fp_2.is_equal (fp2_abs a5, Fp_2.field_zero)
}};

let all_distinct_spec n = do {
  let message_len = 32;
  (messages, messages_ptr) <-
      ptr_to_fresh_readonly "messages"
                            (llvm_array n
                                        (llvm_array message_len (llvm_int 8)));
  llvm_execute_func [ llvm_term {{ `n : [64] }}
                    , llvm_term {{ `message_len : [64] }} 
                    , messages_ptr ];
  llvm_return (llvm_term {{ bool_to_limb (all_distinct messages) }});
};

// TODO: What should n be?  2 and 8 have good coverage.  Maybe just those two?
// There's an argument to be made for 16 as well, which hits an additional
// branch.  9 will also hit an additional branch in pairing_commit
let aggregate_n = 2;

// TODO: Prove
all_distinct_ov <- admit "all_distinct" (all_distinct_spec aggregate_n);

let blst_pairing_finalverify_spec = do {
  /*
  (ctx, ctx_ptr) <- ptr_to_fresh_readonly "ctx"
                                          (llvm_struct "struct.blst_pairing");
                                          */
  ctx_ptr <- llvm_alloc_readonly (llvm_struct "struct.blst_pairing_st");
  GT <- llvm_fresh_var "GT" vec384fp12_type;
  llvm_precond {{ fp12_invariant GT }};
  AggrSign <- llvm_fresh_var "AggrSign" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant AggrSign }};
  crucible_precond {{ is_point_projective E (POINTonE1_abs AggrSign) }}; // on the curve
  crucible_precond {{ ~(Fp.is_equal ((fp_abs (AggrSign.2)), Fp.field_zero)) }};
  llvm_points_to (llvm_elem ctx_ptr 0)
                 (llvm_term {{ AGGR_HASH_OR_ENCODE
                            || AGGR_MIN_SIG
                            || AGGR_SIGN_SET
                            || AGGR_GT_SET }});
  llvm_points_to (llvm_elem ctx_ptr 4) (llvm_term GT);
  llvm_points_to (llvm_elem ctx_ptr 5) (llvm_term AggrSign);
  llvm_execute_func [ ctx_ptr, llvm_null ];
  llvm_return (llvm_term {{ bool_to_limb (finalverify (POINTonE1_abs AggrSign)
                                                      (fp12_abs GT)) }});
};

let demo_BasicAggregateVerify_A_spec n = do {
  global_alloc_init "demo_DST_A" {{ DST }};
  (sig, sig_ptr) <- ptr_to_fresh_readonly "sig" compressed_E1_rep_type;
  (pks, pks_ptr) <-
      ptr_to_fresh_readonly "pks" (llvm_array n compressed_E2_rep_type);
  let message_len = 32;
  (messages, messages_ptr) <-
      ptr_to_fresh_readonly "messages"
                            (llvm_array n
                                        (llvm_array message_len (llvm_int 8)));
  verify_A_sig_preconds sig;
  llvm_precond {{ all verify_A_pk_precond pks }};
  /*
  llvm_precond {{ verify_A_pk_precond (pks@0) }};
  llvm_precond {{ verify_A_pk_precond (pks@1) }};
  llvm_precond {{ verify_A_pk_precond (pks@2) }};
  */
  // TODO: Preconditions.  Likely can lift signature preconditions from
  // BasicVerify, and apply pk preconds to every element in pks.  Also need
  // precond that all messages are unique (Or to integrate that into postcond)
  llvm_execute_func [ llvm_term {{ `n : [64] }}
                    , llvm_term {{ `message_len : [64] }}
                    , pks_ptr
                    , messages_ptr
                    , sig_ptr ];
  // TODO: Postcond
  llvm_return (llvm_term
      {{ bool_to_limb (CoreAggregateVerify (split`{n} (join (join pks))) messages (join sig)) }});
};

let msg_len = 32;
let dst_len = 43;
let aug_len = 0;

Hash_to_G1_ov <- prove_Hash_to_G1_impl_ov msg_len dst_len aug_len;

normalize_hash_to_curve_opt_impl_rws <-
  normalize_hash_to_curve_impl_thms msg_len dst_len aug_len;

hash_to_curve_opt_impl_POINTonE1_from_Jacobian_precond_thms <-
  core_verify_pk_in_g2_POINTonE1_from_Jacobian_hash_preconds msg_len dst_len aug_len;

unfold_all_POINTonE2_affine_invariant_2_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \x1 x2 -> all POINTonE2_affine_invariant [x1, x2] ==
               (POINTonE2_affine_invariant x1 /\
                POINTonE2_affine_invariant x2) }}) [];

unfold_all_POINTonE1_affine_invariant_2_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \x1 x2 -> all POINTonE1_affine_invariant [x1, x2] ==
               (POINTonE1_affine_invariant x1 /\
                POINTonE1_affine_invariant x2) }}) [];

normalize_affine_fp_pair0_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> (Fp.normalize P.0) == (normalize_affine_point Fp P).0 }}) [];

normalize_affine_fp_pair1_thm <- prove_cryptol (rewrite (cryptol_ss())
  {{ \P -> (Fp.normalize P.1) == (normalize_affine_point Fp P).1 }}) [];

hoist_fp_invariant <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c x1 x2 -> fp_invariant (if c then x1 else x2) ==
                   if c then fp_invariant x1 else fp_invariant x2 }})
  ["fp_invariant"];

hoist_fp_abs <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c x1 x2 -> fp_abs (if c then x1 else x2) ==
                   if c then fp_abs x1 else fp_abs x2 }})
  ["fp_abs"];

hoist_is_point_projective_E_z_thm <- prove_cryptol
  (rewrite (cryptol_ss())
    {{ \c x y z1 z2 -> is_point_projective E (x, y, if c then z1 else z2) ==
                       if c
                       then is_point_projective E (x, y, z1)
                       else is_point_projective E (x, y, z2) }}) [];

// TODO: Is this true?  Z==1 should indicate that the point is already affine.
// So if it's on the curve in projective coordinates shouldn't it also be on
// the curve in affine coordinates?  Prove?
is_point_projective_E_affine_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \x y -> is_point_projective E (x, y, Fp.field_unit) ==
             is_point_affine E (x, y) }});

// For vec_is_zero(GT[0][1], sizeof(GT) - sizeof(GT[0][0])) in final verify
let vec_is_zero_5fp2_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" (llvm_array 5 vec384x_type);
  crucible_precond {{ (  fp2_invariant a0
                      /\ fp2_invariant a1
                      /\ fp2_invariant a2
                      /\ fp2_invariant a3
                      /\ fp2_invariant a4 ) where [a0,a1,a2,a3,a4] = a }};
  crucible_execute_func [a_ptr, crucible_term {{ (480:Size_t) }}]; // Non-portable
  crucible_return (crucible_term {{
    (if (  (Fp_2.is_equal (fp2_abs a0, Fp_2.field_zero))
        /\ (Fp_2.is_equal (fp2_abs a1, Fp_2.field_zero))
        /\ (Fp_2.is_equal (fp2_abs a2, Fp_2.field_zero))
        /\ (Fp_2.is_equal (fp2_abs a3, Fp_2.field_zero))
        /\ (Fp_2.is_equal (fp2_abs a4, Fp_2.field_zero))
        ) then 1 else (0:Limb)) where [a0,a1,a2,a3,a4] = a }});
  };

vec_is_zero_5fp2_ov <- test "vec_is_zero" []  vec_is_zero_5fp2_spec;

blst_pairing_finalverify_ov <- custom_verify
  "blst_pairing_finalverify"
  (concat mul_fp12_ovs
          [ POINTonE1_from_Jacobian_ov
          , conjugate_fp12_ov
          , final_exp_alias_ov
          , vec_is_equal_fp2_ov
          , vec_is_zero_5fp2_ov
          , miller_loop_n_1_ov])
  blst_pairing_finalverify_spec
  do {
    rw_with fp12_rep_thms;
    rw_with [affine_inv_affine_rep_e1_thm, one_mont_px_invariant_thm];
    unfolding ["fp12_rep", "fp6_rep", "finalverify", "G2", "one_mont_px"];
    simplify basic_ss;
    simplify (cryptol_ss());
    rw_with fp2_rep_thms;
    rw_with fp12_normalization_thms;
    rw_with POINTonE1_base_thms;
    rw_with [ normalize_miller_loop_opt_checked_thm
            , normalize_affinify_thm ];
    rw_with remove_ho_rules;
    print_goal;
    //print_readably;
    w4_unint_z3 (concat [ "all_distinct"
                        , "POINTonE1_abs"
                        , "POINTonE1_invariant"
                        , "is_point_projective_E"
                        , "fp_abs"
                        , "final_exponentiation_impl"
                        , "fp12_conjugate"
                        , "miller_loop_opt_checked"
                        , "Fp"
                        , "Fp_2"
                        , "fp12_abs" ]
                        BasicVerify_A_unints);
  };


// TODO: This needs to look more like map_size_1_term
let map_size_2_term = parse_core "\\(f : ((Vec 6 (Vec 64 Bool)) * (Vec 6 (Vec 64 Bool))) -> (Integer * Integer)) -> \\(y : Vec 2 ((Vec 6 (Vec 64 Bool)) * (Vec 6 (Vec 64 Bool)))) -> map ((Vec 6 (Vec 64 Bool)) * (Vec 6 (Vec 64 Bool))) (Integer * Integer) f 2 y";

unfold_map <- admit_cryptol (rewrite (cryptol_ss())
  {{ \f xs -> (map_size_2_term f xs) == ([f x1, f x2] where [x1, x2] = xs) }});

demo_BasicAggregateVerify_A_ov <- really_custom_verify
  "demo_BasicAggregateVerify_A"
  (foldr concat [vec_fp2_overrides, vec_overrides/*, mul_fp12_ovs*/]
                [ all_distinct_ov
                , POINTonE1_Uncompress_OK_ov // blst_p1_uncompress_OK_ov
                , POINTonE1_affine_on_curve_ov
                , blst_p1_affine_in_g1_ov
                , demo_KeyValidate_A_ov
                , blst_p2_uncompress_OK_ov
                // ovs used in pairing aggregate:
                , POINTonE1_in_G1_ov
                , Hash_to_G1_ov
                , POINTonE1_from_Jacobian_alias_ov
                , vec_copy_2fp_ov
                // ovs used in blst_pairing_commit:
                , miller_loop_n_2_ov
                // ovs used in blst_pairing_finalverify:
                , blst_pairing_finalverify_ov
                /*
                , POINTonE1_from_Jacobian_ov
                , miller_loop_n_1_ov
                , conjugate_fp12_ov
                , final_exp_ov
                */
                ])
  (demo_BasicAggregateVerify_A_spec aggregate_n)
  do {
    (goal_num_ite 190
      (do {
        // Postcondition proof
        unfolding [ "CoreAggregateVerify" ];
        simplify basic_ss;
        simplify (cryptol_ss());
        //goal_eval_unint (concat ["all_distinct"] BasicVerify_A_unints);
        print_goal;
        w4_unint_z3 (concat [ "all_distinct" ]
                            BasicVerify_A_unints);
      })
      (do {
        // Precondition proof(s)
        unfolding [ "POINTonE1_affine_abs"
                  , "uncompress_E1_imp"
                  , "POINTonE2_affine_abs"
                  , "blst_core_verify_pk_in_g2_error_precond"
                  ];
        simplify basic_ss;
        simplify (cryptol_ss());
        simplify basic_ss;
        rw_with [ hoist_POINTonE1_affine_rep
                , hoist_POINTonE1_affine_invariant
                , hoist_POINTonE2_affine_rep
                , hoist_POINTonE2_affine_invariant
                , affine_inv_affine_rep_e2_thm
                , zero_lt_one_thm
                , intLe_sym_thm
                , affine_inv_affine_rep_e1_thm ];
        rw_with structural_rewrites;
        simplify basic_ss;
        rw_with [ fold_POINTonE1_affine_invariant
                , fold_POINTonE2_affine_invariant
                , hoist_POINTonE1_affine_invariant
                , hoist_POINTonE2_affine_invariant
                , affine_inv_affine_rep_e2_thm
                , fold_POINTonE2_affine_abs_thm
                , hoist_POINTonE2_affine_abs_thm
                , hoist_is_point_O_E'_thm
                , POINTonE2_affine_abs_rep_thm
                , is_point_O_KeyValidate_thm
                , normalize_uncompress_E2_OK_thm
                , unfold_all_POINTonE1_affine_invariant_2_thm
                , unfold_all_POINTonE2_affine_invariant_2_thm
                , affine_inv_affine_rep_e1_thm ];
        rw_with POINTonE1_base_thms;
        unfolding ["POINTonE1_rep"];
        simplify basic_ss;
        simplify (cryptol_ss());
        rw_with fp_rep_thms;
        rw_with normalize_hash_to_curve_opt_impl_rws;
        rw_with hash_to_curve_opt_impl_POINTonE1_from_Jacobian_precond_thms;
        //rw_with_1 is_point_O_affine_rev_thm;
        simplify basic_ss;
        simplify (cryptol_ss());
        unfolding [ "POINTonE1_invariant"
                  , "POINTonE1_affine_rep"
                  , "select"
                  , "POINTonE1_abs" ];
        //hoist_ifs_in_goal;
        rw_with fp_rep_thms;
        rw_with [ normalize_affine_fp_pair0_thm
                , hoist_fp_invariant
                , hoist_fp_abs
                , normalize_affine_fp_pair1_thm
                , one_mont_p_invariant_thm
                , one_mont_p_abs_thm
                , hoist_is_point_projective_E_z_thm
                , is_point_projective_E_affine_thm
                , normalize_uncompress_E1_OK_thm];
        rw_with fp_rep_thms;
        rw_with fp12_rep_thms;
        simplify basic_ss;
        simplify (cryptol_ss());
        rw_with remove_ho_rules;
        //print_readably;
        (goal_num_ite 190
          (do {
            goal_eval_unint (concat [ "affinify_E"
                                    , "all_distinct"
                                    , "BLSMinimalSignatureSize::CoreAggregateVerify"
                                    , "BLSMinimalSignatureSize::KeyValidate"
                                    , "bool_to_limb"
                                    , "F_prod_Fp_12"
                                    , "finalverify"
                                    , "Fp"
                                    , "Fp_2"
                                    , "Fp_12"
                                    , "fp_abs"
                                    , "fp2_abs"
                                    , "hash_to_curve_opt_impl"
                                    , "is_point_projective_E"
                                    , "miller_loop_opt"
                                    , "verify_A_pk_precond"
                                    ]
                                    BasicVerify_A_unints);
            print_goal;
            w4_unint_z3 (concat [ "all_distinct" ]
                                BasicVerify_A_unints);
          })
          (do {
            // Final goal
            unfolding ["Cryptol::map"];
            simplify basic_ss;
            simplify (cryptol_ss());
            rw_with [unfold_map];
            print_goal;
            w4_unint_z3 (concat [ "all_distinct" ]
                                BasicVerify_A_unints);
          }));
      }));
  };
