// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "exp.saw";
//include "curve_operations.saw";
//include "ec_mult.saw";
//include "x86.saw";

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

import "../spec/HashToCurveE1Aux.cry";
HE1 <- cryptol_load "../spec/HashToCurveE1.cry";
import "../spec/implementation/CurveOperation.cry";
//import "../spec/implementation/HashToG1.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/FieldExtras.cry";
import "../spec/implementation/swu_map_E1.cry";
P <- cryptol_load "../spec/Parameters.cry";

// Specs

let map_to_isogenous_E1_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  new_out <- llvm_fresh_var "map_to_isogenous_extract_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

// the code calls this assembly function:
let sgn0x_pty_mont_384_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  (_, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  n0 <- crucible_fresh_var "n0" limb_type;
  crucible_execute_func [a_ptr, p_ptr, crucible_term n0];
  crucible_return (crucible_term {{ (zext (sgn0 (fp_abs a))):[64] }});
};

// we also need this (we need to unfold `recip_sqrt_fp`):
let recip_sqrt_fp_3mod4_spec = do {
    out_ptr <- crucible_alloc vec384_type;
    (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384_type;
    crucible_precond {{ fp_invariant inp }};
    crucible_execute_func [out_ptr, inp_ptr];
    crucible_points_to out_ptr (crucible_term {{fp_rep (Fp.div (Fp.field_unit, sqrt_fp (fp_abs inp))) }});
    };

sgn0x_pty_mont_384_ov <- admit "sgn0x_pty_mont_384" sgn0x_pty_mont_384_spec;
recip_sqrt_fp_3mod4_ov <- admit "recip_sqrt_fp_3mod4" recip_sqrt_fp_3mod4_spec; // TODO: prove (see exp.saw)

enable_experimental;

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
  fp_neg = Fp.neg
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p -> Fp.neg p == fp_neg p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

_ <- llvm_compositional_extract
  m
  "map_to_isogenous_E1"
  "map_to_isogenous_E1_term"
  (concat_all [fp_overrides, vec_overrides, [recip_sqrt_fp_3mod4_ov , sgn0x_pty_mont_384_ov]])
  true
  map_to_isogenous_E1_extract_spec
  do {
    unfolding ["select"];
    simplify fp_simpset;
    w4;
  };

// TODO:
really_custom_prove_cryptol {{ \x -> POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep x)) == (HE1::map_to_curve_simple_swu x) }} assume_unsat;
// testing it:
really_custom_prove_cryptol {{ \(x:[380]) -> POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep (toInteger x))) == (HE1::map_to_curve_simple_swu (toInteger x)) }} (quickcheck 20);
// testing the impl spec:
really_custom_prove_cryptol {{ \(x:[380]) -> POINTonE1_abs (map_to_isogenous_E1_term (fp_rep (toInteger x))) == (map_to_curve_simple_swu_impl (toInteger x)) }} (quickcheck 20);

// We rewrite the constants appearing in the C code (mostly for readability of the goals when debugging; this just saves unfolding Fp.field_unit):
constants_rewrites <- for [
      {{ fp_abs [ 4878930887265312543 , 14750521259635781058 , 8371497156570714123 , 15793066378700994603 , 16433423527091015560 , 32548497384448767 ] == sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) }}
    , {{ fp_abs [ 9830232086645309404 , 1112389714365644829 , 8603885298299447491 , 11361495444721768256 , 5788602283869803809 , 543934104870762216 ] == Z }}
    , {{ fp_abs [ 9180392817347875192 , 12752300768841235045 , 5424152106454515062 , 3349150446948955809 , 1614784533401171638 , 42236840757897548 ] == Fp.mul (Z, A') }}
    ,  {{ fp_abs [ 9987108143941419098 , 10981380979105458492 , 12597673232421864513 , 4365728511027233858 , 2514197008840889506 , 336850944957925653 ] == Fp.neg(A') }}
    , {{ fp_abs [ 3415322872136444497 , 9675504606121301699 , 13284745414851768802 , 2873609449387478652 , 2897906769629812789 , 1536947672689614213 ] == A' }}
    , {{ fp_abs [ 18129637713272545760 , 11144507692959411567 , 10108153527111632324 , 9745270364868568433 , 14587922135379007624 , 469008097655535723 ] == B' }}
    , {{ fp_abs [ 8505329371266088957 , 17002214543764226050 , 6865905132761471162 , 8632934651105793861 , 6631298214892334189 , 1582556514881692819 ] == Fp.field_unit }}
  ] (\ eq -> really_custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4);

//enable_what4_hash_consing;
impl_lemma <- really_custom_prove_cryptol {{ \x -> POINTonE1_abs (map_to_isogenous_E1_term (fp_rep x)) == map_to_curve_simple_swu_impl x }}
  do {
    // the only difference between spec and code is the use of `vec_select` and `vec_is_equal`
    let local_rewrites = run (
      for [
            {{ \x y -> Fp.is_equal (x, y) == (x == y) }}
          , {{ Fp.field_zero == 0 }}
      ] (\ eq -> really_custom_prove_cryptol (rewrite (cryptol_ss ()) eq) w4)
    );
    unfolding ["map_to_curve_simple_swu_impl", "map_to_isogenous_E1_term", "select", "POINTonE1_abs'", "POINTonE1_abs"];
    simplify fp_simpset;
    simplify (addsimps (concat local_rewrites constants_rewrites) empty_ss);
    goal_eval_unint (concat fp_unints ["sqrt_fp","sqrt"]); // TODO: the proof fails without this.. why? Alternatively, enabling hash consing in What4 also works...
    w4_unint_z3 (concat ["Fp"] ["sqrt_fp","sqrt"]);
  };

// Now it remains to prove that the implementation spec is equivalent to the IETF spec

// We need to rewrite `e2`, which is computed differently in the C code compared to the specification
let {{
  e2_eqn = \gx1 gxd -> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul (gx1, gxd))), gxd), gx1)
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq gxd, Fp.mul (gx1, gxd)))
}};

e2_lemma <- simp_then_admit (unfold_term ["e2_eqn"] {{ e2_eqn }}); // TODO: this is a trivial simplification, which unfortunately would be pretty tedious in SAW. Not sure it's worth it...

// testing reveals no errors:
_ <- really_custom_prove_cryptol {{
  \(gx1:[380]) (gxd:[380]) -> gx1 != zero /\ gxd != zero ==> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul ((toInteger gx1), (toInteger gxd)))), (toInteger gxd)), (toInteger gx1))
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq (toInteger gxd), Fp.mul ((toInteger gx1), (toInteger gxd))))
}} (quickcheck 20);

// we need this:
recip_sqrt_fp_algebra_thm <- simp_then_admit {{ \x -> Fp.div (Fp.field_unit, sqrt_fp x) == fp_exp x ((`P::p-3)/4) }};

// the final proof:
impl_eq_swu_3mod4 <- really_custom_prove_cryptol {{ \u -> map_to_curve_simple_swu_impl u == map_to_curve_simple_swu_3mod4 u }}
  do {
    unfolding ["map_to_curve_simple_swu_impl", "map_to_curve_simple_swu_3mod4"];
    simplify (addsimp e2_lemma empty_ss);
    simplify (cryptol_ss ());
    simplify (addsimp recip_sqrt_fp_algebra_thm empty_ss);
    w4_unint_z3 (concat ["Fp"] ["sqrt","fp_exp"]);
  };
