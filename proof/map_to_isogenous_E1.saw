// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "exp.saw";
//include "curve_operations.saw";
//include "ec_mult.saw";
//include "x86.saw";

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

import "../spec/HashToCurveE1Aux.cry";
HE1 <- cryptol_load "../spec/HashToCurveE1.cry";
import "../spec/implementation/CurveOperation.cry";
//import "../spec/implementation/HashToG1.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/FieldExtras.cry";
import "../spec/implementation/swu_map_E1.cry";

// Specs

let map_to_isogenous_E1_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (u, u_ptr) <- ptr_to_fresh_readonly "u" vec384_type;
  llvm_precond {{ fp_invariant u }};
  llvm_execute_func [out_ptr, u_ptr];
  new_out <- llvm_fresh_var "map_to_isogenous_extract_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

// the code calls this assembly function:
let sgn0x_pty_mont_384_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  (_, p_ptr) <- ptr_to_fresh_readonly "p" vec384_type;
  n0 <- crucible_fresh_var "n0" limb_type;
  crucible_execute_func [a_ptr, p_ptr, crucible_term n0];
  crucible_return (crucible_term {{ (zext (sgn0 (fp_abs a))):[64] }});
};

// we also need this (we need to unfold `recip_sqrt_fp`):
let recip_sqrt_fp_3mod4_spec = do {
    out_ptr <- crucible_alloc vec384_type;
    (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384_type;
    crucible_precond {{ fp_invariant inp }};
    crucible_execute_func [out_ptr, inp_ptr];
    crucible_points_to out_ptr (crucible_term {{fp_rep (Fp.div (Fp.field_unit, sqrt_fp (fp_abs inp))) }});
    };

sgn0x_pty_mont_384_ov <- admit "sgn0x_pty_mont_384" sgn0x_pty_mont_384_spec;
recip_sqrt_fp_3mod4_ov <- admit "recip_sqrt_fp_3mod4" recip_sqrt_fp_3mod4_spec; // TODO: prove (see exp.saw)

enable_experimental;

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_exp : t_Fp -> Integer -> t_Fp
  fp_exp = undefined
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss); // NOTE this modifies the goal
    print_goal;
};

// custom version of this:
let vec_is_equal_48_spec_2 = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384_type;
  crucible_execute_func [a_ptr, b_ptr, crucible_term {{ (48:Size_t) }}]; // Non-portable
  crucible_return (crucible_term {{ bool_to_limb (Fp.is_equal (fp_abs a, fp_abs b)) }});
  };

vec_is_equal_48_ov_2 <- verify "vec_is_equal" []  vec_is_equal_48_spec_2;

_ <- llvm_compositional_extract
  m
  "map_to_isogenous_E1"
  "map_to_isogenous_E1_term"
  (concat_all [fp_overrides, vec_overrides, [recip_sqrt_fp_3mod4_ov , sgn0x_pty_mont_384_ov, vec_is_equal_48_ov_2]])
  true
  map_to_isogenous_E1_extract_spec
  do {
    unfolding ["select"];
    simplify fp_simpset;
    w4;
  };

// TODO:
really_custom_prove_cryptol {{ \x -> POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep x)) == (HE1::map_to_curve_simple_swu x) }} assume_unsat;
// testing it:
custom_prove_cryptol {{ \(x:[3]) -> POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep (toInteger x))) == (HE1::map_to_curve_simple_swu (toInteger x)) }} (quickcheck 8);

// We need to rewrite `e2`, which is computed differently in the C code compared to the specification
e2_lemma <- simp_then_admit {{
  \gx1 gxd -> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul (gx1, gxd))), gxd), gx1)
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq gxd, Fp.mul (gx1, gxd)))
}};

// testing reveals no errors:
_ <- custom_prove_cryptol {{
  \(gx1:[6]) (gxd:[6]) -> gx1 != zero /\ gxd != zero ==> (imp_term == spec_term where
    spec_term = Fp.is_equal (Fp.mul (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), Fp.mul ((toInteger gx1), (toInteger gxd)))), (toInteger gxd)), (toInteger gx1))
    imp_term = Fp.is_equal (Fp.sq (Fp.mul (Fp.div (Fp.field_unit, sqrt_fp tv4), tv4)), tv4)
    tv4 = Fp.mul (Fp.sq (toInteger gxd), Fp.mul ((toInteger gx1), (toInteger gxd))))
}} (quickcheck 128);

// TODO: now can we apply it to the actual term?
// First we have to deal with `vec_is_equal`

really_custom_prove_cryptol {{ \x -> POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep x)) == (HE1::map_to_curve_simple_swu x) }}
  do {
    unfolding ["map_to_isogenous_E1_term"];
    simplify fp_simpset;
    print_readably;
    simplify (addsimp e2_lemma empty_ss);
    print_readably;
    assume_unsat;
  };

///////////////////////

P <- cryptol_load "../spec/Parameters.cry";

let {{
  ex1_expected_us =
     [ P::to_Fp 0x0ba14bd907ad64a016293ee7c2d276b8eae71f25a4b941eece7b0d89f17f75cb3ae5438a614fb61d6835ad59f29c564f
     , P::to_Fp 0x019b9bd7979f12657976de2884c7cce192b82c177c80e0ec604436a7f538d231552f0d96d9f7babe5fa3b19b3ff25ac9
     ]
  map_to_curve_test_1_1_a =
      is_point_affine HE1::Curve_E' (POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep 3)))
  map_to_curve_test_1_1_a_ =
      is_point_affine HE1::Curve_E' (HE1::map_to_curve_simple_swu 3)
  map_to_curve_test_1_1_b =
      is_point_affine HE1::Curve_E' (POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep (ex1_expected_us@1))))
}};

let {{
  fixed_impl u = (x,y) where
    y = if sgn0 u != sgn0 y' then y' else Fp.neg y'
    (x,y') = POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep u))
}};

//really_custom_prove_cryptol {{ map_to_curve_test_1_1_a }} w4;
//really_custom_prove_cryptol {{ map_to_curve_test_1_1_b }} w4;
//really_custom_prove_cryptol {{ \x y -> HE1::map_to_curve_simple_swu 3 == x /\ POINTonE1_abs' (map_to_isogenous_E1_term (fp_rep 3)) == y ==> x == y }} w4;

//really_custom_prove_cryptol {{ \x y -> HE1::map_to_curve_simple_swu 3 == x /\ fixed_impl 3 == y ==> x == y }} w4;

//let {{
  //map_to_curve u = (Fp.div(xn,xd), Fp.div(yn,yd)) where
    //(xn,xd,yn,yd) = map_to_curve_simple_swu_impl u
//}};

//really_custom_prove_cryptol {{ \(u:[3]) -> sgn0 ((HE1::map_to_curve_simple_swu (toInteger u)).1) == sgn0 (toInteger u) }} (quickcheck 10);

//really_custom_prove_cryptol {{ \x y -> HE1::map_to_curve_simple_swu 3 == x /\ map_to_curve 3 == y ==> x == y }} w4;
//really_custom_prove_cryptol {{ \x y -> fixed_impl 3 == x /\ map_to_curve 3 == y ==> x == y }} w4;
//really_custom_prove_cryptol {{ \x y -> HE1::map_to_curve_simple_swu 4637 == x /\ map_to_curve 4637 == y ==> x == y }} w4;
//really_custom_prove_cryptol {{ \x y -> fixed_impl 4637 == x /\ map_to_curve 4637 == y ==> x == y }} w4;

//really_custom_prove_cryptol {{ \(x:[3]) -> x != 0 ==> ((toInteger x)%2) != ((Fp.neg (toInteger x))%2) }} w4;
