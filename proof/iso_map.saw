/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// NOTE: equalities of terms involving only Fp.add and Fp.mul (and no
// uninterpreted functions) are tractable. Of course there is the issue of some
// simplifications like x*1 = x not being valid in the current
// representation...

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";

//import "../spec/Parameters.cry";
//import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE1Aux.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/FieldExtras.cry";

// Specs

let blst_isogeny_map_to_E1_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  llvm_precond {{ ~ (is_point_O E (POINTonE1_abs' p)) }}; // Does not work for zero (division by zero etc.)
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ POINTonE1_abs' new_out == iso_map (POINTonE1_abs' p) }};
};

let blst_isogeny_map_to_E1_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

iso_map_impl_lemma <- admit_cryptol {{ // TODO
  \p -> iso_map (affinify E p) == affinify E (iso_map_impl p)
}};

// Proofs

enable_experimental;

_ <- llvm_compositional_extract
  m
  "isogeny_map_to_E1"
  "isogeny_map_to_E1_term"
  fp_overrides
  true
  blst_isogeny_map_to_E1_extract_spec
  (do { // discharge simulation side-conditions
      assume_unsat;
      //unfolding ["POINTonE1_invariant"];
      //simplify (addsimps fp_rep_thms (cryptol_ss ()));
      //w4;
  });

// a few tests:
_ <- custom_prove_cryptol {{ \p -> POINTonE1_abs' (isogeny_map_to_E1_term p) == iso_map (POINTonE1_abs' p) }} (quickcheck 10);

// Here we prove that the implementation and low-level cryptol spec match
impl_thm <- really_custom_prove_cryptol {{ \p -> POINTonE1_abs (isogeny_map_to_E1_term p) == iso_map_impl (POINTonE1_abs p) }}
  (do {
    unfolding ["POINTonE1_abs", "isogeny_map_to_E1_term", "iso_map"];
    simplify (addsimps fp_rep_thms (cryptol_ss ())); // eliminte (abs. rep)
    w4;
  });

// TODO: now it remains to rewrite the arithmetic expressions to get to the high-level spec...
_ <- custom_prove_cryptol {{ \p -> affinify E (iso_map_impl (POINTonE1_abs p)) == iso_map (affinify E (POINTonE1_abs p)) }} (quickcheck 10);

// sometimes, rewrite rules do not apply if they are not first simplified with cryptol_ss
let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_exp : t_Fp -> Integer -> t_Fp
  fp_exp = undefined
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss);
    print_goal;
};

// We will need to prove that some expression of the field Fp are equivalent.
// To do so, we will try to rewrite them to a normal form with the following
// rules. The big problem is that we cannot use commutativity or associativity,
// which would make the rewriter loop....

zero_unit_rewrites <- for [ // here we are cheating: this is true only if we use modular types
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  //, {{ \x -> Fp.div (x, x) == if (Fp.is_equal (x, Fp.field_zero)) then apply Fp.div (x,x) else Fp.field_unit }}
  //, {{ \x y z -> Fp.div (Fp.mul (x,z), Fp.mul(y,z)) == Fp.div (x,y) }} // this rule seems better than the previous because it is unconditional
] simp_then_admit;

// NOTE: I'm assuming that rules are applied in the order they appear; if not, we will likely mess up the order of variables in products and, since we can't use commutativity as it would loop, we're in trouble
push_div_out_rewrites <- for [
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.div (Fp.div (z, x), y) == Fp.div (z, Fp.mul (x,y)) }} // this will mess up the order of terms if the first rule is not applied with higher priority; TODO: we might not need this rule at all
] simp_then_admit;

sum_of_prods_rewrites <- for [
  {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
] simp_then_admit;

unsquare_rewrite <- simp_then_admit {{ \a -> Fp.sq a == Fp.mul (a,a) }};

left_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z) }};

// this one is not included in algebra_simpset below:
right_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (Fp.mul (x, y),z) == Fp.mul (x, Fp.mul (y,z)) }};

simp_div_rewrites <- for [
    {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
  , {{ \x y z -> Fp.div (Fp.mul (y,x), Fp.mul(z,x)) == Fp.div (y,z) }}
  , {{ \x y z -> Fp.div (Fp.mul (x,y), Fp.mul(x,z)) == Fp.div (y,z) }}
] simp_then_admit;

let algebra_simpset = addsimps (concat_all [zero_unit_rewrites, [unsquare_rewrite], [left_fold_mul], sum_of_prods_rewrites, push_div_out_rewrites, simp_div_rewrites]) empty_ss;

let {{
  powers x = ps where
    ps = [Fp.field_unit] # [Fp.mul(x, pi) | pi <- ps]
  zz11 z = (powers (Fp.sq z))@11
  zz15 z = (powers (Fp.sq z))@15
}};

// we will first rewrite iso_map to get rid of div terms
// first we multiply x_num and x_den by zz11, and y_num and y_den by zz15
let {{
  iso_map_2 (x', y', z') = (x, y) where
    (X,Y) = affinify E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
}};

rewrite_1 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map (affinify E p) == iso_map_2 p }})
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimps (concat_all [zero_unit_rewrites, simp_div_rewrites]) empty_ss);
    w4_unint_z3 fp_unints;
  });

// then we massage y a bit more:
let {{
  iso_map_3 (x', y', z') = (x, y) where
    (X,Y) = affinify E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')))
}};

hoist_if_mul_1 <- really_custom_prove_cryptol (rewrite (cryptol_ss()) {{ \x a b c -> Fp.mul(if a then b else c, x) == if a then Fp.mul (b,x) else Fp.mul (c,x) }}) w4;
hoist_if_mul_2 <- really_custom_prove_cryptol (rewrite (cryptol_ss()) {{ \x a b c -> Fp.mul(x, if a then b else c) == if a then Fp.mul (x,b) else Fp.mul (x,c) }}) w4;
hoist_if_proj_2 <- really_custom_prove_cryptol (rewrite (cryptol_ss()) {{ \a (b:(Integer,Integer)) (c:(Integer,Integer))-> (if a then b else c).1 == if a then b.1 else c.1 }}) w4;

aux_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \y_num y_den x' y' z' -> (Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z'))) == if ~(is_zero Fp z') then Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z'))) else apply Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
  where (X,Y) = affinify E (x', y', z'))
}})
 (do {
    unfolding ["affinify","E","apply"];
    simplify (addsimps [hoist_if_proj_2,hoist_if_mul_1,hoist_if_mul_2] empty_ss);
    simplify algebra_simpset;
    w4_unint_z3 fp_unints;
 });

rewrite_2 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map_2 p == if ~(is_zero Fp p.2) then iso_map_3 p else apply iso_map_2 p }})
  (do {
    unfolding ["iso_map_2","apply"];
    simplify (addsimp aux_rewrite empty_ss);
    w4_unint_z3 fp_unints;
  });

// Rewrite rule for x_num

let {{
  x_num_times_zz11 x' z' = Fp.mul (x_num, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- (powers X)]
  // here we don't want any divisions:
  x_num_times_zz11_nodiv x' z' = x_num where
    x'_powers = take`{front=12}(powers x')
    zz'_powers = take`{front=12}(powers zz')
    zz' = Fp.sq z'
    x_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k1s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_x_num_times_zz11 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_num_times_zz11_nodiv x z == x_num_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","x_num_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// Now let's prove that the nodiv term is equivalent to the implementation term. Since there are no divisions left, Z3 is able to handle the proof obligations (or is it rewriting in What4?)

let {{
  x_num_times_zz11_impl x' z' = xn where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k1s]) x' where // k0 to k11
      kzzs = map_fp_times_Zz`{n=11} k1s zzs // k0 to k10
}};

x_num_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_num_times_zz11_impl"] {{ \x z -> x_num_times_zz11_impl x z == x_num_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// now let's make sure we can rewrite the implementation term:
rewrite (addsimp x_num_rewrite empty_ss) (rewrite (cryptol_ss ()) (unfold_term ["iso_map_impl"] {{ iso_map_impl }})); // works: the nodiv term appears. Note how we need to rewrite with cryptol_ss first

// rewrite rule for x_den

let {{
  x_den_times_zz11 x' z' = Fp.mul (x_den, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_den = F.add ((powers X)@10, F_sum F [F.mul(ki, xi) | ki <- k2s | xi <- (powers X)])
  // here we don't want any divisions:
  x_den_times_zz11_nodiv x' z' = x_den where
    x'_powers = take`{front=11}(powers x')
    zz'_powers = tail (take`{front=12}(powers zz'))
    zz' = Fp.sq z'
    x_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k2s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

really_custom_prove_cryptol {{ \(x:[8]) (z:[8]) -> x_den_times_zz11 (toInteger x) (toInteger z) == x_den_times_zz11_nodiv (toInteger x) (toInteger z) }} (quickcheck 20);

elim_div_rewrite_x_den_times_zz11 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_den_times_zz11_nodiv x z == x_den_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k2s","x_den_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  x_den_times_zz11_impl x' z' = xd where
    zzs = Zz_powers z'
    xd = Fp.mul (xs, last zzs)
    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) x'
    xkzz9 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=10} k2s zzs
}};

x_den_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_den_times_zz11_impl"] {{ \x z -> x_den_times_zz11_impl x z == x_den_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// now let's make sure we can rewrite the implementation term:
rewrite (addsimp x_den_rewrite empty_ss) (rewrite (cryptol_ss ()) (unfold_term ["iso_map_impl"] {{ iso_map_impl }})); // works: the nodiv term appears. Note how we need to rewrite with cryptol_ss first

// rewrite rule for y_num

let {{
  y_num_times_zz15 x' y' z' = Fp.mul (y', Fp.mul (y_num, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- (powers X)]
  // here we don't want any divisions:
  y_num_times_zz15_nodiv x' y' z' = Fp.mul (y_num, y') where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k3s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_y_num_times_zz15 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x y z -> y_num_times_zz15_nodiv x y z == y_num_times_zz15 x y z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","y_num_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

let {{
  y_num_times_zz15_impl x' y' z' = Fp.mul (xn, y') where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k3s]) x' where
      kzzs = map_fp_times_Zz`{n=15} k3s zzs
}};

y_num_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_num_times_zz15_impl"] {{ \x y z -> y_num_times_zz15_impl x y z == y_num_times_zz15_nodiv x y z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k3s"]);
    w4;
  });

// now let's make sure we can rewrite the implementation term:
rewrite (addsimp y_num_rewrite empty_ss) (rewrite (cryptol_ss ()) (unfold_term ["iso_map_impl"] {{ iso_map_impl }})); // works: the nodiv term appears. Note how we need to rewrite with cryptol_ss first

// rewrite rule for y_den

let {{
  y_den_times_zz15 x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_den = F.add ((powers X)@15, F_sum F [F.mul(ki, xi) | ki <- k4s | xi <- (powers X)])
  // here we don't want any divisions:
  y_den_times_zz15_nodiv x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  y_den) where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k4s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

really_custom_prove_cryptol {{ \(x:[8]) (z:[8]) -> y_den_times_zz15 (toInteger x) (toInteger z) == y_den_times_zz15_nodiv (toInteger x) (toInteger z) }} (quickcheck 20);

elim_div_rewrite_y_den_times_zz15 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> y_den_times_zz15_nodiv x z == y_den_times_zz15 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k4s","y_den_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  y_den_times_zz15_impl x' z' = Fp.mul (Fp.mul (xs, z'), last zzs) where
    zzs = Zz_powers z'
    xs = map_fp ((take`{front=14}kzzs)#[ykzz14]) x'
    ykzz14 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=15} k4s zzs
}};

y_den_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_den_times_zz15_impl"] {{ \x z -> y_den_times_zz15_impl x z == y_den_times_zz15_nodiv x z }}))
  (do {
    unfolding ["y_den_times_zz15_nodiv"];
    goal_eval_unint (concat fp_unints ["k4s"]);
    w4;
  });

// now let's make sure we can rewrite the implementation term:
rewrite (addsimp y_den_rewrite empty_ss) (rewrite (cryptol_ss ()) (unfold_term ["iso_map_impl"] {{ iso_map_impl }})); // works: the nodiv term appears. Note how we need to rewrite with cryptol_ss first

// we are also going to use this:
to_jacobian_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ())
  {{
    \xn xd yn yd -> affinify E (to_jacobian xn xd yn yd) == if ~(is_zero Fp (Fp.mul (xd,yd))) then (F.div (xn, xd), F.div(yn, yd)) else apply affinify E (to_jacobian xn xd yn yd)
  }})
  (do {
    unfolding ["to_jacobian", "affinify", "F", "E"];
    simplify algebra_simpset;
    simplify (addsimp right_fold_mul empty_ss);
    simplify (addsimps simp_div_rewrites empty_ss);
    w4_unint_z3 fp_unints;
  });

// For now we assume this property. TODO: is there something better to do?
x_den_times_y_den_nz <- simp_then_admit {{
  \(p:(Integer,Integer,Integer)) -> is_zero Fp (Fp.mul (x_den_times_zz11 p.0 p.2, y_den_times_zz15 p.0 p.2)) == if ~(is_zero Fp p.2) then False else apply is_zero Fp (Fp.mul (x_den_times_zz11 p.0 p.2, y_den_times_zz15 p.0 p.2))
}};

iso_map_impl_lemma <- really_custom_prove_cryptol {{
  \p -> ~(is_zero Fp p.2) ==> iso_map (affinify E p) == affinify E (iso_map_impl p)
}}
  (do {
    simplify (addsimps [rewrite_1, rewrite_2] empty_ss);
    unfolding ["iso_map_impl"];
    simplify (cryptol_ss ());
    simplify (addsimps [x_num_rewrite, elim_div_rewrite_x_num_times_zz11, x_den_rewrite, elim_div_rewrite_x_den_times_zz11, y_num_rewrite, elim_div_rewrite_y_num_times_zz15, y_den_rewrite, elim_div_rewrite_y_den_times_zz15] empty_ss);
    simplify (cryptol_ss ());
    simplify (addsimp to_jacobian_rewrite empty_ss);
    unfolding ["F"];
    simplify (addsimp x_den_times_y_den_nz empty_ss);
    w4_unint_z3 fp_unints;
  });
