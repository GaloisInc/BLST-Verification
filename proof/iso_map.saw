/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// NOTE: equalities of terms involving only Fp.add and Fp.mul (and no
// uninterpreted functions) are tractable. Of course there is the issue of some
// simplifications like x*1 = x not being valid in the current
// representation...

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";

//import "../spec/Parameters.cry";
//import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE1Aux.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/FieldExtras.cry";

// Specs

let blst_isogeny_map_to_E1_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  llvm_precond {{ ~ (is_point_O E (POINTonE1_abs' p)) }}; // Does not work for zero (division by zero etc.)
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ POINTonE1_abs' new_out == iso_map (POINTonE1_abs' p) }};
};

let blst_isogeny_map_to_E1_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

iso_map_impl_lemma <- admit_cryptol {{ // TODO
  \p -> iso_map (affinify E p) == affinify E (iso_map_impl p)
}};

// Proofs

enable_experimental;

_ <- llvm_compositional_extract
  m
  "isogeny_map_to_E1"
  "isogeny_map_to_E1_term"
  fp_overrides
  true
  blst_isogeny_map_to_E1_extract_spec
  (do { // discharge simulation side-conditions
      assume_unsat;
      //unfolding ["POINTonE1_invariant"];
      //simplify (addsimps fp_rep_thms (cryptol_ss ()));
      //w4;
  });

// a few tests:
_ <- custom_prove_cryptol {{ \p -> POINTonE1_abs' (isogeny_map_to_E1_term p) == iso_map (POINTonE1_abs' p) }} (quickcheck 10);

// Here we prove that the implementation and low-level cryptol spec match
impl_thm <- really_custom_prove_cryptol {{ \p -> POINTonE1_abs (isogeny_map_to_E1_term p) == iso_map_impl (POINTonE1_abs p) }}
  (do {
    unfolding ["POINTonE1_abs", "isogeny_map_to_E1_term", "iso_map"];
    simplify (addsimps fp_rep_thms (cryptol_ss ())); // eliminte (abs. rep)
    w4;
  });

// TODO: now it remains to rewrite the arithmetic expressions to get to the high-level spec...
_ <- custom_prove_cryptol {{ \p -> affinify E (iso_map_impl (POINTonE1_abs p)) == iso_map (affinify E (POINTonE1_abs p)) }} (quickcheck 10);

// first let's not worry about z = 0...
let {{
  affinify_nz (x,y,z) = (Fp.mul(lambda2, x), Fp.mul(lambda3, y)) where
    lambda = Fp.div (Fp.field_unit, z)
    lambda2 = Fp.sq lambda
    lambda3 = Fp.mul(lambda, lambda2)
}};

// sometimes, rewrite rules do not apply if they are not first simplified with cryptol_ss
let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_exp : t_Fp -> Integer -> t_Fp
  fp_exp = undefined
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss);
    print_goal;
};

basic_algebra_simps <- for [ // true only if we use modular types
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  //, {{ \x -> Fp.div (x, x) == if (Fp.is_equal (x, Fp.field_zero)) then apply Fp.div (x,x) else Fp.field_unit }}
  , {{ \x y z -> Fp.div (Fp.mul (x,z), Fp.mul(y,z)) == Fp.div (x,y) }} // this rule seems better than the previous because it is unconditional
] simp_then_admit;

// TODO: why not use a common definition of powers everywhere?
let {{
  powers x = ps where
    ps = [Fp.field_unit] # [Fp.mul(x, pi) | pi <- ps]
  //zz_powers z = [zz] # [Fp.mul(zzi, zz) | zzi <- (zz_powers z)] where
    //zz = Fp.sq z
  zz11 z = (powers (Fp.sq z))@11
  zz15 z = (powers (Fp.sq z))@15
}};

// we will first rewrite iso_map to get rid of div terms
// first we multiply x_num and x_den by zz11, and y_num and y_den by zz15
let {{
  iso_map_2 (x', y', z') = (x, y) where
    (X,Y) = affinify E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.mul (Y, Fp.div(Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
}};

rewrite_1 <- really_custom_prove_cryptol {{ \x y z -> iso_map (affinify E (x,y,z)) == iso_map_2 (x,y,z) }}
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimps basic_algebra_simps empty_ss);
    w4_unint_z3 fp_unints;
  });

let more_algebra_eqs = [
   // push division to the outermost scope:
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  // convert to sum of products:
  , {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a -> Fp.sq a == Fp.mul (a,a) }} // get rid of square
  // rearange multiplication to get a left fold
  , {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z)}}
  // eliminate divs:
  , {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
];

more_algebra_rewrites <- for more_algebra_eqs simp_then_admit;

// Rewrite rule for x_num

let {{
  x_num_times_zz11 x' z' = Fp.mul (x_num, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- (powers X)]
  // here we don't want any divisions:
  x_num_times_zz11_nodiv x' z' = x_num where
    x'_powers = take`{front=12}(powers x')
    zz'_powers = take`{front=12}(powers zz')
    zz' = Fp.sq z'
    x_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k1s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite <- really_custom_prove_cryptol {{ \x z -> x_num_times_zz11 x z == x_num_times_zz11_nodiv x z }}
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","x_num_times_zz11_nodiv"]);
    //simplify (addsimps (concat more_algebra_rewrites basic_algebra_simps) empty_ss); // that also works
    simplify (addsimps basic_algebra_simps empty_ss); // get rid of 1*x etc.
    simplify (addsimps (elems_at [5] more_algebra_rewrites) empty_ss); // get rid of square
    simplify (addsimps (elems_at [3,4] more_algebra_rewrites) empty_ss); // rewrite to sum of products
    simplify (addsimps (concat_all [(elems_at [0,1,2] more_algebra_rewrites), basic_algebra_simps]) empty_ss); // push division to the outermost scope:
    simplify (addsimps (elems_at [6] more_algebra_rewrites) empty_ss); // reorganize mul terms to obtain a left fold everywhere
    simplify (addsimps (elems_at [7] more_algebra_rewrites) empty_ss); // eliminate divisions
    print_readably;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  x_num_times_zz11_impl x' z' = xn where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k1s]) x' where // k0 to k11
      kzzs = map_fp_times_Zz`{n=11} k1s zzs // k0 to k10
}};

x_num_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_num_times_zz11_impl"] {{ \x z -> x_num_times_zz11_impl x z == x_num_times_zz11_nodiv x z }}))
  (do {
    unfolding ["x_num_times_zz11_nodiv"];
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// now let's make sure we can rewrite the implementation term:
rewrite (addsimp x_num_rewrite empty_ss) (rewrite (cryptol_ss ()) (unfold_term ["iso_map_impl"] {{ iso_map_impl }})); // works: the nodiv term appears. Note how we need to rewrite with cryptol_ss first

// TODO: rewrite rule for x_den

let {{
  x_den_times_zz11 x' z' = Fp.mul (x_den, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_den = F.add ((powers X)@10, F_sum F [F.mul(ki, xi) | ki <- k2s | xi <- (powers X)])
  // here we don't want any divisions:
  x_den_times_zz11_nodiv x' z' = x_den where
    x'_powers = take`{front=11}(powers x')
    zz'_powers = tail (take`{front=12}(powers zz'))
    zz' = Fp.sq z'
    x_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k2s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

really_custom_prove_cryptol {{ \(x:[8]) (z:[8]) -> x_den_times_zz11 (toInteger x) (toInteger z) == x_den_times_zz11_nodiv (toInteger x) (toInteger z) }} (quickcheck 20);

elim_div_rewrite <- really_custom_prove_cryptol {{ \x z -> x_den_times_zz11 x z == x_den_times_zz11_nodiv x z }}
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k2s","x_den_times_zz11_nodiv"]);
    simplify (addsimps (concat more_algebra_rewrites basic_algebra_simps) empty_ss);
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  x_den_times_zz11_impl x' z' = xd where
    zzs = Zz_powers z'
    xd = Fp.mul (xs, last zzs)
    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) x'
    xkzz9 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=10} k2s zzs
}};

x_den_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_den_times_zz11_impl"] {{ \x z -> x_den_times_zz11_impl x z == x_den_times_zz11_nodiv x z }}))
  (do {
    unfolding ["x_den_times_zz11_nodiv"];
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// now let's make sure we can rewrite the implementation term:
rewrite (addsimp x_den_rewrite empty_ss) (rewrite (cryptol_ss ()) (unfold_term ["iso_map_impl"] {{ iso_map_impl }})); // works: the nodiv term appears. Note how we need to rewrite with cryptol_ss first

// TODO: y_num

rewrite_2 <- really_custom_prove_cryptol {{ \x y z -> iso_map_2 (x,y,z) == affinify E (iso_map_impl (x,y,z)) }}
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimp (elem_at 0 more_algebra_rewrites) empty_ss);
    goal_eval_unint (concat fp_unints ["k1s","k2s","k3s","k4s","iso_map_impl"]);
    //simplify (addsimps more_algebra_rewrites empty_ss);
    simplify (addsimps basic_algebra_simps empty_ss);
    print_readably;
    assume_unsat;
    //w4;
    //w4_unint_z3 fp_unints;
  });

_ <- really_custom_prove_cryptol {{ \x y z -> affinify E (iso_map_impl (x,y,z)) == iso_map (affinify E (x,y,z)) }}
  (do {
    simplify (addsimp rewrite_1 empty_ss);
    //unfolding ["affinify_nz"];
    //simplify (cryptol_ss ());
    print_readably;
    //goal_eval_unint (concat fp_unints ["iso_map"]);  // working on HE1::iso_map first
    //simplify (addsimps basic_algebra_simps (cryptol_ss ()));
    //print_readably;
    assume_unsat;
  });

blst_isogeny_map_to_E1_ov <- custom_verify "isogeny_map_to_E1" fp_overrides blst_isogeny_map_to_E1_spec
  (do {
    goal_num_ite 176
      (do { //  the main safety goal
        unfolding ["POINTonE1_abs'"];
        simplify (addsimp iso_map_impl_lemma empty_ss);
        simplify (addsimps (concat fp_alg_thms fp_rep_thms) (cryptol_ss ()));
        unfolding ["iso_map"];
        simplify (cryptol_ss ());
        goal_eval_unint (concat fp_unints ec_mult_unints);
        print_goal;
        print_goal_consts;
        //assume_unsat;
        w4_unint_z3 ["Fp","fp_invariant","POINTonE1_abs","POINTonE1_invariant"];
      })
      (do { // discharge simulation side-conditions
        assume_unsat;
        //unfolding ["POINTonE1_invariant"];
        //simplify (addsimps fp_rep_thms (cryptol_ss ()));
        //w4;
      });
  });
