/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";

//import "../spec/Parameters.cry";
//import "../spec/ShortWeierstrassCurve.cry";
import "../spec/HashToCurveE1Aux.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/FieldExtras.cry";

// Specs

let blst_isogeny_map_to_E1_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  llvm_precond {{ ~ (is_point_O E (POINTonE1_abs' p)) }}; // Does not work for zero (division by zero etc.)
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ POINTonE1_abs' new_out == iso_map (POINTonE1_abs' p) }};
};

let blst_isogeny_map_to_E1_extract_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
};

iso_map_impl_lemma <- admit_cryptol {{ // TODO
  \p -> iso_map (affinify E p) == affinify E (iso_map_impl p)
}};

// Proofs

enable_experimental;

_ <- llvm_compositional_extract
  m
  "isogeny_map_to_E1"
  "isogeny_map_to_E1_term"
  fp_overrides
  true
  blst_isogeny_map_to_E1_extract_spec
  (do { // discharge simulation side-conditions
      assume_unsat;
      //unfolding ["POINTonE1_invariant"];
      //simplify (addsimps fp_rep_thms (cryptol_ss ()));
      //w4;
  });

// a few tests:
_ <- custom_prove_cryptol {{ \p -> POINTonE1_abs (isogeny_map_to_E1_term p) == iso_map_impl (POINTonE1_abs p) }} (quickcheck 1);
_ <- custom_prove_cryptol {{ \p -> POINTonE1_abs' (isogeny_map_to_E1_term p) == iso_map (POINTonE1_abs' p) }} (quickcheck 10);

// Here we prove that the implementation and cryptol spec match
impl_thm <- custom_prove_cryptol {{ \p -> POINTonE1_abs (isogeny_map_to_E1_term p) == iso_map_impl (POINTonE1_abs p) }}
  (do {
    unfolding ["POINTonE1_abs", "isogeny_map_to_E1_term", "iso_map"];
    simplify (addsimps fp_rep_thms (cryptol_ss ())); // eliminte (abs. rep)
    w4;
  });

// TODO: now it remains to rewrite the arithmetic expressions to get to the high-level spec...
_ <- custom_prove_cryptol {{ \p -> affinify E (iso_map_impl (POINTonE1_abs p)) == iso_map (affinify E (POINTonE1_abs p)) }} (quickcheck 1);

// first let's not worry about z = 0...
let {{ affinify_nz (x,y,z) = (Fp.mul(lambda2, x), Fp.mul(lambda3, y)) where
  lambda = Fp.div (Fp.field_unit, z);
  lambda2 = Fp.sq lambda;
  lambda3 = Fp.mul(lambda, lambda2)
}};

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_exp : t_Fp -> Integer -> t_Fp
  fp_exp = undefined
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss);
    print_goal;
};

algebra_simps <- for [ // true only if we use modular types
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  , {{ \x -> Fp.div (x, x) == if (Fp.is_equal (x, Fp.field_zero)) then apply Fp.div (x,x) else Fp.field_unit }}
] simp_then_admit;

//let {{
  //F_sum_p = F_sum Fp
//}};

//F_sum_rewrite <- admit_cryptol {{ \(xs:[12]Integer) -> (F_sum Fp xs) == F_sum_p xs}};

let{{
  zz_powers z = [zz] # [Fp.mul(zzi, zz) | zzi <- (zz_powers z)] where
    zz = Fp.sq z
  zz11 z = (zz_powers z)@10
  zz15 z = (zz_powers z)@14
}};

let {{
iso_map_2 (x', y', z') = (x, y) where
  (X,Y) = affinify_nz (x', y', z')
  x_powers = [Fp.field_unit] # [Fp.mul(X, xi) | xi <- x_powers]
  x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
  x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
  y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
  y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
  x = Fp.mul (Fp.div (x_num, x_den), Fp.div (zz11 z', zz11 z'))
  y = Fp.mul (Y, Fp.mul (Fp.div(y_num, y_den), Fp.div (zz15 z', zz15 z')))
}};

// TODO: a shortcut for now:
zz11_nz <- simp_then_admit {{ \z -> Fp.is_equal (zz11 z, Fp.field_zero) == False }};
zz15_nz <- simp_then_admit {{ \z -> Fp.is_equal (zz15 z, Fp.field_zero) == False }};

// first test that it's right:
_ <- really_custom_prove_cryptol {{ \p -> iso_map (affinify_nz (POINTonE1_abs p)) == iso_map_2 (POINTonE1_abs p) }} (quickcheck 10);

// now prove it:

rewrite_1 <- really_custom_prove_cryptol {{ \x y z -> iso_map (affinify_nz (x,y,z)) == iso_map_2 (x,y,z) }}
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimps algebra_simps empty_ss);
    simplify (add_prelude_eqs ["ite_false"] (addsimps [zz11_nz, zz15_nz] (cryptol_ss ())));
    simplify (addsimps algebra_simps empty_ss);
    //print_readably;
    w4_unint_z3 fp_unints;
  });

let more_alg_eqs = [
   // push division to the outermost scope:
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \a b c -> Fp.mul (Fp.div (a, b), c) == Fp.div (Fp.mul (a,c), b) }}
  // convert to sum of products:
  , {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a -> Fp.sq a == Fp.mul (a,a) }} // get rid of square
  // rearange multiplication to get a left fold
  , {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z)}}
  // eliminate divs:
  , {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
];

more_alg_rewrites <- for more_alg_eqs simp_then_admit;

// NOTE: it is hopeless to have Z3 prove anything about division, but it can prove basic properties of multiplication and addition:
really_custom_prove_cryptol (elem_at 4 more_alg_eqs) w4;
really_custom_prove_cryptol (elem_at 5 more_alg_eqs) w4;
// unfortunately, it cannot even do this:
//really_custom_prove_cryptol (rewrite (addsimps readability_rewrites empty_ss) {{ \a b c d -> Fp.div(d, Fp.mul (c, Fp.add (a, b))) == Fp.div(d, Fp.add (Fp.mul (a,c), Fp.mul (b,c))) }}) (do {print_goal; w4_unint_z3 ["fp_div"];});

// Let's try something else
let {{
  xs_1 X = F_sum Fp xs where
    xs = [Fp.field_unit] # [Fp.mul(X, xi) | xi <- xs | i <- [0..12]]
  xs_2 X = F_sum Fp xs where
    xs = [Fp.field_unit] # [Fp.mul(xi, X) | xi <- xs | i <- [0..12]]
}};
really_custom_prove_cryptol {{ \x -> xs_1 x == xs_2 x }} w4; // This works!

// another experiment
let {{
  t_1 X = F_sum Fp kxs where
    kxs = [Fp.mul(ki, xi) | ki <- k1s | xi <- xs]
    xs = [Fp.field_unit] # [Fp.mul(X, xi) | xi <- xs]
  t_2 X = last xs where
    xs = [last k1s] # [Fp.add (Fp.mul (xi, X), ki) | ki <- tail (reverse k1s) | xi <- xs]
}};
really_custom_prove_cryptol {{ \(x:[9]) -> t_1 (toInteger x) == t_2 (toInteger x) }} (quickcheck 10);
really_custom_prove_cryptol {{ \x -> t_1 x == t_2 x }} w4; // Works too!

// The conclusion of those last two experiments is that equalities of terms involving only add and mul (and no uninterpreted functions) are tractable. Of course there is the issue of some simplifications like x*1 = x not being valid in the current representation...

// Now let's try a useful rule:
let {{
  x_num_times_z11 x' z' = Fp.mul (x_num, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    X_powers = [Fp.field_unit] # [Fp.mul(X, xi) | xi <- X_powers]
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- X_powers]
  // here we don't want any divisions:
  x_num_times_z11_2 x' z' = x_num where
    powers a = ps where
      ps = [Fp.field_unit] # [Fp.mul(a, pi) | pi <- ps | i <- [1..11]]
    x'_powers = powers x'
    zz'_powers = powers zz'
    zz' = Fp.sq z'
    x_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k1s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

// If we get something higher than the modulus then it might fail...
really_custom_prove_cryptol {{ \(x:[4]) (y:[4]) -> x_num_times_z11 (toInteger x) (toInteger y) == x_num_times_z11_2 (toInteger x) (toInteger y) }} (quickcheck 10);

// now if we have the above, we can try to automatically prove equivalence with the implementation:
let {{
  x_num_times_z11_impl x' z' = xn where
    zzs = Zz_powers z'
    ks = take`{front=12}k1s
    xn = map_fp (kzzs#[last ks]) x' where // k0 to k11
      kzzs = map_fp_times_Zz`{n=11} ks zzs // k0 to k10
}};

really_custom_prove_cryptol {{ \(x:[3]) (y:[3]) -> x_num_times_z11_impl (toInteger x) (toInteger y) == x_num_times_z11_2 (toInteger x) (toInteger y) }} (quickcheck 10);

// that works!:
really_custom_prove_cryptol {{ \x z -> x_num_times_z11_impl x z == x_num_times_z11_2 x z }}
  (do {
    unfolding ["x_num_times_z11_impl", "x_num_times_z11_2"];
    goal_eval_unint (concat fp_unints ["k1s"]);
    //simplify (addsimps algebra_simps empty_ss);
    //print_readably;
    w4;
  });

// NOTE: at this point, it looks like there is a reasonable chance that, after getting rid of the zz^i/zz^j terms, things will work out.
// So, we need to show:
really_custom_prove_cryptol {{ \x z -> x_num_times_z11 x z == x_num_times_z11_2 x z }}
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","x_num_times_z11_2"]);
    simplify (addsimps algebra_simps empty_ss); // get rid of 1*x etc.
    simplify (addsimps (elems_at [6] more_alg_rewrites) empty_ss); // get rid of square
    simplify (addsimps (elems_at [4,5] more_alg_rewrites) empty_ss); // rewrite to sum of products
    simplify (addsimps (concat_all [(elems_at [0,1,2] more_alg_rewrites), algebra_simps]) empty_ss); // push division to the outermost scope:
    simplify (addsimps (elems_at [7] more_alg_rewrites) empty_ss); // reorganize mul terms to obtain a left fold everywhere
    simplify (addsimps (elems_at [8] more_alg_rewrites) empty_ss); // eliminate divisions
    print_readably;
    w4; // SUCCESS!
  });

rewrite_2 <- really_custom_prove_cryptol {{ \x y z -> iso_map_2 (x,y,z) == affinify_nz (iso_map_impl (x,y,z)) }}
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimp (elem_at 0 more_alg_rewrites) empty_ss);
    goal_eval_unint (concat fp_unints ["k1s","k2s","k3s","k4s","iso_map_impl"]);
    //simplify (addsimps more_alg_rewrites empty_ss);
    simplify (addsimps algebra_simps empty_ss);
    print_readably;
    assume_unsat;
    //w4;
    //w4_unint_z3 fp_unints;
  });

_ <- really_custom_prove_cryptol {{ \x y z -> affinify_nz (iso_map_impl (x,y,z)) == iso_map (affinify_nz (x,y,z)) }}
  (do {
    simplify (addsimp rewrite_1 empty_ss);
    //unfolding ["affinify_nz"];
    //simplify (cryptol_ss ());
    print_readably;
    //goal_eval_unint (concat fp_unints ["iso_map"]);  // working on HE1::iso_map first
    //simplify (addsimps algebra_simps (cryptol_ss ()));
    //print_readably;
    assume_unsat;
  });

blst_isogeny_map_to_E1_ov <- custom_verify "isogeny_map_to_E1" fp_overrides blst_isogeny_map_to_E1_spec
  (do {
    goal_num_ite 176
      (do { //  the main safety goal
        unfolding ["POINTonE1_abs'"];
        simplify (addsimp iso_map_impl_lemma empty_ss);
        simplify (addsimps (concat fp_alg_thms fp_rep_thms) (cryptol_ss ()));
        unfolding ["iso_map"];
        simplify (cryptol_ss ());
        goal_eval_unint (concat fp_unints ec_mult_unints);
        print_goal;
        print_goal_consts;
        //assume_unsat;
        w4_unint_z3 ["Fp","fp_invariant","POINTonE1_abs","POINTonE1_invariant"];
      })
      (do { // discharge simulation side-conditions
        assume_unsat;
        //unfolding ["POINTonE1_invariant"];
        //simplify (addsimps fp_rep_thms (cryptol_ss ()));
        //w4;
      });
  });
