/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Here we prove that the function isogeny_map_to_E1 satisfies its
// specification. The main difficulty is that the implementation rearranges the
// computation in order to avoid divisions, and SAW cannot reason automatically
// about (simple) algebraic rearrangements involving division. Instead, we have
// to manually rewrite the terms.

// Link to the specification:
// https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-09#appendix-C.2

// Imports

include "helpers.saw";
include "list_utils.saw";
include "types.saw";

m <- llvm_load_module "../build/llvm/libblst.a.bc";
let do_prove = false;

include "proof-helpers.saw";
include "hash_to_field.saw";
include "fp_overrides.saw";
include "vect.saw";
include "curve_operations.saw";
include "ec_mult.saw";

let simp_then_admit r = admit_cryptol (rewrite (cryptol_ss ()) r);

import "../spec/HashToCurveE1Aux.cry";
import "../spec/implementation/CurveOperation.cry";
import "../spec/implementation/HashToG1.cry";
import "../spec/ShortWeierstrassCurve.cry";
import "../spec/FieldExtras.cry";

// Specs

// A Cryptol spec that follows the implementation closely:
let {{
  iso_map_impl: ProjectivePoint t_Fp -> ProjectivePoint t_Fp
  iso_map_impl (X, Y, Z) = to_jacobian xn xd yn yd where
    zzs = Zz_powers Z
    xn = map_fp (kzzs#[last k1s]) X where
      kzzs = map_fp_times_Zz`{n=11} k1s zzs
    xd = Fp.mul (xs, last zzs) where
      xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) X
      xkzz9 = Fp.add (X, last kzzs)
      kzzs = map_fp_times_Zz`{n=10} k2s zzs
    yn = Fp.mul (map_fp (kzzs#[last k3s]) X, Y) where
      kzzs = map_fp_times_Zz`{n=15} k3s zzs
    yd = Fp.mul (Fp.mul (xs, Z), last zzs) where
      xs = map_fp ((take`{front=14}kzzs)#[xkzz14]) X
      xkzz14 = Fp.add (X, last kzzs)
      kzzs = map_fp_times_Zz`{n=15} k4s zzs

  Zz_powers : t_Fp -> [15]t_Fp // powers of ZZ in descending order
  Zz_powers Z = reverse (take`{front=15} zzs) where
      zzs = [Fp.sq Z, Fp.sq (Fp.sq Z)]
        # (join`{parts=inf} [[Fp.mul (zi0, zi1), Fp.sq zi1] | zi0 <- zzs | zi1 <- tail zzs]) // TODO: why is parts=inf necessary here?

  map_fp_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp -> [m2]t_Fp -> [n]t_Fp
  map_fp_times_Zz ks zzs = zipWith (curry Fp.mul) (take`{front=n}ks) (drop`{back=n}zzs)

  map_fp kzzs x = last rs where
    rs = [last kzzs] # [Fp.add (Fp.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]
}};

let blst_isogeny_map_to_E1_impl_spec = do {
  out_ptr <- llvm_alloc POINTonE1_type;
  (p, p_ptr) <- ptr_to_fresh_readonly "p" POINTonE1_type;
  llvm_precond {{ POINTonE1_invariant p }};
  //llvm_precond {{ ~ (is_point_O E (POINTonE1_abs' p)) }}; // p must not be the point at infinity
  llvm_execute_func [out_ptr, p_ptr];
  new_out <- llvm_fresh_var "new_blst_isogeny_map_to_E1_out" POINTonE1_type;
  llvm_points_to out_ptr (llvm_term new_out);
  llvm_postcond {{ POINTonE1_abs new_out == iso_map_impl (POINTonE1_abs p) }};
};

// Proofs

enable_experimental;

// First we prove that the C code implements a low-level Cryptol specification:
iso_map_impl_ov <- really_custom_verify "isogeny_map_to_E1"
  fp_overrides
  blst_isogeny_map_to_E1_impl_spec
  (goal_num_ite 176 // 176 is the main safety goal
    (do {
      unfolding ["POINTonE1_abs", "iso_map"];
      simplify (addsimps fp_rep_thms (cryptol_ss ())); // eliminate `abs . rep`
      w4;
    })
    (do { // discharge simulation side-conditions:
        unfolding ["POINTonE1_invariant"];
        simplify (addsimps fp_rep_thms (cryptol_ss ()));
        w4;
    })
  );

// Now we prove that `affinify E (iso_map_impl p) == if ~(is_zero Fp p.2) then iso_map (affinify E p) else (0,0,0)`

// NOTE we have to make an exception for the `point_O` case, as implementation and specification do not agree:
really_custom_prove_cryptol {{ iso_map_impl (0,0,0) == (0,0,0) }} w4;
really_custom_prove_cryptol {{ iso_map (0,0) != (0,0) }} w4;

// some rewrites for printing things readably:

let {{
  fp_mul = Fp.mul
  fp_sq = Fp.sq
  fp_add = Fp.add
  fp_exp : t_Fp -> Integer -> t_Fp
  fp_exp = undefined
  fp_div = Fp.div
  fp_zero = Fp.field_zero
  fp_unit = Fp.field_unit
  fp_is_equal = Fp.is_equal
}};

readability_rewrites <- for [
  {{ \p q -> Fp.mul (p,q) == fp_mul (p,q) }}
, {{ \p q -> Fp.add (p,q) == fp_add (p,q) }}
, {{ \p -> Fp.sq p == fp_sq p }}
, {{ \p q -> Fp.div (p, q) == fp_div (p, q) }}
, {{ Fp.field_zero == fp_zero }}
, {{ Fp.field_unit == fp_unit }}
, {{ \x y -> Fp.is_equal (x,y) == fp_is_equal (x,y) }}
  ] simp_then_admit;

let print_readably =  do {
    simplify (addsimps readability_rewrites empty_ss);
    print_goal;
}; // NOTE this modifies the goal

// We will need to prove that some expression involving field Fp operations are
// equivalent.  To do so, we will try to rewrite them to a normal form with the
// following rules. The problem is that we cannot use commutativity or
// associativity, which would make the rewriter loop....

zero_unit_rewrites <- for [ // TODO: here we are cheating: this is true only if we use the (Z p) type
    {{ \p -> Fp.add (Fp.field_zero, p) == p }}
  , {{ \p -> Fp.add (p, Fp.field_zero) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_unit) == p }}
  , {{ \p -> Fp.mul (Fp.field_unit, p) == p }}
  , {{ \p -> Fp.mul (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.mul (Fp.field_zero, p) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_zero) == Fp.field_zero }}
  , {{ \p -> Fp.div (p, Fp.field_unit) == Fp.field_unit }}
  , {{ \p -> Fp.div (Fp.field_zero, p) == Fp.field_zero }}
] simp_then_admit;

// NOTE: those rules should be sound since we have `Fp.div (x,0) == 0`
push_div_out_rewrites <- for [
    {{ \x y a b -> Fp.mul (Fp.div (x,y), Fp.div (a,b)) == Fp.div (Fp.mul (x,a), Fp.mul (y,b)) }}
  , {{ \x y z -> Fp.mul (Fp.div (x,y), z) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.mul (z, Fp.div (x,y)) == Fp.div (Fp.mul (x,z), y) }}
  , {{ \x y z -> Fp.div (Fp.div (z, x), y) == Fp.div (z, Fp.mul (x,y)) }}
] simp_then_admit;

sum_of_prods_rewrites <- for [
  {{ \a b c -> Fp.mul (Fp.add (a, b), c) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
  , {{ \a b c -> Fp.mul (c, Fp.add (a, b)) == Fp.add (Fp.mul (a,c), Fp.mul (b,c)) }}
] simp_then_admit;

unsquare_rewrite <- simp_then_admit {{ \a -> Fp.sq a == Fp.mul (a,a) }};

left_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (x, Fp.mul (y,z)) == Fp.mul (Fp.mul (x, y),z) }};

// this one is not included in algebra_simpset below:
right_fold_mul <- simp_then_admit {{ \x y z -> Fp.mul (Fp.mul (x, y),z) == Fp.mul (x, Fp.mul (y,z)) }};

simp_div_rewrites <- for [
    {{ \x y -> Fp.div (Fp.mul (y,x), x) == y }}
  , {{ \x y z -> Fp.div (Fp.mul (y,x), Fp.mul(z,x)) == Fp.div (y,z) }}
  , {{ \x y z -> Fp.div (Fp.mul (x,y), Fp.mul(x,z)) == Fp.div (y,z) }}
] simp_then_admit;

let algebra_simpset = addsimps (concat_all [zero_unit_rewrites, [unsquare_rewrite], [left_fold_mul], sum_of_prods_rewrites, push_div_out_rewrites, simp_div_rewrites]) empty_ss;

// an auxiliary definition that will be useful:
let {{
  powers x = ps where
    ps = [Fp.field_unit] # [Fp.mul(x, pi) | pi <- ps]
  zz11 z = (powers (Fp.sq z))@11
  zz15 z = (powers (Fp.sq z))@15
}};

// we will first rewrite iso_map to get rid of div terms
// first we multiply x_num and x_den by zz11, and y_num and y_den by zz15
let {{
  iso_map_2 (x', y', z') = (x, y) where
    (X,Y) = affinify E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
}};

rewrite_1 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map (affinify E p) == iso_map_2 p }})
  (do {
    unfolding ["iso_map_2"];
    simplify (addsimps (concat_all [zero_unit_rewrites, simp_div_rewrites]) empty_ss);
    w4_unint_z3 fp_unints;
  });

// now we use the fact that Y = y'/z'^3
let {{
  iso_map_3 (x', y', z') = (x, y) where
    (X,Y) = affinify E (x', y', z')
    x_powers = powers X
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- x_powers]
    x_den = Fp.add (x_powers@10, F_sum Fp [Fp.mul(ki, xi) | ki <- k2s | xi <- x_powers])
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- x_powers]
    y_den = Fp.add (x_powers@15, F_sum Fp [Fp.mul(ki, xi) | ki <- k4s | xi <- x_powers])
    x = Fp.div (Fp.mul (x_num, zz11 z'), Fp.mul (x_den, zz11 z'))
    y = Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')))
}};

// we are going to rewrite y with this rule:
aux_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \y_num y_den x' y' z' -> (Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z'))) == if ~(is_zero Fp z') then Fp.div (Fp.mul (y', Fp.mul (y_num, zz15 z')), Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z'))) else apply Fp.mul (Y, Fp.div (Fp.mul (y_num, zz15 z'), Fp.mul (y_den, zz15 z')))
  where (_,Y) = affinify E (x', y', z'))
}}) // NOTE: this holds unconditionally, but rewriting it to get to that will be tedious and not useful since at the end we assume that z' is non-zero
 (do {
    let hoist_ifs_rewrites = run (for [
          {{ \x a b c -> Fp.mul(if a then b else c, x) == if a then Fp.mul (b,x) else Fp.mul (c,x) }}
        , {{ \x a b c -> Fp.mul(x, if a then b else c) == if a then Fp.mul (x,b) else Fp.mul (x,c) }}
        , {{ \a (b:(Integer,Integer)) (c:(Integer,Integer))-> (if a then b else c).1 == if a then b.1 else c.1 }}
      ] (\ x -> really_custom_prove_cryptol (rewrite (cryptol_ss()) x) w4));
    unfolding ["affinify","E","apply"];
    simplify (addsimps hoist_ifs_rewrites algebra_simpset);
    simplify algebra_simpset;
    w4_unint_z3 fp_unints;
 });

rewrite_2 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \p -> iso_map_2 p == if ~(is_zero Fp p.2) then iso_map_3 p else apply iso_map_2 p }})
  (do {
    unfolding ["iso_map_2","apply"];
    simplify (addsimp aux_rewrite empty_ss);
    w4_unint_z3 fp_unints;
  });

// now we rewrite x_num, x_den, y_num, and y_den independently:

// Rewrite rule for x_num

let {{
  x_num_times_zz11 x' z' = Fp.mul (x_num, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k1s | xi <- (powers X)]
  // here we don't want any divisions:
  x_num_times_zz11_nodiv x' z' = x_num where
    x'_powers = take`{front=12}(powers x')
    zz'_powers = take`{front=12}(powers zz')
    zz' = Fp.sq z'
    x_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k1s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_x_num_times_zz11 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_num_times_zz11_nodiv x z == x_num_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","x_num_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// Now let's prove that the nodiv term is equivalent to the implementation term. Since there are no divisions left, Z3 is able to handle the proof obligations (or is it rewriting in What4?)

let {{
  x_num_times_zz11_impl x' z' = xn where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k1s]) x' where // k0 to k11
      kzzs = map_fp_times_Zz`{n=11} k1s zzs // k0 to k10
}};

x_num_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_num_times_zz11_impl"] {{ \x z -> x_num_times_zz11_impl x z == x_num_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// rewrite rule for x_den

let {{
  x_den_times_zz11 x' z' = Fp.mul (x_den, zz11 z') where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    x_den = F.add ((powers X)@10, F_sum F [F.mul(ki, xi) | ki <- k2s | xi <- (powers X)])
  // here we don't want any divisions:
  x_den_times_zz11_nodiv x' z' = x_den where
    x'_powers = take`{front=11}(powers x')
    zz'_powers = tail (take`{front=12}(powers zz'))
    zz' = Fp.sq z'
    x_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k2s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

really_custom_prove_cryptol {{ \(x:[8]) (z:[8]) -> x_den_times_zz11 (toInteger x) (toInteger z) == x_den_times_zz11_nodiv (toInteger x) (toInteger z) }} (quickcheck 20);

elim_div_rewrite_x_den_times_zz11 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> x_den_times_zz11_nodiv x z == x_den_times_zz11 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k2s","x_den_times_zz11_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  x_den_times_zz11_impl x' z' = xd where
    zzs = Zz_powers z'
    xd = Fp.mul (xs, last zzs)
    xs = map_fp ((take`{front=9}kzzs)#[xkzz9]) x'
    xkzz9 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=10} k2s zzs
}};

x_den_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["x_den_times_zz11_impl"] {{ \x z -> x_den_times_zz11_impl x z == x_den_times_zz11_nodiv x z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k1s"]);
    w4;
  });

// rewrite rule for y_num

let {{
  y_num_times_zz15 x' y' z' = Fp.mul (y', Fp.mul (y_num, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_num = F_sum Fp [Fp.mul(ki, xi) | ki <- k3s | xi <- (powers X)]
  // here we don't want any divisions:
  y_num_times_zz15_nodiv x' y' z' = Fp.mul (y_num, y') where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_num = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- k3s | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

elim_div_rewrite_y_num_times_zz15 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x y z -> y_num_times_zz15_nodiv x y z == y_num_times_zz15 x y z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k1s","y_num_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

let {{
  y_num_times_zz15_impl x' y' z' = Fp.mul (xn, y') where
    zzs = Zz_powers z'
    xn = map_fp (kzzs#[last k3s]) x' where
      kzzs = map_fp_times_Zz`{n=15} k3s zzs
}};

y_num_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_num_times_zz15_impl"] {{ \x y z -> y_num_times_zz15_impl x y z == y_num_times_zz15_nodiv x y z }}))
  (do {
    goal_eval_unint (concat fp_unints ["k3s"]);
    w4;
  });

// rewrite rule for y_den

let {{
  y_den_times_zz15 x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  Fp.mul (y_den, zz15 z')) where
    X = Fp.mul(lambda2, x') where
      lambda2 = Fp.sq lambda
      lambda = Fp.div (Fp.field_unit, z')
    y_den = F.add ((powers X)@15, F_sum F [F.mul(ki, xi) | ki <- k4s | xi <- (powers X)])
  // here we don't want any divisions:
  y_den_times_zz15_nodiv x' z' = Fp.mul (Fp.mul (Fp.sq z', z'),  y_den) where
    x'_powers = take`{front=16}(powers x')
    zz'_powers = take`{front=16}(powers zz')
    zz' = Fp.sq z'
    y_den = F_sum Fp [Fp.mul(Fp.mul(ki, xi), zzi) | ki <- (k4s#[Fp.field_unit]) | xi <- x'_powers | zzi <- reverse (zz'_powers)]
}};

really_custom_prove_cryptol {{ \(x:[8]) (z:[8]) -> y_den_times_zz15 (toInteger x) (toInteger z) == y_den_times_zz15_nodiv (toInteger x) (toInteger z) }} (quickcheck 20);

elim_div_rewrite_y_den_times_zz15 <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{ \x z -> y_den_times_zz15_nodiv x z == y_den_times_zz15 x z }})
  (do { // we must get rid of the divisions by rewriting
    goal_eval_unint (concat fp_unints ["k4s","y_den_times_zz15_nodiv"]);
    simplify algebra_simpset;
    w4;
  });

// now let's prove that the nodiv term is equivalent to the implementation term:

let {{
  y_den_times_zz15_impl x' z' = Fp.mul (Fp.mul (xs, z'), last zzs) where
    zzs = Zz_powers z'
    xs = map_fp ((take`{front=14}kzzs)#[ykzz14]) x'
    ykzz14 = Fp.add (x', last kzzs)
    kzzs = map_fp_times_Zz`{n=15} k4s zzs
}};

y_den_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) (unfold_term ["y_den_times_zz15_impl"] {{ \x z -> y_den_times_zz15_impl x z == y_den_times_zz15_nodiv x z }}))
  (do {
    unfolding ["y_den_times_zz15_nodiv"];
    goal_eval_unint (concat fp_unints ["k4s"]);
    w4;
  });

// we are also going to use this:
to_jacobian_rewrite <- really_custom_prove_cryptol (rewrite (cryptol_ss ())
  {{
    \xn xd yn yd -> affinify E (to_jacobian xn xd yn yd) == if ~(is_zero Fp (Fp.mul (xd,yd))) then (F.div (xn, xd), F.div(yn, yd)) else apply affinify E (to_jacobian xn xd yn yd)
  }})
  (do {
    unfolding ["to_jacobian", "affinify", "F", "E"];
    simplify algebra_simpset;
    simplify (addsimp right_fold_mul empty_ss);
    simplify (addsimps simp_div_rewrites empty_ss);
    w4_unint_z3 fp_unints;
  });

// For now we assume this property. TODO: is there something better to do?
// It is a property of the isogeny map: it never maps a non-zero point to zero
x_den_times_y_den_nz <- simp_then_admit {{
  \(p:(Integer,Integer,Integer)) -> is_zero Fp (Fp.mul (x_den_times_zz11 p.0 p.2, y_den_times_zz15 p.0 p.2)) == if ~(is_zero Fp p.2) then False else apply is_zero Fp (Fp.mul (x_den_times_zz11 p.0 p.2, y_den_times_zz15 p.0 p.2))
}};

iso_map_abs_thm <- really_custom_prove_cryptol (rewrite (cryptol_ss ()) {{
  \p -> affinify E (iso_map_impl p) == if ~(is_zero Fp p.2) then iso_map (affinify E p) else apply affinify E (iso_map_impl p) }})
  (do {
    unfolding ["apply"]; // NOTE: we need to get rid of apply, otherwise further rewrites apply to one side and not the other.
    simplify (addsimps [rewrite_1, rewrite_2] empty_ss);
    unfolding ["iso_map_impl"];
    simplify (cryptol_ss ());
    simplify (addsimps [x_num_rewrite, elim_div_rewrite_x_num_times_zz11, x_den_rewrite, elim_div_rewrite_x_den_times_zz11, y_num_rewrite, elim_div_rewrite_y_num_times_zz15, y_den_rewrite, elim_div_rewrite_y_den_times_zz15] empty_ss);
    simplify (cryptol_ss ());
    simplify (addsimp to_jacobian_rewrite empty_ss);
    unfolding ["F"];
    simplify (addsimp x_den_times_y_den_nz empty_ss);
    w4_unint_z3 fp_unints;
  });

// TODO: why do we need this?
is_zero_rewrite <- really_custom_prove_cryptol {{ \p -> is_zero Fp (p.2) == if ~(is_point_O E (affinify E p)) then False else  apply is_zero Fp (p.2) }}
  do {
    // unfortunately, there is no way to unfold those without unfolding Fp completely:
    let temp_rewrites = run (for [
          {{ \x y -> Fp.is_equal (x, y) == (x==y) }}
        , {{ Fp.field_zero == 0 }}
      ] (\ x -> really_custom_prove_cryptol x w4));
    unfolding ["apply"];
    unfolding ["affinify", "is_zero", "point_O", "is_point_O", "same_point_affine", "E"];
    simplify (addsimps temp_rewrites (cryptol_ss ()));
    w4_unint_z3 fp_unints;
  };
