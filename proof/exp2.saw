/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import "../spec/implementation/Types.cry";
import "../spec/Parameters.cry";
import "../spec/FieldExtras.cry";
import "../spec/BLSFieldExtras.cry";

// Temporary home; these belong in fp_overrides
fp2_alg_thms <- for
  [ {{ \ x y z -> Fp_2.mul (Fp_2.mul (x, y), z) == Fp_2.mul (x, Fp_2.mul (y, z)) }} // mul associates
  , {{ \x -> Fp_2.mul (x, Fp_2.field_zero) == Fp_2.field_zero }} // x*0 = 0
  , {{ \x -> Fp_2.mul (Fp_2.field_zero, x) == Fp_2.field_zero }} // 0*x = 0
  , {{ \x -> Fp_2.mul (x, Fp_2.field_unit) == Fp_2.normalize x }} // x*1 = x ish
  // , {{ \x -> Fp_2.mul (x, Fp_2.field_unit) == x }} // x*1 = x TODO: OK in the `Z p` model
  , {{ \x -> Fp_2.mul (Fp_2.field_unit, x) == Fp_2.normalize x }} // 1*x = x ish
  // , {{ \x -> Fp_2.mul (Fp_2.field_unit, x) == x }} // 1*x = x TODO

  , {{ \x -> Fp_2.sq x == Fp_2.mul (x,x) }} // eliminate squaring.  Not always a good idea

  , {{ \ x y z -> Fp_2.add (Fp_2.add (x, y), z) == Fp_2.add (x, Fp_2.add (y, z)) }} // add associates
  , {{ \x -> Fp_2.add (x, Fp_2.field_zero) == Fp_2.normalize x }} // x+0 = x ish
  , {{ \x -> Fp_2.add (Fp_2.field_zero, x) == Fp_2.normalize x }}//  0+x = x ish

  , {{ \ x y -> Fp_2.sub (x, y) == Fp_2.add (x, Fp_2.neg y) }} // eliminate sub in favour of neg

  , {{ \ x -> Fp_2.neg (Fp_2.neg x) == Fp_2.normalize x }} // double negative
  , {{ \ x y -> Fp_2.neg (Fp_2.add (x, y)) == Fp_2.add (Fp_2.neg x, Fp_2.neg y) }} // push neg inside a sum
  , {{ Fp_2.neg Fp_2.field_zero == Fp_2.field_zero }} // -0 = 0
  ] (\ t -> prove_cryptol t []);

// alternative definition for fp2_invariant, avoiding `all` and thus also `foldr'` and `map`:
fp2_invariant_alt_thm <-
  prove_cryptol
  {{ \x -> fp2_invariant x == (fp_invariant (x@0) /\ fp_invariant (x@1)) }}
  ["fp_invariant"];

fp2_invariant_alt_seq_thm <-
  prove_cryptol
  {{ \x y -> fp2_invariant [x,y] == (fp_invariant x /\ fp_invariant y) }}
  ["fp_invariant"];

// Proof development:

let print_goal_nicely = do {
    unfolding ["Fp", "prime_field_integer", "prime_field", "\\/", "/\\", "==>"];
    unfolding ["Fp_2", "extension_field"];
//    simplify (add_prelude_eqs
//               [ "ite_true", "ite_false", "ite_eq" , "not_True", "not_False", "not_not"
//               , "and_True1", "and_True2", "and_False1", "and_False2", "and_idem"
//               , "or_True1", "or_True2", "or_False1", "or_False2", "or_idem"]
//             (cryptol_ss()));
     // beta_reduce_goal;
     simplify (cryptol_ss());
     print_goal;
     };
    
////////////////////////////////////////////////////////////////////////////////
// Specifications
////////////////////////////////////////////////////////////////////////////////

// reciprocal_fp2
/*
let reciprocal_fp2_spec = do {
  out_ptr <- crucible_alloc vec384x_type;
  (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384x_type;
  crucible_precond {{ fp2_invariant inp }};
  crucible_execute_func [out_ptr, inp_ptr];
  crucible_points_to out_ptr (crucible_term {{ fp2_rep (inverse_fp2 (fp2_abs inp)) }});
  };
*/

let fp2_unop_spec name op = unop_spec name vec384x_type {{fp2_invariant}} {{fp2_rep}} {{fp2_abs}} op;

let reciprocal_fp2_spec = fp2_unop_spec "reciprocal_fp2" {{ inverse_fp2 }};

// recip_sqrt_fp2_9mod16 is computed using an addition chain.
// We can use rewriting to show that it computes the correct power.

// We then assume as axioms that these powers compute the appropriate functions.

// We can use algebraic rules relating multiplication to exponentiation to show that these chains
// computes the correct values.

// fp2_exp is for positive exponents only, avoiding the need for rewriting x*1 to x
let {{ fp2_exp: t_Fp_2 -> Integer -> t_Fp_2
       fp2_exp x e = if e == 1 then x else Fp_2.mul (x, fp2_exp x (e-1))
       }};

fp2_mult_exp_thm_1 <- prove_cryptol {{\x -> Fp_2.mul (x, x) == fp2_exp x 2 }} [] ;
fp2_mult_exp_thm_2 <- admit_cryptol {{ \x k -> Fp_2.mul (x, fp2_exp x k) == fp2_exp x (k+1) }};
fp2_mult_exp_thm_3 <- admit_cryptol {{ \x k -> Fp_2.mul (fp2_exp x k, x) == fp2_exp x (k+1) }};
fp2_mult_exp_thm_4 <- admit_cryptol {{ \x n k -> Fp_2.mul (fp2_exp x n, fp2_exp x k) == fp2_exp x (k+n) }};
fp2_mult_exp_thm_5 <- admit_cryptol {{ \x n k -> fp2_exp (fp2_exp x n) k == fp2_exp x (k*n) }};
fp2_mult_exp_thm_6 <- admit_cryptol {{ \n -> fp2_exp Fp_2.field_unit n == Fp_2.field_unit }};

fp2_exp_simps <- addsimps (concat [fp2_mult_exp_thm_1, fp2_mult_exp_thm_2, fp2_mult_exp_thm_3
                                  , fp2_mult_exp_thm_4, fp2_mult_exp_thm_5, fp2_mult_exp_thm_6]
                                  fp2_alg_thms)
                           fp2_simpset;

fp2_mul_unit_exp_thm <- admit_cryptol
  {{ \ x e -> Fp_2.mul (Fp_2.field_unit, fp2_exp x e)
              == if e > 1 then fp2_exp x e else apply Fp_2.mul (Fp_2.field_unit, fp2_exp x e) }} ;
              

// sqr_n_mul_fp2

// Assumed overrides

let {{
  sqr_n_mul_fp2: t_Fp_2 -> Size_t -> t_Fp_2 -> t_Fp_2
  sqr_n_mul_fp2 x count y = Fp_2.mul (fp2_exp x (2^^count), y)
  }};

let sqr_n_mul_fp2_spec = do {
  out_ptr <- crucible_alloc vec384x_type;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  count <- crucible_fresh_var "count" size_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
  crucible_precond {{ count > 0 }};
  crucible_execute_func [out_ptr, a_ptr, crucible_term count, b_ptr];
  crucible_points_to out_ptr (crucible_term {{ fp2_rep (sqr_n_mul_fp2 (fp2_abs a) count (fp2_abs b)) }});
  };

let sqr_n_mul_fp2_alias_1_2_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
  count <- crucible_fresh_var "count" size_type;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
  crucible_precond {{ count > 0 }};
  crucible_execute_func [a_ptr, a_ptr, crucible_term count, b_ptr];
  crucible_points_to a_ptr (crucible_term {{ fp2_rep (sqr_n_mul_fp2 (fp2_abs a) count (fp2_abs b)) }});
  };

let recip_sqrt_fp2_9mod16_spec = fp2_unop_spec "recip_sqrt_fp2_9mod16" {{ \ x ->  fp2_exp x ((`p^^2-9)/16) }};

// ... recip_sqrt_fp2 deviates from the algorithm in Appendix G.3; instead of squaring each of the
// candidates for square root, it uses some algebraically equivalent operations.  That is,
// given a candidate `s` or square root, it is supposed to test s^2, (c1*s)^2, (c2*s)^2, and (c3*s)^2
// to see which (if any) gives the correct result.  The code uses these rules:
//  if s^2 = b*u + a, then, as c1 = u
//   (c1*s)^2 = c1^2 * s^2 = - (s^2)
//   (c2*s)^2 = c2^2 * s*2 = c1 * (s^2) =a*u - b
//   (c3*s)^2 = -c1 * s = -a*u + b
// ... avoiding the need for any more multiplications after the first squaring, and then
// at the end multiplying `s` by the appropriate number.

// Note for (c1*s)^2 == c1^2 * s^2 we need to permute a multiplication
// Algebraic law:
square_product_thm <- admit_cryptol
  {{ \ x y -> Fp_2.sq (Fp_2.mul (x, y)) == Fp_2.mul (Fp_2.sq x, Fp_2.sq y) }};

sqrt_align_fp2_thms <- for
 [ {{ \x y -> Fp_2.mul ([x, y], Fp_2.sq u) ==  [Fp.neg x, Fp.neg y] }}
 , {{ \ x y -> Fp_2.mul (Fp_2.sq sqrt_fp2_c2, [x, y]) == [Fp.normalize y, Fp.neg x] }}
 , {{ \ x y -> Fp_2.mul (Fp_2.sq sqrt_fp2_c3, [x, y]) == [Fp.neg y, Fp.normalize x] }}
 ]
 ( \ t -> prove_cryptol t [] );

// maybe easier to match variants
sqrt_align_fp2_thms' <- for
 [ {{ \ x -> Fp_2.mul (Fp_2.sq u,           x) ==  [Fp.neg (x@0), Fp.neg (x@1)] }}
 , {{ \ x -> Fp_2.mul (Fp_2.sq sqrt_fp2_c2, x) == [Fp.normalize (x@1), Fp.neg (x@0)] }}
 , {{ \ x -> Fp_2.mul (Fp_2.sq sqrt_fp2_c3, x) == [Fp.neg (x@1), Fp.normalize (x@0)] }}
 ]
 ( \ t -> prove_cryptol t [] );

 
// For the proof, we need some unfolding of definitions to check:
//  sqrt_minus_1 = fp2_rep c1 (from the definition of BLSFieldExtras::sqrt_fp2)
//  sqrt_sqrt_minus_1 =  fp2_rep c2 
//  sqrt_minus_sqrt_minus_1 = fp_rep c3
// ... or perhaps `fp2_abs sqrt_minus_1 == c1` and so on, and we also need
//  `fp2_invariant sqrt_minus_1` and so on.

// These machinations are done in function `sqrt_align_fp2`, called from two places, so we will give it its own
// specification and override.

let {{
  sqrt_align_fp2_coeff: t_Fp_2 -> t_Fp_2 -> t_Fp_2
  sqrt_align_fp2_coeff s inp =
    if Fp_2.sq (Fp_2.mul(sqrt_fp2_c3, s)) == inp then sqrt_fp2_c3
     | Fp_2.sq (Fp_2.mul(sqrt_fp2_c2, s)) == inp then sqrt_fp2_c2
     | Fp_2.sq (Fp_2.mul(          u, s)) == inp then u
    else Fp_2.field_unit
    }};

/*
prove z3 {{ \x y ->  Fp.is_val x ==> Fp.is_val y ==> Fp_2.mul (u, [x, y]) ==  [y, Fp.neg x] }};
prove z3 {{ \x y ->  Fp.is_val x ==> Fp.is_val y ==> Fp_2.mul ([x, y], u) ==  [y, Fp.neg x] }};
prove z3 {{ \x y ->  Fp.is_val x ==> Fp.is_val y ==> Fp_2.mul ([x, y], Fp_2.neg u) ==  [Fp.neg y, x] }}
prove z3 {{ Fp_2.sq sqrt_fp2_c2 == u }};
prove z3 {{ Fp_2.sq sqrt_fp2_c3 == Fp_2.neg u }};

*/

// .. and an equivalent version closer to the code
let {{
  sqrt_align_fp2_coeff': t_Fp_2 -> t_Fp_2 -> t_Fp_2
  sqrt_align_fp2_coeff' s inp =
      if [Fp.neg y, Fp.normalize x] == inp then sqrt_fp2_c3
       | [Fp.normalize y, Fp.neg x] == inp then sqrt_fp2_c2
       | [Fp.neg x, Fp.neg y] == inp then u
      else Fp_2.field_unit
    where [x,y] = Fp_2.sq s
    }};

sqrt_align_fp2_coeff_equiv_thm <- custom_prove_cryptol
  {{ \s inp -> sqrt_align_fp2_coeff s inp == sqrt_align_fp2_coeff' s inp }}
  do { unfolding ["sqrt_align_fp2_coeff", "sqrt_align_fp2_coeff'"];
       simplify (addsimps (concat [square_product_thm] sqrt_align_fp2_thms') (cryptol_ss()));
       // print_goal_nicely;
       w4_unint_z3 fp_unints;
       };
        



fp_inv_fp2_rep_thms <- for [0,1]
  (\ i -> custom_prove_cryptol (rewrite (cryptol_ss()) {{ \ x -> fp_invariant ((fp2_rep x) @ (`i:[1])) == True }})
            do {unfolding ["fp2_rep"];
                simplify fp_simpset;
                w4_unint_z3 fp_unints; } );

let sqrt_align_fp2_spec_for_extract = do {
  out_ptr <- crucible_alloc vec384x_type;
  (ret, ret_ptr) <- ptr_to_fresh_readonly "ret" vec384x_type;
  (sqrt, sqrt_ptr) <- ptr_to_fresh_readonly "sqrt" vec384x_type;
  (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384x_type;
  crucible_precond {{ fp2_invariant inp }};
  crucible_precond {{ fp2_invariant sqrt }};
  crucible_precond {{ fp2_invariant ret }};
  crucible_execute_func [out_ptr, ret_ptr, sqrt_ptr, inp_ptr];
  //crucible_points_to out_ptr (crucible_term
  //    {{ fp2_rep (Fp_2.mul(fp2_abs ret, sqrt_align_fp2_coeff (fp2_abs sqrt) (fp2_abs inp))) }});
  //crucible_return (crucible_term {{ Fp_2.sq (Fp_2.mul(sqrt, sqrt_align_fp2_coeff sqrt inp)) == fp2_abs inp }};
  out <- crucible_fresh_var "out" vec384x_type;
  crucible_points_to out_ptr (crucible_term out);
  };

enable_experimental;
/*
crucible_llvm_compositional_extract m
 "sqrt_align_fp2"
 "foo"
 (foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides] [])
 false
 sqrt_align_fp2_spec_for_extract
 do { unfolding ["fp2_invariant"]; // unfold to get preconditions for the fp functions
      simplify (addsimps fp_inv_fp2_rep_thms (cryptol_ss()));
      goal_eval_unint fp_unints;
      w4_unint_z3 fp2_unints; } ;
      // w4_unint_z3 fp_unints; } ;
*/
/*
crucible_llvm_compositional_extract m
 "sqrt_align_fp2"
 "foo"
 (foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides] [])
 false
 sqrt_align_fp2_spec_for_extract
 do { unfolding ["fp2_invariant"]; // unfold to get preconditions for the fp functions
      simplify (addsimps fp_inv_fp2_rep_thms (cryptol_ss()));
      print_goal_nicely;
      z3;
      }
*/

let sqrt_align_fp2_spec = do {
  out_ptr <- crucible_alloc vec384x_type;
  (ret, ret_ptr) <- ptr_to_fresh_readonly "ret" vec384x_type;
  (sqrt, sqrt_ptr) <- ptr_to_fresh_readonly "sqrt" vec384x_type;
  (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384x_type;
  crucible_precond {{ fp2_invariant inp }};
  crucible_precond {{ fp2_invariant sqrt }};
  crucible_precond {{ fp2_invariant ret }};
  crucible_execute_func [out_ptr, ret_ptr, sqrt_ptr, inp_ptr];
  crucible_points_to out_ptr (crucible_term
      {{ fp2_rep (Fp_2.mul(fp2_abs ret, sqrt_align_fp2_coeff (fp2_abs sqrt) (fp2_abs inp))) }});
  crucible_return (crucible_term
      {{ bool_to_limb (Fp_2.sq (Fp_2.mul(fp2_abs sqrt, sqrt_align_fp2_coeff (fp2_abs sqrt) (fp2_abs inp)))
                        == fp2_abs inp) }});
  };

let sqrt_align_fp2_alias_2_3_spec = do { // for the call in sqrt_fp2
  out_ptr <- crucible_alloc vec384x_type;
  (ret, ret_ptr) <- ptr_to_fresh_readonly "ret" vec384x_type;
  (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384x_type;
  crucible_precond {{ fp2_invariant inp }};
  crucible_precond {{ fp2_invariant ret }};
  crucible_execute_func [out_ptr, ret_ptr, ret_ptr, inp_ptr];
  crucible_points_to out_ptr (crucible_term
      {{ fp2_rep (Fp_2.mul( sqrt_align_fp2_coeff (fp2_abs ret) (fp2_abs inp)
                          , fp2_abs ret)) }});
  crucible_return (crucible_term
      {{ bool_to_limb (Fp_2.sq (Fp_2.mul( sqrt_align_fp2_coeff (fp2_abs ret) (fp2_abs inp)
                                        , fp2_abs ret))
                        == fp2_abs inp) }});
  };

// TODO
/*
sqrt_align_fp2_ov <- custom_verify "sqrt_align_fp2"
  (foldr concat [vec_fp2_overrides, fp2_overrides, fp_overrides] [])
  sqrt_align_fp2_spec
  do { simplify (addsimp sqrt_align_fp2_coeff_equiv_thm  empty_ss);
       simplify fp2_simpset;
       //unfolding ["fp2_invariant"]; // unfold to get preconditions for the fp functions
       simplify (addsimp fp2_invariant_alt_seq_thm fp2_simpset);
       simplify (addsimps fp_inv_fp2_rep_thms (cryptol_ss()));
       print_goal_nicely;
       z3;
       };
*/
//TODO
sqrt_align_fp2_alias_2_3_ov <- admit  "sqrt_align_fp2" sqrt_align_fp2_alias_2_3_spec;


// ... recip_sqrt_fp2

// let recip_sqrt_fp2_spec = fp2_unop_spec "reciprocal_sqrt_fp2" {{ undefined }}; // TODO

// ... sqrt_fp2

let sqrt_fp2_spec = fp2_unop_spec "sqrt_fp2" {{ sqrt_fp2 }};



////////////////////////////////////////////////////////////////////////////////
// Proofs
////////////////////////////////////////////////////////////////////////////////


// Some additional algebraic rules for Fp operations:
// mul_div_fp_thm <- admit_cryptol {{ \x y z -> Fp.mul (x, Fp.div (y,z)) == Fp.div (Fp.mul (x, y), z) }};
// special case
mul_div_fp_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \x z -> Fp.mul (x, Fp.div (Fp.field_unit,z)) == Fp.div (x, z) }});
div_neg_fp_thm <- admit_cryptol {{ \x y  -> Fp.div (Fp.neg x,y) == Fp.neg (Fp.div (x, y)) }};
// commute add once -- use with caution!
add_commutes_fp_thm <- prove_cryptol {{ \x y  -> Fp.add (x, y) == apply Fp.add (y,x) }} [];


reciprocal_fp2_ov <- custom_verify "reciprocal_fp2"
   (concat [reciprocal_fp_ov] fp_overrides)
   (fp2_unop_spec "reciprocal_fp2" {{ inverse_fp2 }})
   do { // commute Fp.add BEFORE we unfold inverse_fp2; this flips the add used in the code
        // but not the add in the definition.  We need to commute one but not the other.
       simplify (addsimp add_commutes_fp_thm empty_ss);
       unfolding ["inverse_fp2", "fp2_rep", "fp2_abs", "fp2_invariant"]; 
       simplify (addsimps [mul_div_fp_thm, div_neg_fp_thm] (addsimps fp_alg_thms fp_simpset));
       w4_unint_z3 fp_unints;
       };

sqr_n_mul_fp2_ov <- admit "sqr_n_mul_fp2" sqr_n_mul_fp2_spec;
sqr_n_mul_fp2_alias_1_2_ov <- admit "sqr_n_mul_fp2" sqr_n_mul_fp2_alias_1_2_spec;

recip_sqrt_fp2_9mod16_ov <- custom_verify "recip_sqrt_fp2_9mod16"
  (concat [sqr_n_mul_fp2_ov, sqr_n_mul_fp2_alias_1_2_ov]
          (concat fp2_overrides vec_fp2_overrides))
  recip_sqrt_fp2_9mod16_spec
  do {
     // simplify (addsimp recip_fp_algebra_thm empty_ss);
     unfolding ["sqr_n_mul_fp2"];
     simplify fp2_exp_simps;
     w4_unint_z3 (concat ["fp2_exp"] fp2_unints);
     };
  
// Note Appendix G.3 says to take power (q+7)/16 as step 1 , one more than recip_sqrt_fp2_9mod16 does

// ... for the proof of sqrt_fp and recip_sqrt_fp we relate fp2_exp and F_expt

// we need to undo goal_eval's rip-and-restitching of vectors.
let fp2_at0 = parse_core "\\ (x:(Vec 2 Integer)) -> at 2 Integer x 0";
let fp2_at1 = parse_core "\\ (x:(Vec 2 Integer)) -> at 2 Integer x 1";

fp2_unrip_thm <- prove_cryptol (rewrite (cryptol_ss ()) {{ \(x:[2]Integer) -> [fp2_at0 x, fp2_at1 x] == x }}) [];

sqrt_fp_power_lemma <- admit_cryptol
  (rewrite (cryptol_ss()) {{ \ x -> F_expt`{n=(width q) - 3} Fp_2 x `((q+7)/16) == fp2_exp x `((q+7)/16) }})
  ;
/*  
// Some proof issues: the base of Fp_2.field_unit introduces fp2_normalize

  do { goal_eval_unint (concat ["fp2_exp"] fp2_unints); // needed to expand F_expt, which uses a comprehension
       simplify (addsimp fp2_unrip_thm fp2_exp_simps);
       print_goal_nicely;
       w4_unint_z3 (concat ["fp2_exp"] fp2_unints);
       };
*/

/* The proof of sqrt_fp2 presents several challenges.

- As described above, the squares of the four candidate roots are computed using some algebraically
  equivalent formulas that are cheaper to evaluate.  We handle this by rewriting the spec
  `sqrt_align_fp2` to `sqrt_align_fp2'`, with a separate proof to show the equivalence of the two forms.

- The equality tests are done strangely, e.g., rather than testing `a^2 == in`, the test is
  `vec_is_zero(sub_fp2(a^2, in))`, rather than `a^2 == neg_fp2 in` the test is
  `vec_is_zero(add_fp2(a^2, in))` and so on.

- In addition, the spec used `Fp_2.is_equal` rather than `==`.  We deal with this via rewrtiting,
  (as in SAW  we cannot just unfold `Fp_2.is_equal`).

- the candidates are tested in a different order in the implementation from the order inthe specification.
  This does not matter, because the candidates are different multiples of some value, if any two are equal
  then the value was 0 and all the multiples are equal.  But is is a bit awkward to prove.
  There are four candidate square roots: r, u*r, c2*r, and c3*r
  The code gives order c3*r, c2*r, u*r, r (i.e., the first in that list that works)
  The specification gives order c2*r, c3*r, u*r, r.

  We handle this by a litle trick.  We have two expressions like
    (*1) `if P1 then c1 else if P2 then c2 else c3`
  and
    (*2) `if P2 then c2 else if P1 then c1 else c3`

  We also know `(P1 /\ P2) ==> c1 == c2`.  So we can rewrite `P1` to the equivalent
    `P1 /\ (P2 ==> c1 == c2')`

  Making that replacement in (*1) and (*2) gives terms that can be proved equal.

*/

// need to lift ite out of FP_2.mul:

// hoist_fp2_mul_thm <- hoist {{ Fp_2.mul }} ["Fp_2"];
hoist_fp2_mul_thm <- prove_cryptol
  (rewrite (cryptol_ss ())
    {{\ c x y z -> Fp_2.mul (if c then x else y, z) ==
                   if c then Fp_2.mul (x, z) else Fp_2.mul (y,z) }})
    ["Fp_2"];             

// `u` is unfolded in some parts automatically!?  So we expand it everywhere else with this rule
u_expander_thm <- prove_cryptol {{ u == [1, 0] }} [];

// we also have some instances of Fp_2.is_equal that need to be replaced with actual equality,

fp2_is_equal_thm <- prove_cryptol {{ \x y -> Fp_2.is_equal (x,y) == (x==y) }} [];

// .. and the rule for dealing with the ordering difference:
sqrt_candidate_comparison_thm <- admit_cryptol
  (rewrite (cryptol_ss ()) {{ \ x y -> (Fp_2.sq (Fp_2.mul (sqrt_fp2_c2, x)) == y) ==
                              ( (apply Fp_2.sq (Fp_2.mul (sqrt_fp2_c2, x)) == y)
                                /\ ((Fp_2.sq (Fp_2.mul (sqrt_fp2_c3, x)) == y)
                                    ==> (Fp_2.mul (sqrt_fp2_c2, x) == Fp_2.mul (sqrt_fp2_c3, x)))) }});


sqrt_candidate_comparison_thm' <- admit_cryptol
  (rewrite (cryptol_ss ())
    {{ \ x y C -> (((if Fp_2.sq A == y then A else if Fp_2.sq B == y then B else C) == 
                     if Fp_2.sq B == y then B else if Fp_2.sq A == y then A else C)
                    where A = Fp_2.mul (sqrt_fp2_c3, x)
                          B = Fp_2.mul (sqrt_fp2_c2, x) ) }} );


sqrt_fp_ov <- really_custom_verify "sqrt_fp2"
  (concat [recip_sqrt_fp2_9mod16_ov, sqrt_align_fp2_alias_2_3_ov] fp2_overrides)
  sqrt_fp2_spec
  do {
  // absorb the multiplication into the exponentiation:
  simplify fp2_exp_simps;
  // open up a bit, and replace `F_expt` with `fp2_exp`, hoist ifs through Fp_2.mul, and expand `u`
  unfolding ["sqrt_fp2", "sqrt_align_fp2_coeff"]; // 
  simplify (addsimps [sqrt_fp_power_lemma, hoist_fp2_mul_thm, u_expander_thm] (cryptol_ss()));
  // eliminate Fp_2.is_equal, and use the trick for order of comparisons
  // and turn mul(field_unit, x) into x
  simplify (addsimps [fp2_is_equal_thm, fp2_mul_unit_exp_thm, sqrt_candidate_comparison_thm']
                     empty_ss);
  w4_unint_z3 (concat ["fp2_exp"] fp2_unints);
  };
