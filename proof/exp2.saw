/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import "../spec/implementation/Types.cry";
import "../spec/Parameters.cry";
import "../spec/FieldExtras.cry";
import "../spec/BLSFieldExtras.cry";

// Temporary home; these belong in fp_overrides
fp2_alg_thms <- for
  [ {{ \ x y z -> Fp_2.mul (Fp_2.mul (x, y), z) == Fp_2.mul (x, Fp_2.mul (y, z)) }} // mul associates
  , {{ \x -> Fp_2.mul (x, Fp_2.field_zero) == Fp_2.field_zero }} // x*0 = 0
  , {{ \x -> Fp_2.mul (Fp_2.field_zero, x) == Fp_2.field_zero }} // 0*x = 0
  , {{ \x -> Fp_2.mul (x, Fp_2.field_unit) == Fp_2.normalize x }} // x*1 = x ish
  // , {{ \x -> Fp_2.mul (x, Fp_2.field_unit) == x }} // x*1 = x TODO: OK in the `Z p` model
  , {{ \x -> Fp_2.mul (Fp_2.field_unit, x) == Fp_2.normalize x }} // 1*x = x ish
  // , {{ \x -> Fp_2.mul (Fp_2.field_unit, x) == x }} // 1*x = x TODO

  , {{ \x -> Fp_2.sq x == Fp_2.mul (x,x) }} // eliminate squaring.  Not always a good idea

  , {{ \ x y z -> Fp_2.add (Fp_2.add (x, y), z) == Fp_2.add (x, Fp_2.add (y, z)) }} // add associates
  , {{ \x -> Fp_2.add (x, Fp_2.field_zero) == Fp_2.normalize x }} // x+0 = x ish
  , {{ \x -> Fp_2.add (Fp_2.field_zero, x) == Fp_2.normalize x }}//  0+x = x ish

  , {{ \ x y -> Fp_2.sub (x, y) == Fp_2.add (x, Fp_2.neg y) }} // eliminate sub in favour of neg

  , {{ \ x -> Fp_2.neg (Fp_2.neg x) == Fp_2.normalize x }} // double negative
  , {{ \ x y -> Fp_2.neg (Fp_2.add (x, y)) == Fp_2.add (Fp_2.neg x, Fp_2.neg y) }} // push neg inside a sum
  , {{ Fp_2.neg Fp_2.field_zero == Fp_2.field_zero }} // -0 = 0
  ] (\ t -> prove_cryptol t []);


////////////////////////////////////////////////////////////////////////////////
// Specifications
////////////////////////////////////////////////////////////////////////////////

// reciprocal_fp2
/*
let reciprocal_fp2_spec = do {
    out_ptr <- crucible_alloc vec384x_type;
    (inp, inp_ptr) <- ptr_to_fresh_readonly "inp" vec384x_type;
    crucible_precond {{ fp2_invariant inp }};
    crucible_execute_func [out_ptr, inp_ptr];
    crucible_points_to out_ptr (crucible_term {{ fp2_rep (inverse_fp2 (fp2_abs inp)) }});
    };
*/

let fp2_unop_spec name op = unop_spec name vec384x_type {{fp2_invariant}} {{fp2_rep}} {{fp2_abs}} op;

let reciprocal_fp2_spec = fp2_unop_spec "reciprocal_fp2" {{ inverse_fp2 }};

// recip_sqrt_fp2_9mod16 is computed using an addition chain.
// We can use rewriting to show that it computes the correct power.

// We then assume as axioms that these powers compute the appropriate functions.

// We can use algebraic rules relating multiplication to exponentiation to show that these chains
// computes the correct values.

// fp2_exp is for positive exponents only, avoiding the need for rewriting x*1 to x
let {{ fp2_exp: t_Fp_2 -> Integer -> t_Fp_2
       fp2_exp x e = if e == 1 then x else Fp_2.mul (x, fp2_exp x (e-1))
       }};

fp2_mult_exp_thm_1 <- prove_cryptol {{\x -> Fp_2.mul (x, x) == fp2_exp x 2 }} [] ;
fp2_mult_exp_thm_2 <- admit_cryptol {{ \x k -> Fp_2.mul (x, fp2_exp x k) == fp2_exp x (k+1) }};
fp2_mult_exp_thm_3 <- admit_cryptol {{ \x k -> Fp_2.mul (fp2_exp x k, x) == fp2_exp x (k+1) }};
fp2_mult_exp_thm_4 <- admit_cryptol {{ \x n k -> Fp_2.mul (fp2_exp x n, fp2_exp x k) == fp2_exp x (k+n) }};
fp2_mult_exp_thm_5 <- admit_cryptol {{ \x n k -> fp2_exp (fp2_exp x n) k == fp2_exp x (k*n) }};
fp2_mult_exp_thm_6 <- admit_cryptol {{ \n -> fp2_exp Fp_2.field_unit n == Fp_2.field_unit }};

fp2_exp_simps <- addsimps (concat [fp2_mult_exp_thm_1, fp2_mult_exp_thm_2, fp2_mult_exp_thm_3
                                  , fp2_mult_exp_thm_4, fp2_mult_exp_thm_5, fp2_mult_exp_thm_6]
                                  fp2_alg_thms)
                           fp2_simpset;

// sqr_n_mul_fp2

// Assumed overrides

let {{
  sqr_n_mul_fp2: t_Fp_2 -> Size_t -> t_Fp_2 -> t_Fp_2
  sqr_n_mul_fp2 x count y = Fp_2.mul (fp2_exp x (2^^count), y)
  }};

let sqr_n_mul_fp2_spec = do {
    out_ptr <- crucible_alloc vec384x_type;
    (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
    count <- crucible_fresh_var "count" size_type;
    (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
    crucible_precond {{ count > 0 }};
    crucible_execute_func [out_ptr, a_ptr, crucible_term count, b_ptr];
    crucible_points_to out_ptr (crucible_term {{ fp2_rep (sqr_n_mul_fp2 (fp2_abs a) count (fp2_abs b)) }});
    };

let sqr_n_mul_fp2_alias_1_2_spec = do {
    (a, a_ptr) <- ptr_to_fresh_readonly "a" vec384x_type;
    count <- crucible_fresh_var "count" size_type;
    (b, b_ptr) <- ptr_to_fresh_readonly "b" vec384x_type;
    crucible_precond {{ count > 0 }};
    crucible_execute_func [a_ptr, a_ptr, crucible_term count, b_ptr];
    crucible_points_to a_ptr (crucible_term {{ fp2_rep (sqr_n_mul_fp2 (fp2_abs a) count (fp2_abs b)) }});
    };

let recip_sqrt_fp2_9mod16_spec = fp2_unop_spec "recip_sqrt_fp2_9mod16" {{ \ x ->  fp2_exp x ((`p^^2-9)/16) }};

////////////////////////////////////////////////////////////////////////////////
// Proofs
////////////////////////////////////////////////////////////////////////////////


// Some additional algebraic rules for Fp operations:
// mul_div_fp_thm <- admit_cryptol {{ \x y z -> Fp.mul (x, Fp.div (y,z)) == Fp.div (Fp.mul (x, y), z) }};
// special case
mul_div_fp_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \x z -> Fp.mul (x, Fp.div (Fp.field_unit,z)) == Fp.div (x, z) }});
div_neg_fp_thm <- admit_cryptol {{ \x y  -> Fp.div (Fp.neg x,y) == Fp.neg (Fp.div (x, y)) }};
// commute add once -- use with caution!
add_commutes_fp_thm <- prove_cryptol {{ \x y  -> Fp.add (x, y) == apply Fp.add (y,x) }} [];


reciprocal_fp2_ov <- custom_verify "reciprocal_fp2"
   (concat [reciprocal_fp_ov] fp_overrides)
   (fp2_unop_spec "reciprocal_fp2" {{ inverse_fp2 }})
   do { // commute Fp.add BEFORE we unfold inverse_fp2; this flips the add used in the code
       simplify (addsimp add_commutes_fp_thm empty_ss);
       unfolding ["inverse_fp2", "fp2_rep", "fp2_abs", "fp2_invariant"]; 
       simplify (addsimps [mul_div_fp_thm, div_neg_fp_thm] (addsimps fp_alg_thms fp_simpset));
       w4_unint_z3 fp_unints;
       };

sqr_n_mul_fp2_ov <- admit "sqr_n_mul_fp2" sqr_n_mul_fp2_spec;
sqr_n_mul_fp2_alias_1_2_ov <- admit "sqr_n_mul_fp2" sqr_n_mul_fp2_alias_1_2_spec;

recip_sqrt_fp2_9mod16_ov <- custom_verify "recip_sqrt_fp2_9mod16"
  (concat [sqr_n_mul_fp2_ov, sqr_n_mul_fp2_alias_1_2_ov]
          (concat fp2_overrides vec_fp2_overrides))
  recip_sqrt_fp2_9mod16_spec
  do {
     // simplify (addsimp recip_fp_algebra_thm empty_ss);
     unfolding ["sqr_n_mul_fp2"];
     simplify fp2_exp_simps;
     w4_unint_z3 (concat ["fp2_exp"] fp2_unints);
     };
  
// Note Appendix G.3 says to take power (q+7)/16 as step 1 , one more than recip_sqrt_fp2_9mod16 does
