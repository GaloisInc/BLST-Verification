/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

// Specifications

// We assume that we use the uniform encoding to the curve, i.e.
// `hash_or_encode` is true. Moreover, we assume that the input points satisfy
// the invariants POINTonE1_affine_invariant (pk) and
// POINTonE2_affine_invariant (sig) and that the signature is a point on the
// curve; ensuring those is the responsibility of the caller. Note that,
// assuming the signature has been deserialized using `blst_p1_uncompress`,
// then there's no need to check whether it's on the curve because that is a
// guarantee of a successful call to `blst_p1_uncompress`. Also note that the
// public key must be a point on the curve and in the right subgroup (this is
// not checked at all by the C code; presumably, public keys should be validated
// separately before use).

// NOTE: calling the function with a null pk is not safe

import "../spec/CoreVerifyPKInG1.cry";

let {{
  blst_core_verify_pk_in_g1_error_precond : POINTonE1_affine_t -> POINTonE2_affine_t -> Bool
  blst_core_verify_pk_in_g1_error_precond pk sig =
       is_point_O E (POINTonE1_affine_abs pk) \/ ( ~(is_point_O E' (POINTonE2_affine_abs sig)) /\ ~is_in_g2_impl (POINTonE2_affine_abs sig) )
       // TODO: Put `aug` back in
  core_verify_pk_in_g1_impl pk sig msg dst = undefined
}};

// case in which no argument is null and the error condition is false
let blst_core_verify_pk_in_g1_non_null_spec msg_len dst_len aug_len = do {
  (pk, pk_ptr) <- ptr_to_fresh_readonly "pk" (llvm_struct "struct.POINTonE1_affine");
  (sig, signature_ptr) <- ptr_to_fresh_readonly "signature" (llvm_struct "struct.POINTonE2_affine");
  llvm_precond {{ POINTonE1_affine_invariant pk /\ POINTonE2_affine_invariant sig /\ is_point_affine E' (POINTonE2_affine_abs sig) /\ ~blst_core_verify_pk_in_g1_error_precond pk sig}};
  hash_or_encode <- llvm_fresh_var "hash_or_encode" (llvm_int 32);
  llvm_precond {{ hash_or_encode != zero }};
  (msg, msg_ptr) <- ptr_to_fresh_readonly "msg" (llvm_array msg_len (llvm_int 8));
  (dst, dst_ptr) <- ptr_to_fresh_readonly "dst" (llvm_array dst_len (llvm_int 8));
  //(aug, aug_ptr) <- ptr_to_fresh_readonly "aug" (llvm_array aug_len (llvm_int 8));
  llvm_execute_func [pk_ptr, signature_ptr, llvm_term hash_or_encode, msg_ptr, llvm_term {{ `msg_len : [64] }}, dst_ptr, llvm_term {{ `dst_len : [64] }}, llvm_null, llvm_term {{ `aug_len : [64] }}];
  llvm_return (llvm_term {{ if core_verify_pk_in_g1_impl (POINTonE1_affine_abs pk) (POINTonE2_affine_abs sig) msg dst then (`BLST_SUCCESS:[32]) else `BLST_VERIFY_FAIL }});
};

blst_core_verify_pk_in_g1_ov <- admit "blst_core_verify_pk_in_g1"
  (blst_core_verify_pk_in_g1_non_null_spec 32 43 0);

// TODO: Might need some guards
verify_g1_eq_thm <- admit_cryptol (rewrite (cryptol_ss())
  {{ \pk sig (msg : [32][8]) (dst : [43][8]) ->
       core_verify_pk_in_g1_impl pk sig msg dst ==
       core_verify_pk_in_g1 pk sig msg dst }});
