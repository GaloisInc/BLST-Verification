// import KeyGen

// module keygen_implementation where

import Parameters as P
import Primitive::Keyless::Hash::SHA256
import Primitive::Symmetric::KDF::HKDF256
import rfc8017

// Implementation types for blst
//

type Vec256 = [4][64]
type Vec384 = [6][64]
type Vec512 = [8][64]
//type Vec768 = [12][64]

type Limb = [64]

// Vectors represent numbers, using a little-endian representation

/**
 * The integer represented by a vector (Vec256, Vec384, ...)
 */
vec_abs: {n} (fin n) => [n]Limb -> Integer
vec_abs limbs = toInteger (join (reverse limbs))

vec256_abs = vec_abs`{256/64}
vec512_abs = vec_abs`{512/64}

/**
 * A vector representing a given integer.  The integer should be non-negative.
 */
vec_rep:  {n} (fin n) => Integer -> [n]Limb
vec_rep x = reverse (split (fromInteger x))

vec256_rep = vec_rep`{256/64}


// for Montgomery mod r

modulus = toInteger 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001 // r

R = 2^^256

R_inv = toInteger 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040

// Montgomery representation of values

R_reduced = R % modulus
R_inv_reduced = R_inv % modulus

to_mont x = (x*R) % modulus

from_mont x = (x*R_inv) % modulus

add_mont x y = (x+y) % modulus

mul_mont x y = (x*y*R_inv) % modulus

property p1 x = mul_mont (from_mont x) (2^^512 % modulus) == (x % modulus)

// concretized versions

modulus_rep = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001

mul_mont_rep: Vec256 -> Vec256 -> Vec256
mul_mont_rep x y = vec256_rep (mul_mont (vec256_abs x) (vec256_abs y))

redc_rep: Vec512 -> Vec256
redc_rep x = vec256_rep (from_mont (vec512_abs x))

RR: Vec256
RR = [14526898881837571181, 3129137299524312099, 419701826671360399, 524908885293268753]

// property p2 x = mul_mont_rep (from_mont_rep x) RR == (x % modulus_rep)

limbs_from_be_bytes_rep48: [48][8] -> [6]Limb
limbs_from_be_bytes_rep48 bytes = reverse (split (join bytes))

/**
 * KeyGen from draft-02
 */
KeyGen_rep: {IKM_len, info_len} ( IKM_len >= 32
                               , validHMACSizes 20 (1+IKM_len)
                               , validHMACSizes 32 (35+info_len)
                               ) =>
        ([IKM_len][8], [info_len][8]) -> Vec256
KeyGen_rep (IKM, key_info) = SK where
    type L = (3 * 256) /^ 16 // (ceil lg2 r) = 256, so L = 3*16=48
    PRK = HKDF_Extract "BLS-SIG-KEYGEN-SALT-" (IKM # [0]) // I2OSP`{xLen=1} 0)
    OKM = HKDF_Expand`{L=L} PRK (key_info # I2OSP`{xLen=2} `L)
    // SK = (OS2IP OKM) % P::r
    OKM_vec = (limbs_from_be_bytes_rep48 OKM) # [0,0]
    SK = mul_mont_rep (redc_rep OKM_vec) RR


