/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 */
import Parameters as P
import ExpandMessage
import Common::bv

// vectors, little-endian representation
type Vec384 = [6][64]
type Vec768 = [12][64]
type Limb = [64]

// abstraction of limb arrays to bvs; TODO use t_Fp instead of bvs?
vec_abs: {n} (fin n) => [n]Limb -> [n*64]
vec_abs limbs = join (reverse limbs)

vec384_abs x = vec_abs`{384/64} x
vec768_abs x = vec_abs`{768/64} x

vec_rep:  {n} (fin n) => [n*64] -> [n]Limb
vec_rep x = reverse (split x)

vec384_rep x = vec_rep`{384/64} x
vec768_rep x = vec_rep`{768/64} x

// Montgomery stuff

R = 2^^384
modulus: Integer
modulus = `P::p
to_mont x = (x*R) % modulus
R_reduced = R % modulus
R_inv = 3231460744492646417066832100176244795738767926513225105051837195607029917124509527734802654356338138714468589979680
property R_R_inv = (R_reduced*R_inv)%modulus == 1
bv_p = (fromInteger modulus):[384]
bv_R = (fromInteger R_reduced):[384]
bv_R_inv = (fromInteger R_inv):[384] // = 0x1bbe869330009d577204078a4f77266aab6fca8f09dc705f13f75b69fe75c040

redc_p_bv: [768] -> [384]
redc_p_bv x = safe_mod (bv_p, safe_product (x, zext bv_R_inv))

redc_rep: Vec768 -> Vec384
redc_rep x = vec384_rep (redc_p_bv (vec768_abs x))

mul_mont_p_bv: [384] -> [384] -> [384]
mul_mont_p_bv a b = safe_mod (bv_p, safe_product (zext a, safe_product (b, bv_R_inv)))

mul_mont_rep: Vec384 -> Vec384 -> Vec384
mul_mont_rep a b = vec384_rep (mul_mont_p_bv (vec384_abs a) (vec384_abs b))

// hash_to_field as implemented in the C code

bv_p0 : [64]
bv_p0 = 0x89f3fffcfffcfffd // -1/p
RRR_rep : Vec384
RRR_rep = [0xed48ac6bd94ca1e0, 0x315f831e03a7adf8, 0x9a53352a615e29dd, 0x34c04e5e921e1761, 0x2512d43565724728, 0x0aa6346091755d4d]

hash_to_field_rep : {msg_len, DST_len, nelems}
               (fin msg_len, fin DST_len, fin nelems
               , DST_len <= 255
               , Expandable msg_len DST_len
               , nelems <= 127
               ) =>
    [msg_len][8] -> [DST_len][8] -> [nelems]Vec384

hash_to_field_rep msg DST = elems where
      type L = 8 // 8 limbs = 512 bits
      uniform_bytes: [nelems*L*8][8]
      uniform_bytes = expand_message msg DST
      elems_768 : [nelems]Vec768
      elems_768 = [ (limbs_from_be_bytes_rep elem_512) # (split zero) | elem_512 <- split`{each=L*8} uniform_bytes]
      elems = [ make_u_i elem_768 | elem_768 <- elems_768 ]
      make_u_i: Vec768 -> Vec384
      make_u_i elem_768 = mul_mont_rep (redc_rep elem_768) RRR_rep

limbs_from_be_bytes_rep: {n} (fin n) => [n*8][8] -> [n]Limb
limbs_from_be_bytes_rep bytes = reverse (split (join bytes))
