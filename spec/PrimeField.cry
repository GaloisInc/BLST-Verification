// Two representation of a finite field with p elements, where p is prime.
//
// The first uses the modular type "Z n", while the second uses bit vectors.
//
// In the first, then, "p" is a type parameter, while in the second it
// is a value parameter.

module PrimeField where

import Common::Field
import Common::ModDivZ
import Common::mod_arith

/**
 * A finite field with a prime number of elements, represented
 * using modular types: `prime_field`k is represented with type `Z k`.
 *
 * The constructor does not check that `k` is prime, so the caller should.
 */
prime_field: {k} (fin k, k >= 3, k > 2*(k/2)) =>  FieldRep (Z k)
prime_field =
    { is_val x = True
    , normalize x = x
    , add (x, y) = x + y
    , sub (x, y) = x - y
    , neg x = -x
    , mul (x,y) = x*y
    , sq x = x*x
    , half x = moddiv x 2
    , div (x,y) = moddiv x y
    , field_zero = 0
    , field_unit = 1
    , is_equal (x, y) = x==y
    }

/**
 * A finite field with a prime number of elements, represented using
 * bit-vector types: `prime_field (k:[n])` is represented with type `[n]`.
 *
 * The constructor does not check that `m` is prime, so the caller should.
 */
prime_field_bv: {n} (fin n, n >= 1) => [n] -> FieldRep [n]
prime_field_bv m =
    { is_val x = x < m
    , normalize x = (x % m)
    , add (x, y) = mod_add (m,x,y)
    , sub (x, y) = mod_sub (m,x,y)
    , neg x = mod_neg (m, x)
    , mul (x,y) = mod_mul (m, x, y)
    , sq x = mod_mul (m, x, x)
    , half x = mod_half (m, x)
    , div (x,y) = mod_div (m, x, y)
    , field_zero = 0
    , field_unit = 1
    , is_equal (x, y) = x==y // does this need to handle unnormalized values?
    }
