/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import Parameters (Fp, t_Fp, to_Fp, E, p)
//import FieldExtras
import ShortWeierstrassCurve (ProjectivePoint, AffinePoint)
import ExpandMessage (Expandable)
import HashToCurveE1 (hash_to_field)
import HashToCurveE1Aux (A', k1s)
import implementation::CurveOperation (point_dadd, point_add, point_double)

map_to_curve_simple_swu: t_Fp -> ProjectivePoint t_Fp
map_to_curve_simple_swu u = undefined

iso_map: ProjectivePoint t_Fp -> ProjectivePoint t_Fp
iso_map p = undefined

Zz_powers : t_Fp -> [15]t_Fp
Zz_powers Z = reverse ([ZZ] # (join ZZ_powers)) where
  ZZ = Fp.sq Z
  ZZ_powers = [[Fp.sq ZZ, Fp.sq (Fp.sq ZZ)]] # [[Fp.mul (zi@0, zi@1), Fp.sq (zi@0)] | i <- [1..6] | zi <- ZZ_powers]

xn : ProjectivePoint t_Fp -> t_Fp
xn p = last xs where
  X = p.0
  Z = p.2
  xs = [x1110] # [Fp.add (Fp.mul (xi, X), kzz@(10-i)) | xi <- xs | i <- [1..10]]
  x1110 = Fp.add (Fp.mul (X, k1s@11), kzz@10)
  kzz = [Fp.mul (ki, zzi) | ki <- k1s | zzi <- Zz_powers Z]

dbl_n_add: ProjectivePoint t_Fp -> Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp
dbl_n_add out n p = point_dadd Fp (db n out) p Fp.field_zero True where
  db: Integer -> ProjectivePoint t_Fp -> ProjectivePoint t_Fp
  db k x =
    if k == 1 then point_double Fp x
    else point_double Fp (db (k-1) x)

clear_cofactor: ProjectivePoint t_Fp -> ProjectivePoint t_Fp
clear_cofactor p = out where
  out1 = point_double Fp p
  out2 = point_add Fp out1 p // NOTE: this is okay because (point_double p) != p or both are point_O
  out3 = dbl_n_add out2 2 p
  out4 = dbl_n_add out3 3 p
  out5 = dbl_n_add out4 9 p
  out6 = dbl_n_add out5 32 p
  out = dbl_n_add out6 16 p

hash_to_curve_opt: {msg_len, DST_len}
               (fin msg_len, fin DST_len
               , DST_len <= 255
               , Expandable msg_len DST_len
               , 8 *( ((lg2 p) + 128) /^ 8 ) >= 384
               ) =>
               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp
hash_to_curve_opt (msg,dst) = map_to_g1 u where
    u = hash_to_field`{count=2} msg dst

map_to_g1: [2]t_Fp -> ProjectivePoint t_Fp
map_to_g1 uv = P where
    Q0 = map_to_curve_simple_swu (uv@0)
    Q1 = map_to_curve_simple_swu (uv@1)
    R = point_dadd Fp Q0 Q1 A' False // This is addition on the isogenous curve
    S = iso_map R
    P = clear_cofactor S
