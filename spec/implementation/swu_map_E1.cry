/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import Parameters (Fp, t_Fp, to_Fp, E, p)
import Common::Field
import FieldExtras
import BLSFieldExtras (sqrt_fp)
import HashToCurveE1Aux (Z, A', B', sqrt, sgn0)
import ShortWeierstrassCurve (ProjectivePoint)

// This is a formalization of map_to_curve_simple_swu_3mod4 as described at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-09#appendix-E.2
// TODO: can we use +, -, *, etc. here?
map_to_curve_simple_swu_3mod4 : t_Fp -> ProjectivePoint t_Fp
map_to_curve_simple_swu_3mod4 u = res where
  //c1 = Fp.div(Fp.sub(`p,3),4)
  c2 = sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z)))

  tv1 = Fp.sq u
  tv3 = Fp.mul (Z, tv1)
  tv2 = Fp.sq tv3
  xd = Fp.add (tv2, tv3)
  x1n = Fp.add (xd, Fp.field_unit)
  x1n_a = Fp.mul (x1n, B')
  xd_a = Fp.mul(Fp.neg A', xd)
  e1 = Fp.is_equal(xd, Fp.field_zero)
  xd_b = if Fp.is_equal(xd_a, Fp.field_zero) then Fp.mul(Z, A') else xd_a // TODO: is this not if e1 ...?

  tv2_a = Fp.sq xd_b
  gxd = Fp.mul(xd_b, tv2_a) // commuted to match the implementation
  tv2_b = Fp.mul(A',  tv2_a)
  gx1 = Fp.sq x1n_a
  gx1_a = Fp.add(gx1, tv2_b)
  gx1_b = Fp.mul(gx1_a,  x1n_a)
  tv2_c = Fp.mul(B', gxd)
  gx1_c = Fp.add(gx1_b, tv2_c)
  tv4 = Fp.sq gxd
  tv2_d = Fp.mul (gx1_c, gxd)
  tv4_b = Fp.mul (tv4, tv2_d)
  y1 = Fp.div (Fp.field_unit, sqrt_fp tv4_b) // this ^((p-3)/4) (exponentition) in the spec; see exp.saw for the rewrite
  y1_b = Fp.mul(y1, tv2_d)
  x2n = Fp.mul(tv3, x1n_a)
  y2 = Fp.mul(y1_b, c2)
  y2_b = Fp.mul(y2, tv1)
  y2_c = Fp.mul(y2_b, u)
  tv2_e = Fp.sq y1_b
  tv2_f = Fp.mul(tv2_e, gxd)
  e2 = Fp.is_equal(tv2_f, gx1_c)
  xn = if e2 then  x1n_a else x2n
  y = if e2 then y1_b else y2_c
  e3 = sgn0(u) == sgn0(y)
  y_a = if e3 then y else Fp.neg y
  // convert to Jacobian coordinates:
  res = (Fp.mul (xn, xd_b), Fp.mul (y_a, gxd), xd_b)

// This is what the implementation does:
map_to_curve_simple_swu_impl : t_Fp -> ProjectivePoint t_Fp
map_to_curve_simple_swu_impl u = res where
  c2 = sqrt (Fp.neg (Fp.mul (Fp.sq Z, Z))) // sqrt(-Z^3)

  // x numerator
  tv1 = Fp.sq u
  tv3 = Fp.mul (Z, tv1)
  tv2 = Fp.add (Fp.sq tv3, tv3)
  x1n = Fp.mul (Fp.add (tv2, Fp.field_unit), B')
  x2n = Fp.mul(tv3, x1n)

  // x denumerator
  xd = Fp.mul(Fp.neg A', tv2)
  e1 = Fp.is_equal(xd, Fp.field_zero)
  xd_b = if e1 then Fp.mul(Z, A') else xd

  // y numerator
  tv2_a = Fp.sq xd_b
  gxd = Fp.mul(xd_b, tv2_a)
  tv2_b = Fp.mul(A',  tv2_a)
  gx1 = Fp.sq x1n
  gx1_a = Fp.add(gx1, tv2_b)
  gx1_b = Fp.mul(gx1_a,  x1n)
  tv2_c = Fp.mul(B', gxd)
  gx1_c = Fp.add(gx1_b, tv2_c)
  tv4 = Fp.sq gxd
  tv2_d = Fp.mul (gx1_c, gxd)
  tv4_b = Fp.mul (tv4, tv2_d)
  y1 = Fp.div (Fp.field_unit, sqrt_fp tv4_b)
  e2 = Fp.is_equal (Fp.sq (Fp.mul (y1, tv4_b)), tv4_b) // this appears in the body of recip_sqrt
  y1_b = Fp.mul(y1, tv2_d)
  y2 = Fp.mul(y1_b, c2)
  y2_b = Fp.mul(y2, tv1)
  y2_c = Fp.mul(y2_b, u)

  xn = if e2 then  x1n else x2n
  y = if e2 then y1_b else y2_c

  y_a = if sgn0(u) != sgn0(y) then Fp.neg y else y // TODO: can Z3 handle that? (C code uses xor)

  // convert to Jacobian coordinates:
  res = (Fp.mul (xn, xd_b), Fp.mul (y_a, gxd), xd_b)
