/*
 * Copyright (c) 2020 Galois, Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
*/

import Parameters (Fp_2, t_Fp_2)
import ShortWeierstrassCurve (ProjectivePoint)
/* import BLSFieldExtras (sqrt_fp, fp_exp) */
import ExpandMessage (Expandable)
import implementation::CurveOperation (point_dadd, point_add, point_double)
import HashToCurveE2
import HashToCurveE2Aux as Aux

map_to_curve_E2_prime_impl : t_Fp_2 -> ProjectivePoint t_Fp_2
map_to_curve_E2_prime_impl = undefined

/* isogeny_map_to_E2_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2 */
/* isogeny_map_to_E2_impl = undefined */

clear_cofactor_E2_impl:  ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2
clear_cofactor_E2_impl = undefined

map_to_g2_impl: [2]t_Fp_2 -> ProjectivePoint t_Fp_2
map_to_g2_impl uv = P where
    Q0 = map_to_curve_E2_prime_impl (uv@0)
    Q2 = map_to_curve_E2_prime_impl (uv@1)
    R = point_dadd Fp_2 Q0 Q2 A' False // This is addition on the isogenous curve E'
    S = isogeny_map_to_E2_impl R
    P = clear_cofactor_E2_impl S

hash_to_curve_opt_impl: {msg_len, DST_len}
               (fin msg_len, fin DST_len
               , DST_len <= 255
               , Expandable msg_len DST_len
               , 8 *( ((lg2 p) + 128) /^ 8 ) >= 384
               ) =>
               ([msg_len][8], [DST_len][8]) -> ProjectivePoint t_Fp_2
hash_to_curve_opt_impl (msg,dst) = map_to_g2_impl u where
    u = hash_to_field`{count=2} msg dst

isogeny_map_to_E2_impl: ProjectivePoint t_Fp_2 -> ProjectivePoint t_Fp_2
isogeny_map_to_E2_impl (X, Y, Z) = to_jacobian xn xd yn yd where
  zzs = Zz_powers Z
  xn = map_fp2 (kzzs#[last Aux::k1s]) X where
    kzzs = map_fp2_times_Zz`{n=3} Aux::k1s zzs
  xd = Fp_2.mul (xs, last zzs) where // multiply by Z^2
    xs = map_fp2 ((take`{front=1}kzzs)#[xkzz1]) X
    xkzz1 = Fp_2.add (X, last kzzs)
    kzzs = map_fp2_times_Zz`{n=2} Aux::k2s zzs
  yn = Fp_2.mul (map_fp2 (kzzs#[last Aux::k3s]) X, Y) where
    kzzs = map_fp2_times_Zz`{n=3} Aux::k3s zzs
  yd = Fp_2.mul (Fp_2.mul (xs, Z), last zzs) where // multiply by Z^3
    xs = map_fp2 ((take`{front=2}kzzs)#[xkzz2]) X
    xkzz2 = Fp_2.add (X, last kzzs)
    kzzs = map_fp2_times_Zz`{n=3} Aux::k4s zzs

// NOTE: below there's some duplication with HashToG1, but it would be cumbersome to factor this out due to the peculiarities of the current Cryptol module system
to_jacobian xn xd yn yd = (X, Y, Z) where
  Z = Fp_2.mul (xd, yd)
  X = Fp_2.mul (Fp_2.mul (xn, yd) , Z)
  Y = Fp_2.mul (Fp_2.mul (Fp_2.sq Z, xd) , yn)

map_fp2_times_Zz : {m1,m2,n} (fin n, fin m2, m1 >= n, m2 >= n) => [m1]t_Fp_2 -> [m2]t_Fp_2 -> [n]t_Fp_2
map_fp2_times_Zz ks zzs = zipWith (curry Fp_2.mul) (take`{front=n}ks) (drop`{back=n}zzs)

map_fp2 kzzs x = last rs where
  rs = [last kzzs] # [F.add (F.mul (ri, x), kzzi) | kzzi <- tail (reverse kzzs) | ri <- rs]

Zz_powers : t_Fp_2 -> [3]t_Fp_2
Zz_powers Z = reverse [Fp_2.sq Z, Fp_2.sq (Fp_2.sq Z), Fp_2.mul (Fp_2.sq (Fp_2.sq Z), Fp_2.sq Z)]
